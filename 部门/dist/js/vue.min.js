! function(t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.Vue = e()
}(this, function() {
    "use strict";

    function t(e, n, r) {
        if (i(e, n)) return void(e[n] = r);
        if (e._isVue) return void t(e._data, n, r);
        var s = e.__ob__;
        if (!s) return void(e[n] = r);
        if (s.convert(n, r), s.dep.notify(), s.vms)
            for (var o = s.vms.length; o--;) {
                var a = s.vms[o];
                a._proxy(n), a._digest()
            }
        return r
    }

    function e(t, e) {
        if (i(t, e)) {
            delete t[e];
            var n = t.__ob__;
            if (n && (n.dep.notify(), n.vms))
                for (var r = n.vms.length; r--;) {
                    var s = n.vms[r];
                    s._unproxy(e), s._digest()
                }
        }
    }

    function i(t, e) {
        return mi.call(t, e)
    }

    function n(t) {
        return gi.test(t)
    }

    function r(t) {
        var e = (t + "").charCodeAt(0);
        return 36 === e || 95 === e
    }

    function s(t) {
        return null == t ? "" : t.toString()
    }

    function o(t) {
        if ("string" != typeof t) return t;
        var e = Number(t);
        return isNaN(e) ? t : e
    }

    function a(t) {
        return "true" === t ? !0 : "false" === t ? !1 : t
    }

    function h(t) {
        var e = t.charCodeAt(0),
            i = t.charCodeAt(t.length - 1);
        return e !== i || 34 !== e && 39 !== e ? t : t.slice(1, -1)
    }

    function l(t) {
        return t.replace(_i, c)
    }

    function c(t, e) {
        return e ? e.toUpperCase() : ""
    }

    function u(t) {
        return t.replace(bi, "$1-$2").toLowerCase()
    }

    function f(t) {
        return t.replace(yi, c)
    }

    function p(t, e) {
        return function(i) {
            var n = arguments.length;
            return n ? n > 1 ? t.apply(e, arguments) : t.call(e, i) : t.call(e)
        }
    }

    function d(t, e) {
        e = e || 0;
        for (var i = t.length - e, n = new Array(i); i--;) n[i] = t[i + e];
        return n
    }

    function v(t, e) {
        for (var i = Object.keys(e), n = i.length; n--;) t[i[n]] = e[i[n]];
        return t
    }

    function m(t) {
        return null !== t && "object" == typeof t
    }

    function g(t) {
        return Ci.call(t) === wi
    }

    function _(t, e, i, n) {
        Object.defineProperty(t, e, {
            value: i,
            enumerable: !!n,
            writable: !0,
            configurable: !0
        })
    }

    function b(t, e) {
        var i, n, r, s, o, a = function h() {
            var a = Date.now() - s;
            e > a && a >= 0 ? i = setTimeout(h, e - a) : (i = null, o = t.apply(r, n), i || (r = n = null))
        };
        return function() {
            return r = this, n = arguments, s = Date.now(), i || (i = setTimeout(a, e)), o
        }
    }

    function y(t, e) {
        for (var i = t.length; i--;)
            if (t[i] === e) return i;
        return -1
    }

    function C(t) {
        var e = function i() {
            return i.cancelled ? void 0 : t.apply(this, arguments)
        };
        return e.cancel = function() {
            e.cancelled = !0
        }, e
    }

    function w(t, e) {
        return t == e || (m(t) && m(e) ? JSON.stringify(t) === JSON.stringify(e) : !1)
    }

    function $(t) {
        this.size = 0, this.limit = t, this.head = this.tail = void 0, this._keymap = Object.create(null)
    }

    function k() {
        var t, e = Ri.slice(Mi, Bi).trim();
        if (e) {
            t = {};
            var i = e.match(Gi);
            t.name = i[0], i.length > 1 && (t.args = i.slice(1).map(x))
        }
        t && (Hi.filters = Hi.filters || []).push(t), Mi = Bi + 1
    }

    function x(t) {
        if (Zi.test(t)) return {
            value: o(t),
            dynamic: !1
        };
        var e = h(t),
            i = e === t;
        return {
            value: i ? t : e,
            dynamic: i
        }
    }

    function A(t) {
        var e = Qi.get(t);
        if (e) return e;
        for (Ri = t, zi = Ii = !1, Ui = qi = Ji = 0, Mi = 0, Hi = {}, Bi = 0, Vi = Ri.length; Vi > Bi; Bi++)
            if (Wi = Li, Li = Ri.charCodeAt(Bi), zi) 39 === Li && 92 !== Wi && (zi = !zi);
            else if (Ii) 34 === Li && 92 !== Wi && (Ii = !Ii);
        else if (124 === Li && 124 !== Ri.charCodeAt(Bi + 1) && 124 !== Ri.charCodeAt(Bi - 1)) null == Hi.expression ? (Mi = Bi + 1, Hi.expression = Ri.slice(0, Bi).trim()) : k();
        else switch (Li) {
            case 34:
                Ii = !0;
                break;
            case 39:
                zi = !0;
                break;
            case 40:
                Ji++;
                break;
            case 41:
                Ji--;
                break;
            case 91:
                qi++;
                break;
            case 93:
                qi--;
                break;
            case 123:
                Ui++;
                break;
            case 125:
                Ui--
        }
        return null == Hi.expression ? Hi.expression = Ri.slice(0, Bi).trim() : 0 !== Mi && k(), Qi.put(t, Hi), Hi
    }

    function O(t) {
        return t.replace(Xi, "\\$&")
    }

    function N() {
        var t = O(an.delimiters[0]),
            e = O(an.delimiters[1]),
            i = O(an.unsafeDelimiters[0]),
            n = O(an.unsafeDelimiters[1]);
        tn = new RegExp(i + "(.+?)" + n + "|" + t + "(.+?)" + e, "g"), en = new RegExp("^" + i + ".*" + n + "$"), Yi = new $(1e3)
    }

    function T(t) {
        Yi || N();
        var e = Yi.get(t);
        if (e) return e;
        if (t = t.replace(/\n/g, ""), !tn.test(t)) return null;
        for (var i, n, r, s, o, a, h = [], l = tn.lastIndex = 0; i = tn.exec(t);) n = i.index, n > l && h.push({
            value: t.slice(l, n)
        }), r = en.test(i[0]), s = r ? i[1] : i[2], o = s.charCodeAt(0), a = 42 === o, s = a ? s.slice(1) : s, h.push({
            tag: !0,
            value: s.trim(),
            html: r,
            oneTime: a
        }), l = n + i[0].length;
        return l < t.length && h.push({
            value: t.slice(l)
        }), Yi.put(t, h), h
    }

    function j(t) {
        return t.length > 1 ? t.map(function(t) {
            return E(t)
        }).join("+") : E(t[0], !0)
    }

    function E(t, e) {
        return t.tag ? S(t.value, e) : '"' + t.value + '"'
    }

    function S(t, e) {
        if (nn.test(t)) {
            var i = A(t);
            return i.filters ? "this._applyFilters(" + i.expression + ",null," + JSON.stringify(i.filters) + ",false)" : "(" + t + ")"
        }
        return e ? t : "(" + t + ")"
    }

    function F(t) {
        return t.replace(tn, "")
    }

    function D(t, e, i, n) {
        H(t, 1, function() {
            e.appendChild(t)
        }, i, n)
    }

    function P(t, e, i, n) {
        H(t, 1, function() {
            z(t, e)
        }, i, n)
    }

    function R(t, e, i) {
        H(t, -1, function() {
            U(t)
        }, e, i)
    }

    function H(t, e, i, n, r) {
        var s = t.__v_trans;
        if (!s || !s.hooks && !Ti || !n._isCompiled || n.$parent && !n.$parent._isCompiled) return i(), void(r && r());
        var o = e > 0 ? "enter" : "leave";
        s[o](i, r)
    }

    function L(t) {
        return "string" == typeof t && (t = document.querySelector(t)), t
    }

    function W(t) {
        var e = document.documentElement,
            i = t && t.parentNode;
        return e === t || e === i || !(!i || 1 !== i.nodeType || !e.contains(i))
    }

    function B(t, e) {
        var i = t.getAttribute(e);
        return null !== i && t.removeAttribute(e), i
    }

    function V(t, e) {
        var i = B(t, ":" + e);
        return null === i && (i = B(t, "v-bind:" + e)), i
    }

    function M(t, e) {
        return t.hasAttribute(e) || t.hasAttribute(":" + e) || t.hasAttribute("v-bind:" + e)
    }

    function z(t, e) {
        e.parentNode.insertBefore(t, e)
    }

    function I(t, e) {
        e.nextSibling ? z(t, e.nextSibling) : e.parentNode.appendChild(t)
    }

    function U(t) {
        t.parentNode.removeChild(t)
    }

    function q(t, e) {
        e.firstChild ? z(t, e.firstChild) : e.appendChild(t)
    }

    function J(t, e) {
        var i = t.parentNode;
        i && i.replaceChild(e, t)
    }

    function Q(t, e, i) {
        t.addEventListener(e, i)
    }

    function G(t, e, i) {
        t.removeEventListener(e, i)
    }

    function Z(t, e) {
        !Ai || t instanceof SVGElement ? t.setAttribute("class", e) : t.className = e
    }

    function K(t, e) {
        if (t.classList) t.classList.add(e);
        else {
            var i = " " + (t.getAttribute("class") || "") + " ";
            i.indexOf(" " + e + " ") < 0 && Z(t, (i + e).trim())
        }
    }

    function X(t, e) {
        if (t.classList) t.classList.remove(e);
        else {
            for (var i = " " + (t.getAttribute("class") || "") + " ", n = " " + e + " "; i.indexOf(n) >= 0;) i = i.replace(n, " ");
            Z(t, i.trim())
        }
        t.className || t.removeAttribute("class")
    }

    function Y(t, e) {
        var i, n;
        if (it(t) && t.content instanceof DocumentFragment && (t = t.content), t.hasChildNodes())
            for (tt(t), n = e ? document.createDocumentFragment() : document.createElement("div"); i = t.firstChild;) n.appendChild(i);
        return n
    }

    function tt(t) {
        et(t, t.firstChild), et(t, t.lastChild)
    }

    function et(t, e) {
        e && 3 === e.nodeType && !e.data.trim() && t.removeChild(e)
    }

    function it(t) {
        return t.tagName && "template" === t.tagName.toLowerCase()
    }

    function nt(t, e) {
        var i = an.debug ? document.createComment(t) : document.createTextNode(e ? " " : "");
        return i.__vue_anchor = !0, i
    }

    function rt(t) {
        if (t.hasAttributes())
            for (var e = t.attributes, i = 0, n = e.length; n > i; i++) {
                var r = e[i].name;
                if (ln.test(r)) return l(r.replace(ln, ""))
            }
    }

    function st(t, e, i) {
        for (var n; t !== e;) n = t.nextSibling, i(t), t = n;
        i(e)
    }

    function ot(t, e, i, n, r) {
        function s() {
            if (a++, o && a >= h.length) {
                for (var t = 0; t < h.length; t++) n.appendChild(h[t]);
                r && r()
            }
        }
        var o = !1,
            a = 0,
            h = [];
        st(t, e, function(t) {
            t === e && (o = !0), h.push(t), R(t, i, s)
        })
    }

    function at(t, e) {
        var i = t.tagName.toLowerCase(),
            n = t.hasAttributes();
        if (cn.test(i) || un.test(i)) {
            if (n) return ht(t)
        } else {
            if (_t(e, "components", i)) return {
                id: i
            };
            var r = n && ht(t);
            if (r) return r
        }
    }

    function ht(t) {
        var e = B(t, "is");
        return null != e ? {
            id: e
        } : (e = V(t, "is"), null != e ? {
            id: e,
            dynamic: !0
        } : void 0)
    }

    function lt(t, e, i) {
        var n = e.path;
        i = ut(e, i), t[n] = t._data[n] = ct(e, i) ? i : void 0
    }

    function ct(t, e) {
        if (null === t.raw && !t.required) return !0;
        var i, n = t.options,
            r = n.type,
            s = !0;
        if (r && (r === String ? (i = "string", s = typeof e === i) : r === Number ? (i = "number", s = "number" == typeof e) : r === Boolean ? (i = "boolean", s = "boolean" == typeof e) : r === Function ? (i = "function", s = "function" == typeof e) : r === Object ? (i = "object", s = g(e)) : r === Array ? (i = "array", s = $i(e)) : s = e instanceof r), !s) return !1;
        var o = n.validator;
        return o && !o.call(null, e) ? !1 : !0
    }

    function ut(t, e) {
        var i = t.options.coerce;
        return i ? i(e) : e
    }

    function ft(e, n) {
        var r, s, o;
        for (r in n) s = e[r], o = n[r], i(e, r) ? m(s) && m(o) && ft(s, o) : t(e, r, o);
        return e
    }

    function pt(t, e) {
        var i = Object.create(t);
        return e ? v(i, mt(e)) : i
    }

    function dt(t) {
        if (t.components)
            for (var e, i = t.components = mt(t.components), n = Object.keys(i), r = 0, s = n.length; s > r; r++) {
                var o = n[r];
                cn.test(o) || un.test(o) || (e = i[o], g(e) && (i[o] = ci.extend(e)))
            }
    }

    function vt(t) {
        var e, i, n = t.props;
        if ($i(n))
            for (t.props = {}, e = n.length; e--;) i = n[e], "string" == typeof i ? t.props[i] = null : i.name && (t.props[i.name] = i);
        else if (g(n)) {
            var r = Object.keys(n);
            for (e = r.length; e--;) i = n[r[e]], "function" == typeof i && (n[r[e]] = {
                type: i
            })
        }
    }

    function mt(t) {
        if ($i(t)) {
            for (var e, i = {}, n = t.length; n--;) {
                e = t[n];
                var r = "function" == typeof e ? e.options && e.options.name || e.id : e.name || e.id;
                r && (i[r] = e)
            }
            return i
        }
        return t
    }

    function gt(t, e, n) {
        function r(i) {
            var r = fn[i] || pn;
            o[i] = r(t[i], e[i], n, i)
        }
        dt(e), vt(e);
        var s, o = {};
        if (e.mixins)
            for (var a = 0, h = e.mixins.length; h > a; a++) t = gt(t, e.mixins[a], n);
        for (s in t) r(s);
        for (s in e) i(t, s) || r(s);
        return o
    }

    function _t(t, e, i) {
        var n, r = t[e];
        return r[i] || r[n = l(i)] || r[n.charAt(0).toUpperCase() + n.slice(1)]
    }

    function bt(t, e, i) {}

    function yt() {
        this.id = mn++, this.subs = []
    }

    function Ct(t) {
        if (this.value = t, this.dep = new yt, _(t, "__ob__", this), $i(t)) {
            var e = ki ? wt : $t;
            e(t, vn, gn), this.observeArray(t)
        } else this.walk(t)
    }

    function wt(t, e) {
        t.__proto__ = e
    }

    function $t(t, e, i) {
        for (var n, r = i.length; r--;) n = i[r], _(t, n, e[n])
    }

    function kt(t, e) {
        if (t && "object" == typeof t) {
            var n;
            return i(t, "__ob__") && t.__ob__ instanceof Ct ? n = t.__ob__ : ($i(t) || g(t)) && Object.isExtensible(t) && !t._isVue && (n = new Ct(t)), n && e && n.addVm(e), n
        }
    }

    function xt(t, e, i) {
        var n, r, s = new yt;
        if (an.convertAllProperties) {
            var o = Object.getOwnPropertyDescriptor(t, e);
            if (o && o.configurable === !1) return;
            n = o && o.get, r = o && o.set
        }
        var a = kt(i);
        Object.defineProperty(t, e, {
            enumerable: !0,
            configurable: !0,
            get: function() {
                var e = n ? n.call(t) : i;
                if (yt.target && (s.depend(), a && a.dep.depend(), $i(e)))
                    for (var r, o = 0, h = e.length; h > o; o++) r = e[o], r && r.__ob__ && r.__ob__.dep.depend();
                return e
            },
            set: function(e) {
                var o = n ? n.call(t) : i;
                e !== o && (r ? r.call(t, e) : i = e, a = kt(e), s.notify())
            }
        })
    }

    function At(t) {
        t.prototype._init = function(t) {
            t = t || {}, this.$el = null, this.$parent = t.parent, this.$root = this.$parent ? this.$parent.$root : this, this.$children = [], this.$refs = {}, this.$els = {}, this._watchers = [], this._directives = [], this._uid = bn++, this._isVue = !0, this._events = {}, this._eventsCount = {}, this._isFragment = !1, this._fragment = this._fragmentStart = this._fragmentEnd = null, this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = !1, this._unlinkFn = null, this._context = t._context || this.$parent, this._scope = t._scope, this._frag = t._frag, this._frag && this._frag.children.push(this), this.$parent && this.$parent.$children.push(this), t = this.$options = gt(this.constructor.options, t, this), this._updateRef(), this._data = {}, this._callHook("init"), this._initState(), this._initEvents(), this._callHook("created"), t.el && this.$mount(t.el)
        }
    }

    function Ot(t) {
        if (void 0 === t) return "eof";
        var e = t.charCodeAt(0);
        switch (e) {
            case 91:
            case 93:
            case 46:
            case 34:
            case 39:
            case 48:
                return t;
            case 95:
            case 36:
                return "ident";
            case 32:
            case 9:
            case 10:
            case 13:
            case 160:
            case 65279:
            case 8232:
            case 8233:
                return "ws"
        }
        return e >= 97 && 122 >= e || e >= 65 && 90 >= e ? "ident" : e >= 49 && 57 >= e ? "number" : "else"
    }

    function Nt(t) {
        var e = t.trim();
        return "0" === t.charAt(0) && isNaN(t) ? !1 : n(e) ? h(e) : "*" + e
    }

    function Tt(t) {
        function e() {
            var e = t[c + 1];
            return u === jn && "'" === e || u === En && '"' === e ? (c++, n = "\\" + e, p[Cn](), !0) : void 0
        }
        var i, n, r, s, o, a, h, l = [],
            c = -1,
            u = xn,
            f = 0,
            p = [];
        for (p[wn] = function() {
                void 0 !== r && (l.push(r), r = void 0)
            }, p[Cn] = function() {
                void 0 === r ? r = n : r += n
            }, p[$n] = function() {
                p[Cn](), f++
            }, p[kn] = function() {
                if (f > 0) f--, u = Tn, p[Cn]();
                else {
                    if (f = 0, r = Nt(r), r === !1) return !1;
                    p[wn]()
                }
            }; null != u;)
            if (c++, i = t[c], "\\" !== i || !e()) {
                if (s = Ot(i), h = Dn[u], o = h[s] || h["else"] || Fn, o === Fn) return;
                if (u = o[0], a = p[o[1]], a && (n = o[2], n = void 0 === n ? i : n, a() === !1)) return;
                if (u === Sn) return l.raw = t, l
            }
    }

    function jt(t) {
        var e = yn.get(t);
        return e || (e = Tt(t), e && yn.put(t, e)), e
    }

    function Et(t, e) {
        return Wt(e).get(t)
    }

    function St(e, i, n) {
        var r = e;
        if ("string" == typeof i && (i = Tt(i)), !i || !m(e)) return !1;
        for (var s, o, a = 0, h = i.length; h > a; a++) s = e, o = i[a], "*" === o.charAt(0) && (o = Wt(o.slice(1)).get.call(r, r)), h - 1 > a ? (e = e[o], m(e) || (e = {}, t(s, o, e))) : $i(e) ? e.$set(o, n) : o in e ? e[o] = n : t(e, o, n);
        return !0
    }

    function Ft(t, e) {
        var i = Qn.length;
        return Qn[i] = e ? t.replace(Mn, "\\n") : t, '"' + i + '"'
    }

    function Dt(t) {
        var e = t.charAt(0),
            i = t.slice(1);
        return Ln.test(i) ? t : (i = i.indexOf('"') > -1 ? i.replace(In, Pt) : i, e + "scope." + i)
    }

    function Pt(t, e) {
        return Qn[e]
    }

    function Rt(t) {
        Bn.test(t), Qn.length = 0;
        var e = t.replace(zn, Ft).replace(Vn, "");
        return e = (" " + e).replace(qn, Dt).replace(In, Pt), Ht(e)
    }

    function Ht(t) {
        try {
            return new Function("scope", "return " + t + ";")
        } catch (e) {}
    }

    function Lt(t) {
        var e = jt(t);
        return e ? function(t, i) {
            St(t, e, i)
        } : void 0
    }

    function Wt(t, e) {
        t = t.trim();
        var i = Rn.get(t);
        if (i) return e && !i.set && (i.set = Lt(i.exp)), i;
        var n = {
            exp: t
        };
        return n.get = Bt(t) && t.indexOf("[") < 0 ? Ht("scope." + t) : Rt(t), e && (n.set = Lt(t)), Rn.put(t, n), n
    }

    function Bt(t) {
        return Un.test(t) && !Jn.test(t) && "Math." !== t.slice(0, 5)
    }

    function Vt() {
        Zn = [], Kn = [], Xn = {}, Yn = {}, tr = er = !1
    }

    function Mt() {
        zt(Zn), er = !0, zt(Kn), Vt()
    }

    function zt(t) {
        for (var e = 0; e < t.length; e++) {
            var i = t[e],
                n = i.id;
            Xn[n] = null, i.run()
        }
    }

    function It(t) {
        var e = t.id;
        if (null == Xn[e]) {
            if (er && !t.user) return void t.run();
            var i = t.user ? Kn : Zn;
            Xn[e] = i.length, i.push(t), tr || (tr = !0, Di(Mt))
        }
    }

    function Ut(t, e, i, n) {
        n && v(this, n);
        var r = "function" == typeof e;
        if (this.vm = t, t._watchers.push(this), this.expression = r ? e.toString() : e, this.cb = i, this.id = ++ir, this.active = !0, this.dirty = this.lazy, this.deps = Object.create(null), this.newDeps = null, this.prevError = null, r) this.getter = e, this.setter = void 0;
        else {
            var s = Wt(e, this.twoWay);
            this.getter = s.get, this.setter = s.set
        }
        this.value = this.lazy ? void 0 : this.get(), this.queued = this.shallow = !1
    }

    function qt(t) {
        var e, i;
        if ($i(t))
            for (e = t.length; e--;) qt(t[e]);
        else if (m(t))
            for (i = Object.keys(t), e = i.length; e--;) qt(t[i[e]])
    }

    function Jt(t) {
        if (lr[t]) return lr[t];
        var e = Qt(t);
        return lr[t] = lr[e] = e, e
    }

    function Qt(t) {
        t = u(t);
        var e = l(t),
            i = e.charAt(0).toUpperCase() + e.slice(1);
        if (cr || (cr = document.createElement("div")), e in cr.style) return t;
        for (var n, r = or.length; r--;)
            if (n = ar[r] + i, n in cr.style) return or[r] + t
    }

    function Gt(t, e) {
        var i = e.map(function(t) {
            var e = t.charCodeAt(0);
            return e > 47 && 58 > e ? parseInt(t, 10) : 1 === t.length && (e = t.toUpperCase().charCodeAt(0), e > 64 && 91 > e) ? e : _r[t]
        });
        return function(e) {
            return i.indexOf(e.keyCode) > -1 ? t.call(this, e) : void 0
        }
    }

    function Zt(t) {
        return function(e) {
            return e.stopPropagation(), t.call(this, e)
        }
    }

    function Kt(t) {
        return function(e) {
            return e.preventDefault(), t.call(this, e)
        }
    }

    function Xt(t, e, i) {
        for (var n, r, s, o = e ? [] : null, a = 0, h = t.options.length; h > a; a++)
            if (n = t.options[a], s = i ? n.hasAttribute("selected") : n.selected) {
                if (r = n.hasOwnProperty("_value") ? n._value : n.value, !e) return r;
                o.push(r)
            }
        return o
    }

    function Yt(t, e) {
        for (var i = t.length; i--;)
            if (w(t[i], e)) return i;
        return -1
    }

    function te(t) {
        return it(t) && t.content instanceof DocumentFragment
    }

    function ee(t, e) {
        var i = Or.get(t);
        if (i) return i;
        var n = document.createDocumentFragment(),
            r = t.match(jr),
            s = Er.test(t);
        if (r || s) {
            var o = r && r[1],
                a = Tr[o] || Tr.efault,
                h = a[0],
                l = a[1],
                c = a[2],
                u = document.createElement("div");
            for (e || (t = t.trim()), u.innerHTML = l + t + c; h--;) u = u.lastChild;
            for (var f; f = u.firstChild;) n.appendChild(f)
        } else n.appendChild(document.createTextNode(t));
        return Or.put(t, n), n
    }

    function ie(t) {
        if (te(t)) return tt(t.content), t.content;
        if ("SCRIPT" === t.tagName) return ee(t.textContent);
        for (var e, i = ne(t), n = document.createDocumentFragment(); e = i.firstChild;) n.appendChild(e);
        return tt(n), n
    }

    function ne(t) {
        if (!t.querySelectorAll) return t.cloneNode();
        var e, i, n, r = t.cloneNode(!0);
        if (Sr) {
            var s = r;
            if (te(t) && (t = t.content, s = r.content), i = t.querySelectorAll("template"), i.length)
                for (n = s.querySelectorAll("template"), e = n.length; e--;) n[e].parentNode.replaceChild(ne(i[e]), n[e])
        }
        if (Fr)
            if ("TEXTAREA" === t.tagName) r.value = t.value;
            else if (i = t.querySelectorAll("textarea"), i.length)
            for (n = r.querySelectorAll("textarea"), e = n.length; e--;) n[e].value = i[e].value;
        return r
    }

    function re(t, e, i) {
        var n, r;
        return t instanceof DocumentFragment ? (tt(t), e ? ne(t) : t) : ("string" == typeof t ? i || "#" !== t.charAt(0) ? r = ee(t, i) : (r = Nr.get(t), r || (n = document.getElementById(t.slice(1)), n && (r = ie(n), Nr.put(t, r)))) : t.nodeType && (r = ie(t)), r && e ? ne(r) : r)
    }

    function se(t, e, i, n, r, s) {
        this.children = [], this.childFrags = [], this.vm = e, this.scope = r, this.inserted = !1, this.parentFrag = s, s && s.childFrags.push(this), this.unlink = t(e, i, n, r, this);
        var o = this.single = 1 === i.childNodes.length && !i.childNodes[0].__vue_anchor;
        o ? (this.node = i.childNodes[0], this.before = oe, this.remove = ae) : (this.node = nt("fragment-start"), this.end = nt("fragment-end"), this.frag = i, q(this.node, i), i.appendChild(this.end), this.before = he, this.remove = le), this.node.__vfrag__ = this
    }

    function oe(t, e) {
        this.inserted = !0;
        var i = e !== !1 ? P : z;
        i(this.node, t, this.vm), W(this.node) && this.callHook(ce)
    }

    function ae() {
        this.inserted = !1;
        var t = W(this.node),
            e = this;
        e.callHook(ue), R(this.node, this.vm, function() {
            t && e.callHook(fe), e.destroy()
        })
    }

    function he(t, e) {
        this.inserted = !0;
        var i = this.vm,
            n = e !== !1 ? P : z;
        st(this.node, this.end, function(e) {
            n(e, t, i)
        }), W(this.node) && this.callHook(ce)
    }

    function le() {
        this.inserted = !1;
        var t = this,
            e = W(this.node);
        t.callHook(ue), ot(this.node, this.end, this.vm, this.frag, function() {
            e && t.callHook(fe), t.destroy()
        })
    }

    function ce(t) {
        t._isAttached || t._callHook("attached")
    }

    function ue(t) {
        t.$destroy(!1, !0)
    }

    function fe(t) {
        t._isAttached && t._callHook("detached")
    }

    function pe(t, e) {
        this.vm = t;
        var i, n = "string" == typeof e;
        n || it(e) ? i = re(e, !0) : (i = document.createDocumentFragment(), i.appendChild(e)), this.template = i;
        var r, s = t.constructor.cid;
        if (s > 0) {
            var o = s + (n ? e : e.outerHTML);
            r = Pr.get(o), r || (r = Ae(i, t.$options, !0), Pr.put(o, r))
        } else r = Ae(i, t.$options, !0);
        this.linker = r
    }

    function de(t, e, i) {
        var n = t.node.previousSibling;
        if (n) {
            for (t = n.__vfrag__; !(t && t.forId === i && t.inserted || n === e);) {
                if (n = n.previousSibling, !n) return;
                t = n.__vfrag__
            }
            return t
        }
    }

    function ve(t) {
        var e = t.node;
        if (t.end)
            for (; !e.__vue__ && e !== t.end && e.nextSibling;) e = e.nextSibling;
        return e.__vue__
    }

    function me(t) {
        for (var e = -1, i = new Array(t); ++e < t;) i[e] = e;
        return i
    }

    function ge(t) {
        Mr.push(t), zr || (zr = !0, Di(_e))
    }

    function _e() {
        for (var t = document.documentElement.offsetHeight, e = 0; e < Mr.length; e++) Mr[e]();
        return Mr = [], zr = !1, t
    }

    function be(t, e, i, n) {
        this.id = e, this.el = t, this.enterClass = e + "-enter", this.leaveClass = e + "-leave", this.hooks = i, this.vm = n, this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null, this.justEntered = !1, this.entered = this.left = !1, this.typeCache = {};
        var r = this;
        ["enterNextTick", "enterDone", "leaveNextTick", "leaveDone"].forEach(function(t) {
            r[t] = p(r[t], r)
        })
    }

    function ye(t) {
        return !(t.offsetWidth || t.offsetHeight || t.getClientRects().length)
    }

    function Ce(t) {
        for (var e = {}, i = t.trim().split(/\s+/), n = i.length; n--;) e[i[n]] = !0;
        return e
    }

    function we(t, e) {
        return $i(t) ? t.indexOf(e) > -1 : i(t, e)
    }

    function $e(t, e) {
        for (var i, r, s, o, a, h, c, f = [], p = Object.keys(e), d = p.length; d--;) r = p[d], i = e[r] || is, a = l(r), ns.test(a) && (c = {
            name: r,
            path: a,
            options: i,
            mode: es.ONE_WAY,
            raw: null
        }, s = u(r), null === (o = V(t, s)) && (null !== (o = V(t, s + ".sync")) ? c.mode = es.TWO_WAY : null !== (o = V(t, s + ".once")) && (c.mode = es.ONE_TIME)), null !== o ? (c.raw = o, h = A(o), o = h.expression, c.filters = h.filters, n(o) ? c.optimizedLiteral = !0 : c.dynamic = !0, c.parentPath = o) : null !== (o = B(t, s)) ? c.raw = o : i.required, f.push(c));
        return ke(f)
    }

    function ke(t) {
        return function(e, i) {
            e._props = {};
            for (var n, r, s, l, c, u = t.length; u--;)
                if (n = t[u], c = n.raw, r = n.path, s = n.options, e._props[r] = n, null === c) lt(e, n, xe(e, s));
                else if (n.dynamic) e._context && (n.mode === es.ONE_TIME ? (l = (i || e._context).$get(n.parentPath), lt(e, n, l)) : e._bindDir({
                name: "prop",
                def: Kr,
                prop: n
            }, null, null, i));
            else if (n.optimizedLiteral) {
                var f = h(c);
                l = f === c ? a(o(c)) : f, lt(e, n, l)
            } else l = s.type === Boolean && "" === c ? !0 : c, lt(e, n, l)
        }
    }

    function xe(t, e) {
        if (!i(e, "default")) return e.type === Boolean ? !1 : void 0;
        var n = e["default"];
        return m(n), "function" == typeof n && e.type !== Function ? n.call(t) : n
    }

    function Ae(t, e, i) {
        var n = i || !e._asComponent ? Fe(t, e) : null,
            r = n && n.terminal || "SCRIPT" === t.tagName || !t.hasChildNodes() ? null : We(t.childNodes, e);
        return function(t, e, i, s, o) {
            var a = d(e.childNodes),
                h = Oe(function() {
                    n && n(t, e, i, s, o), r && r(t, a, i, s, o)
                }, t);
            return Te(t, h)
        }
    }

    function Oe(t, e) {
        var i = e._directives.length;
        t();
        var n = e._directives.slice(i);
        n.sort(Ne);
        for (var r = 0, s = n.length; s > r; r++) n[r]._bind();
        return n
    }

    function Ne(t, e) {
        return t = t.descriptor.def.priority || cs, e = e.descriptor.def.priority || cs, t > e ? -1 : t === e ? 0 : 1
    }

    function Te(t, e, i, n) {
        return function(r) {
            je(t, e, r), i && n && je(i, n)
        }
    }

    function je(t, e, i) {
        for (var n = e.length; n--;) e[n]._teardown(), i || t._directives.$remove(e[n])
    }

    function Ee(t, e, i, n) {
        var r = $e(e, i),
            s = Oe(function() {
                r(t, n)
            }, t);
        return Te(t, s)
    }

    function Se(t, e, i) {
        var n, r, s = e._containerAttrs,
            o = e._replacerAttrs;
        return 11 !== t.nodeType && (e._asComponent ? (s && i && (n = qe(s, i)), o && (r = qe(o, e))) : r = qe(t.attributes, e)),
            function(t, e, i) {
                var s, o = t._context;
                o && n && (s = Oe(function() {
                    n(o, e, null, i)
                }, o));
                var a = Oe(function() {
                    r && r(t, e)
                }, t);
                return Te(t, a, o, s)
            }
    }

    function Fe(t, e) {
        var i = t.nodeType;
        return 1 === i && "SCRIPT" !== t.tagName ? De(t, e) : 3 === i && t.data.trim() ? Pe(t, e) : null
    }

    function De(t, e) {
        if ("TEXTAREA" === t.tagName) {
            var i = T(t.value);
            i && (t.setAttribute(":value", j(i)), t.value = "")
        }
        var n, r = t.hasAttributes();
        return r && (n = ze(t, e)), n || (n = Ve(t, e)), n || (n = Me(t, e)), !n && r && (n = qe(t.attributes, e)), n
    }

    function Pe(t, e) {
        if (t._skip) return Re;
        var i = T(t.wholeText);
        if (!i) return null;
        for (var n = t.nextSibling; n && 3 === n.nodeType;) n._skip = !0, n = n.nextSibling;
        for (var r, s, o = document.createDocumentFragment(), a = 0, h = i.length; h > a; a++) s = i[a], r = s.tag ? He(s, e) : document.createTextNode(s.value), o.appendChild(r);
        return Le(i, o, e)
    }

    function Re(t, e) {
        U(e)
    }

    function He(t, e) {
        function i(e) {
            if (!t.descriptor) {
                var i = A(t.value);
                t.descriptor = {
                    name: e,
                    def: Vr[e],
                    expression: i.expression,
                    filters: i.filters
                }
            }
        }
        var n;
        return t.oneTime ? n = document.createTextNode(t.value) : t.html ? (n = document.createComment("v-html"), i("html")) : (n = document.createTextNode(" "), i("text")), n
    }

    function Le(t, e) {
        return function(i, n, r, s) {
            for (var o, a, h, l = e.cloneNode(!0), c = d(l.childNodes), u = 0, f = t.length; f > u; u++) o = t[u], a = o.value, o.tag && (h = c[u], o.oneTime ? (a = (s || i).$eval(a), o.html ? J(h, re(a, !0)) : h.data = a) : i._bindDir(o.descriptor, h, r, s));
            J(n, l)
        }
    }

    function We(t, e) {
        for (var i, n, r, s = [], o = 0, a = t.length; a > o; o++) r = t[o], i = Fe(r, e), n = i && i.terminal || "SCRIPT" === r.tagName || !r.hasChildNodes() ? null : We(r.childNodes, e), s.push(i, n);
        return s.length ? Be(s) : null
    }

    function Be(t) {
        return function(e, i, n, r, s) {
            for (var o, a, h, l = 0, c = 0, u = t.length; u > l; c++) {
                o = i[c], a = t[l++], h = t[l++];
                var f = d(o.childNodes);
                a && a(e, o, n, r, s), h && h(e, f, n, r, s)
            }
        }
    }

    function Ve(t, e) {
        var i = t.tagName.toLowerCase();
        if (!cn.test(i)) {
            "slot" === i && M(t, "name") && (i = "_namedSlot");
            var n = _t(e, "elementDirectives", i);
            return n ? Ue(t, i, "", e, n) : void 0
        }
    }

    function Me(t, e) {
        var i = at(t, e);
        if (i) {
            var n = rt(t),
                r = {
                    name: "component",
                    ref: n,
                    expression: i.id,
                    def: ts.component,
                    modifiers: {
                        literal: !i.dynamic
                    }
                },
                s = function(t, e, i, s, o) {
                    n && xt((s || t).$refs, n, null), t._bindDir(r, e, i, s, o)
                };
            return s.terminal = !0, s
        }
    }

    function ze(t, e) {
        if (null !== B(t, "v-pre")) return Ie;
        if (t.hasAttribute("v-else")) {
            var i = t.previousElementSibling;
            if (i && i.hasAttribute("v-if")) return Ie
        }
        for (var n, r, s = 0, o = ls.length; o > s; s++)
            if (r = ls[s], n = t.getAttribute("v-" + r)) return Ue(t, r, n, e)
    }

    function Ie() {}

    function Ue(t, e, i, n, r) {
        var s = A(i),
            o = {
                name: e,
                expression: s.expression,
                filters: s.filters,
                raw: i,
                def: r || Vr[e]
            };
        ("for" === e || "router-view" === e) && (o.ref = rt(t));
        var a = function(t, e, i, n, r) {
            o.ref && xt((n || t).$refs, o.ref, null), t._bindDir(o, e, i, n, r)
        };
        return a.terminal = !0, a
    }

    function qe(t, e) {
        function i(t, e, i) {
            var n = A(s);
            d.push({
                name: t,
                attr: o,
                raw: a,
                def: e,
                arg: l,
                modifiers: c,
                expression: n.expression,
                filters: n.filters,
                interp: i
            })
        }
        for (var n, r, s, o, a, h, l, c, u, f, p = t.length, d = []; p--;)
            if (n = t[p], r = o = n.name, s = a = n.value, f = T(s), l = null, c = Je(r), r = r.replace(as, ""), f) s = j(f), "class" === r ? i("class", ts["class"], !0) : (l = r, i("bind", Vr.bind, !0));
            else if (hs.test(r)) c.literal = !rs.test(r), i("transition", ts.transition);
        else if (ss.test(r)) l = r.replace(ss, ""), i("on", Vr.on);
        else if (rs.test(r)) h = r.replace(rs, ""), "style" === h || "class" === h ? i(h, ts[h]) : (l = h, i("bind", Vr.bind));
        else if (0 === r.indexOf("v-")) {
            if (l = (l = r.match(os)) && l[1], l && (r = r.replace(os, "")), h = r.slice(2), "else" === h) continue;
            u = _t(e, "directives", h), u && i(h, u)
        }
        return d.length ? Qe(d) : void 0
    }

    function Je(t) {
        var e = Object.create(null),
            i = t.match(as);
        if (i)
            for (var n = i.length; n--;) e[i[n].slice(1)] = !0;
        return e
    }

    function Qe(t) {
        return function(e, i, n, r, s) {
            for (var o = t.length; o--;) e._bindDir(t[o], i, n, r, s)
        }
    }

    function Ge(t, e) {
        return e && (e._containerAttrs = Ke(t)), it(t) && (t = re(t)), e && (e._asComponent && !e.template && (e.template = "<slot></slot>"), e.template && (e._content = Y(t), t = Ze(t, e))), t instanceof DocumentFragment && (q(nt("v-start", !0), t), t.appendChild(nt("v-end", !0))), t
    }

    function Ze(t, e) {
        var i = e.template,
            n = re(i, !0);
        if (n) {
            var r = n.firstChild,
                s = r.tagName && r.tagName.toLowerCase();
            return e.replace ? (t === document.body, n.childNodes.length > 1 || 1 !== r.nodeType || "component" === s || _t(e, "components", s) || M(r, "is") || _t(e, "elementDirectives", s) || r.hasAttribute("v-for") || r.hasAttribute("v-if") ? n : (e._replacerAttrs = Ke(r), Xe(t, r), r)) : (t.appendChild(n), t)
        }
    }

    function Ke(t) {
        return 1 === t.nodeType && t.hasAttributes() ? d(t.attributes) : void 0
    }

    function Xe(t, e) {
        for (var i, n, r = t.attributes, s = r.length; s--;) i = r[s].name, n = r[s].value, e.hasAttribute(i) || us.test(i) ? "class" === i && n.split(/\s+/).forEach(function(t) {
            K(e, t)
        }) : e.setAttribute(i, n)
    }

    function Ye(e) {
        function n() {}

        function s(t, e) {
            var i = new Ut(e, t, null, {
                lazy: !0
            });
            return function() {
                return i.dirty && i.evaluate(), yt.target && i.depend(), i.value
            }
        }
        Object.defineProperty(e.prototype, "$data", {
            get: function() {
                return this._data
            },
            set: function(t) {
                t !== this._data && this._setData(t)
            }
        }), e.prototype._initState = function() {
            this._initProps(), this._initMeta(), this._initMethods(), this._initData(), this._initComputed()
        }, e.prototype._initProps = function() {
            var t = this.$options,
                e = t.el,
                i = t.props;
            e = t.el = L(e), this._propsUnlinkFn = e && 1 === e.nodeType && i ? Ee(this, e, i, this._scope) : null
        }, e.prototype._initData = function() {
            var e = this._data,
                n = this.$options.data,
                r = n && n();
            if (r) {
                this._data = r;
                for (var s in e) null === this._props[s].raw && i(r, s) || t(r, s, e[s])
            }
            var o, a, h = this._data,
                l = Object.keys(h);
            for (o = l.length; o--;) a = l[o], this._proxy(a);
            kt(h, this)
        }, e.prototype._setData = function(t) {
            t = t || {};
            var e = this._data;
            this._data = t;
            var n, r, s;
            for (n = Object.keys(e), s = n.length; s--;) r = n[s], r in t || this._unproxy(r);
            for (n = Object.keys(t), s = n.length; s--;) r = n[s], i(this, r) || this._proxy(r);
            e.__ob__.removeVm(this), kt(t, this), this._digest()
        }, e.prototype._proxy = function(t) {
            if (!r(t)) {
                var e = this;
                Object.defineProperty(e, t, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        return e._data[t]
                    },
                    set: function(i) {
                        e._data[t] = i
                    }
                })
            }
        }, e.prototype._unproxy = function(t) {
            r(t) || delete this[t]
        }, e.prototype._digest = function() {
            for (var t = 0, e = this._watchers.length; e > t; t++) this._watchers[t].update(!0)
        }, e.prototype._initComputed = function() {
            var t = this.$options.computed;
            if (t)
                for (var e in t) {
                    var i = t[e],
                        r = {
                            enumerable: !0,
                            configurable: !0
                        };
                    "function" == typeof i ? (r.get = s(i, this), r.set = n) : (r.get = i.get ? i.cache !== !1 ? s(i.get, this) : p(i.get, this) : n, r.set = i.set ? p(i.set, this) : n), Object.defineProperty(this, e, r)
                }
        }, e.prototype._initMethods = function() {
            var t = this.$options.methods;
            if (t)
                for (var e in t) this[e] = p(t[e], this)
        }, e.prototype._initMeta = function() {
            var t = this.$options._meta;
            if (t)
                for (var e in t) xt(this, e, t[e])
        }
    }

    function ti(t) {
        function e(t, e) {
            for (var i, n, r = e.attributes, s = 0, o = r.length; o > s; s++) i = r[s].name, ps.test(i) && (i = i.replace(ps, ""), n = (t._scope || t._context).$eval(r[s].value, !0), t.$on(i.replace(ps), n))
        }

        function i(t, e, i) {
            if (i) {
                var r, s, o, a;
                for (s in i)
                    if (r = i[s], $i(r))
                        for (o = 0, a = r.length; a > o; o++) n(t, e, s, r[o]);
                    else n(t, e, s, r)
            }
        }

        function n(t, e, i, r, s) {
            var o = typeof r;
            if ("function" === o) t[e](i, r, s);
            else if ("string" === o) {
                var a = t.$options.methods,
                    h = a && a[r];
                h && t[e](i, h, s)
            } else r && "object" === o && n(t, e, i, r.handler, r)
        }

        function r() {
            this._isAttached || (this._isAttached = !0, this.$children.forEach(s))
        }

        function s(t) {
            !t._isAttached && W(t.$el) && t._callHook("attached")
        }

        function o() {
            this._isAttached && (this._isAttached = !1, this.$children.forEach(a))
        }

        function a(t) {
            t._isAttached && !W(t.$el) && t._callHook("detached")
        }
        t.prototype._initEvents = function() {
            var t = this.$options;
            t._asComponent && e(this, t.el), i(this, "$on", t.events), i(this, "$watch", t.watch)
        }, t.prototype._initDOMHooks = function() {
            this.$on("hook:attached", r), this.$on("hook:detached", o)
        }, t.prototype._callHook = function(t) {
            var e = this.$options[t];
            if (e)
                for (var i = 0, n = e.length; n > i; i++) e[i].call(this);
            this.$emit("hook:" + t)
        }
    }

    function ei() {}

    function ii(t, e, i, n, r, s) {
        this.vm = e, this.el = i, this.descriptor = t, this.name = t.name, this.expression = t.expression, this.arg = t.arg, this.modifiers = t.modifiers, this.filters = t.filters, this.literal = this.modifiers && this.modifiers.literal, this._locked = !1, this._bound = !1, this._listeners = null, this._host = n, this._scope = r, this._frag = s
    }

    function ni(t) {
        t.prototype._updateRef = function(t) {
            var e = this.$options._ref;
            if (e) {
                var i = (this._scope || this._context).$refs;
                t ? i[e] === this && (i[e] = null) : i[e] = this
            }
        }, t.prototype._compile = function(t) {
            var e = this.$options,
                i = t;
            if (t = Ge(t, e), this._initElement(t), 1 !== t.nodeType || null === B(t, "v-pre")) {
                var n, r = this._context && this._context.$options,
                    s = Se(t, e, r),
                    o = this.constructor;
                e._linkerCachable && (n = o.linker, n || (n = o.linker = Ae(t, e)));
                var a = s(this, t, this._scope),
                    h = n ? n(this, t) : Ae(t, e)(this, t);
                return this._unlinkFn = function() {
                    a(), h(!0)
                }, e.replace && J(i, t), this._isCompiled = !0, this._callHook("compiled"), t
            }
        }, t.prototype._initElement = function(t) {
            t instanceof DocumentFragment ? (this._isFragment = !0, this.$el = this._fragmentStart = t.firstChild, this._fragmentEnd = t.lastChild, 3 === this._fragmentStart.nodeType && (this._fragmentStart.data = this._fragmentEnd.data = ""), this._fragment = t) : this.$el = t, this.$el.__vue__ = this, this._callHook("beforeCompile")
        }, t.prototype._bindDir = function(t, e, i, n, r) {
            this._directives.push(new ii(t, this, e, i, n, r))
        }, t.prototype._destroy = function(t, e) {
            if (this._isBeingDestroyed) return void(e || this._cleanup());
            var i, n, r = this,
                s = function() {
                    !i || n || e || r._cleanup()
                };
            t && this.$el && (n = !0, this.$remove(function() {
                n = !1, s()
            })), this._callHook("beforeDestroy"), this._isBeingDestroyed = !0;
            var o, a = this.$parent;
            for (a && !a._isBeingDestroyed && (a.$children.$remove(this), this._updateRef(!0)), o = this.$children.length; o--;) this.$children[o].$destroy();
            for (this._propsUnlinkFn && this._propsUnlinkFn(), this._unlinkFn && this._unlinkFn(), o = this._watchers.length; o--;) this._watchers[o].teardown();
            this.$el && (this.$el.__vue__ = null), i = !0, s()
        }, t.prototype._cleanup = function() {
            this._isDestroyed || (this._frag && this._frag.children.$remove(this), this._data.__ob__ && this._data.__ob__.removeVm(this), this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null, this._isDestroyed = !0, this._callHook("destroyed"), this.$off())
        }
    }

    function ri(t) {
        t.prototype._applyFilters = function(t, e, i, n) {
            var r, s, o, a, h, l, c, u, f;
            for (l = 0, c = i.length; c > l; l++)
                if (r = i[l], s = _t(this.$options, "filters", r.name), s && (s = n ? s.write : s.read || s, "function" == typeof s)) {
                    if (o = n ? [t, e] : [t], h = n ? 2 : 1, r.args)
                        for (u = 0, f = r.args.length; f > u; u++) a = r.args[u], o[u + h] = a.dynamic ? this.$get(a.value) : a.value;
                    t = s.apply(this, o)
                }
            return t
        }, t.prototype._resolveComponent = function(e, i) {
            var n = _t(this.$options, "components", e);
            if (n)
                if (n.options) i(n);
                else if (n.resolved) i(n.resolved);
            else if (n.requested) n.pendingCallbacks.push(i);
            else {
                n.requested = !0;
                var r = n.pendingCallbacks = [i];
                n(function(e) {
                    g(e) && (e = t.extend(e)), n.resolved = e;
                    for (var i = 0, s = r.length; s > i; i++) r[i](e)
                }, function(t) {})
            }
        }
    }

    function si(i) {
        function n(t) {
            return new Function("return function " + f(t) + " (options) { this._init(options) }")()
        }
        i.util = _n, i.config = an, i.set = t, i["delete"] = e, i.nextTick = Di, i.compiler = fs, i.FragmentFactory = pe, i.internalDirectives = ts, i.parsers = {
            path: Pn,
            text: rn,
            template: Dr,
            directive: Ki,
            expression: Gn
        }, i.cid = 0;
        var r = 1;
        i.extend = function(t) {
            t = t || {};
            var e = this,
                i = 0 === e.cid;
            if (i && t._Ctor) return t._Ctor;
            var s = t.name || e.options.name,
                o = n(s || "VueComponent");
            return o.prototype = Object.create(e.prototype), o.prototype.constructor = o, o.cid = r++, o.options = gt(e.options, t), o["super"] = e, o.extend = e.extend, an._assetTypes.forEach(function(t) {
                o[t] = e[t]
            }), s && (o.options.components[s] = o), i && (t._Ctor = o), o
        }, i.use = function(t) {
            if (!t.installed) {
                var e = d(arguments, 1);
                return e.unshift(this), "function" == typeof t.install ? t.install.apply(t, e) : t.apply(null, e), t.installed = !0, this
            }
        }, i.mixin = function(t) {
            i.options = gt(i.options, t)
        }, an._assetTypes.forEach(function(t) {
            i[t] = function(e, n) {
                return n ? ("component" === t && g(n) && (n.name = e, n = i.extend(n)), this.options[t + "s"][e] = n, n) : this.options[t + "s"][e]
            }
        })
    }

    function oi(t) {
        function i(t) {
            return JSON.parse(JSON.stringify(t))
        }
        t.prototype.$get = function(t, e) {
            var i = Wt(t);
            if (i) {
                if (e && !Bt(t)) {
                    var n = this;
                    return function() {
                        n.$arguments = d(arguments), i.get.call(n, n), n.$arguments = null
                    }
                }
                try {
                    return i.get.call(this, this)
                } catch (r) {}
            }
        }, t.prototype.$set = function(t, e) {
            var i = Wt(t, !0);
            i && i.set && i.set.call(this, this, e)
        }, t.prototype.$delete = function(t) {
            e(this._data, t)
        }, t.prototype.$watch = function(t, e, i) {
            var n, r = this;
            "string" == typeof t && (n = A(t), t = n.expression);
            var s = new Ut(r, t, e, {
                deep: i && i.deep,
                sync: i && i.sync,
                filters: n && n.filters
            });
            return i && i.immediate && e.call(r, s.value),
                function() {
                    s.teardown()
                }
        }, t.prototype.$eval = function(t, e) {
            if (ds.test(t)) {
                var i = A(t),
                    n = this.$get(i.expression, e);
                return i.filters ? this._applyFilters(n, null, i.filters) : n
            }
            return this.$get(t, e)
        }, t.prototype.$interpolate = function(t) {
            var e = T(t),
                i = this;
            return e ? 1 === e.length ? i.$eval(e[0].value) + "" : e.map(function(t) {
                return t.tag ? i.$eval(t.value) : t.value
            }).join("") : t
        }, t.prototype.$log = function(t) {
            var e = t ? Et(this._data, t) : this._data;
            if (e && (e = i(e)), !t)
                for (var n in this.$options.computed) e[n] = i(this[n]);
            console.log(e)
        }
    }

    function ai(t) {
        function e(t, e, n, r, s, o) {
            e = i(e);
            var a = !W(e),
                h = r === !1 || a ? s : o,
                l = !a && !t._isAttached && !W(t.$el);
            return t._isFragment ? (st(t._fragmentStart, t._fragmentEnd, function(i) {
                h(i, e, t)
            }), n && n()) : h(t.$el, e, t, n), l && t._callHook("attached"), t
        }

        function i(t) {
            return "string" == typeof t ? document.querySelector(t) : t
        }

        function n(t, e, i, n) {
            e.appendChild(t), n && n()
        }

        function r(t, e, i, n) {
            z(t, e), n && n()
        }

        function s(t, e, i) {
            U(t), i && i()
        }
        t.prototype.$nextTick = function(t) {
            Di(t, this)
        }, t.prototype.$appendTo = function(t, i, r) {
            return e(this, t, i, r, n, D)
        }, t.prototype.$prependTo = function(t, e, n) {
            return t = i(t), t.hasChildNodes() ? this.$before(t.firstChild, e, n) : this.$appendTo(t, e, n), this
        }, t.prototype.$before = function(t, i, n) {
            return e(this, t, i, n, r, P)
        }, t.prototype.$after = function(t, e, n) {
            return t = i(t), t.nextSibling ? this.$before(t.nextSibling, e, n) : this.$appendTo(t.parentNode, e, n), this
        }, t.prototype.$remove = function(t, e) {
            if (!this.$el.parentNode) return t && t();
            var i = this._isAttached && W(this.$el);
            i || (e = !1);
            var n = this,
                r = function() {
                    i && n._callHook("detached"), t && t()
                };
            if (this._isFragment) ot(this._fragmentStart, this._fragmentEnd, this, this._fragment, r);
            else {
                var o = e === !1 ? s : R;
                o(this.$el, this, r)
            }
            return this
        }
    }

    function hi(t) {
        function e(t, e, n) {
            var r = t.$parent;
            if (r && n && !i.test(e))
                for (; r;) r._eventsCount[e] = (r._eventsCount[e] || 0) + n, r = r.$parent
        }
        t.prototype.$on = function(t, i) {
            return (this._events[t] || (this._events[t] = [])).push(i), e(this, t, 1), this
        }, t.prototype.$once = function(t, e) {
            function i() {
                n.$off(t, i), e.apply(this, arguments)
            }
            var n = this;
            return i.fn = e, this.$on(t, i), this
        }, t.prototype.$off = function(t, i) {
            var n;
            if (!arguments.length) {
                if (this.$parent)
                    for (t in this._events) n = this._events[t], n && e(this, t, -n.length);
                return this._events = {}, this
            }
            if (n = this._events[t], !n) return this;
            if (1 === arguments.length) return e(this, t, -n.length), this._events[t] = null, this;
            for (var r, s = n.length; s--;)
                if (r = n[s], r === i || r.fn === i) {
                    e(this, t, -1), n.splice(s, 1);
                    break
                }
            return this
        }, t.prototype.$emit = function(t) {
            var e = this._events[t],
                i = !e;
            if (e) {
                e = e.length > 1 ? d(e) : e;
                for (var n = d(arguments, 1), r = 0, s = e.length; s > r; r++) {
                    var o = e[r].apply(this, n);
                    o === !0 && (i = !0)
                }
            }
            return i
        }, t.prototype.$broadcast = function(t) {
            if (this._eventsCount[t]) {
                for (var e = this.$children, i = 0, n = e.length; n > i; i++) {
                    var r = e[i],
                        s = r.$emit.apply(r, arguments);
                    s && r.$broadcast.apply(r, arguments)
                }
                return this
            }
        }, t.prototype.$dispatch = function() {
            this.$emit.apply(this, arguments);
            for (var t = this.$parent; t;) {
                var e = t.$emit.apply(t, arguments);
                t = e ? t.$parent : null
            }
            return this
        };
        var i = /^hook:/
    }

    function li(t) {
        function e() {
            this._isAttached = !0, this._isReady = !0, this._callHook("ready")
        }
        t.prototype.$mount = function(t) {
            return this._isCompiled ? void 0 : (t = L(t), t || (t = document.createElement("div")), this._compile(t), this._initDOMHooks(), W(this.$el) ? (this._callHook("attached"), e.call(this)) : this.$once("hook:attached", e), this)
        }, t.prototype.$destroy = function(t, e) {
            this._destroy(t, e)
        }, t.prototype.$compile = function(t, e, i, n) {
            return Ae(t, this.$options, !0)(this, t, e, i, n)
        }
    }

    function ci(t) {
        this._init(t)
    }

    function ui(t, e, i) {
        return i = i ? parseInt(i, 10) : 0, "number" == typeof e ? t.slice(i, i + e) : t
    }

    function fi(t, e, i) {
        if (t = vs(t), null == e) return t;
        if ("function" == typeof e) return t.filter(e);
        e = ("" + e).toLowerCase();
        for (var n, r, s, o, a = "in" === i ? 3 : 2, h = d(arguments, a).reduce(function(t, e) {
                return t.concat(e)
            }, []), l = [], c = 0, u = t.length; u > c; c++)
            if (n = t[c], s = n && n.$value || n, o = h.length) {
                for (; o--;)
                    if (r = h[o], "$key" === r && di(n.$key, e) || di(Et(s, r), e)) {
                        l.push(n);
                        break
                    }
            } else di(n, e) && l.push(n);
        return l
    }

    function pi(t, e, i) {
        if (t = vs(t), !e) return t;
        var n = i && 0 > i ? -1 : 1;
        return t.slice().sort(function(t, i) {
            return "$key" !== e && (m(t) && "$value" in t && (t = t.$value), m(i) && "$value" in i && (i = i.$value)), t = m(t) ? Et(t, e) : t, i = m(i) ? Et(i, e) : i, t === i ? 0 : t > i ? n : -n
        })
    }

    function di(t, e) {
        var i;
        if (g(t)) {
            var n = Object.keys(t);
            for (i = n.length; i--;)
                if (di(t[n[i]], e)) return !0
        } else if ($i(t)) {
            for (i = t.length; i--;)
                if (di(t[i], e)) return !0
        } else if (null != t) return t.toString().toLowerCase().indexOf(e) > -1
    }

    function vi(t, e, i) {
        function n(t) {
            !it(t) || t.hasAttribute("v-if") || t.hasAttribute("v-for") || (t = re(t)), t = ne(t), r.appendChild(t)
        }
        for (var r = document.createDocumentFragment(), s = 0, o = t.length; o > s; s++) {
            var a = t[s];
            i && !a.__v_selected ? n(a) : i || a.parentNode !== e || (a.__v_selected = !0, n(a))
        }
        return r
    }
    var mi = Object.prototype.hasOwnProperty,
        gi = /^\s?(true|false|[\d\.]+|'[^']*'|"[^"]*")\s?$/,
        _i = /-(\w)/g,
        bi = /([a-z\d])([A-Z])/g,
        yi = /(?:^|[-_\/])(\w)/g,
        Ci = Object.prototype.toString,
        wi = "[object Object]",
        $i = Array.isArray,
        ki = "__proto__" in {},
        xi = "undefined" != typeof window && "[object Object]" !== Object.prototype.toString.call(window),
        Ai = xi && navigator.userAgent.toLowerCase().indexOf("msie 9.0") > 0,
        Oi = xi && navigator.userAgent.toLowerCase().indexOf("android") > 0,
        Ni = void 0,
        Ti = void 0,
        ji = void 0,
        Ei = void 0;
    if (xi && !Ai) {
        var Si = void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend,
            Fi = void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend;
        Ni = Si ? "WebkitTransition" : "transition", Ti = Si ? "webkitTransitionEnd" : "transitionend", ji = Fi ? "WebkitAnimation" : "animation", Ei = Fi ? "webkitAnimationEnd" : "animationend"
    }
    var Di = function() {
            function t() {
                n = !1;
                var t = i.slice(0);
                i = [];
                for (var e = 0; e < t.length; e++) t[e]()
            }
            var e, i = [],
                n = !1;
            if ("undefined" != typeof MutationObserver) {
                var r = 1,
                    s = new MutationObserver(t),
                    o = document.createTextNode(r);
                s.observe(o, {
                    characterData: !0
                }), e = function() {
                    r = (r + 1) % 2, o.data = r
                }
            } else e = setTimeout;
            return function(r, s) {
                var o = s ? function() {
                    r.call(s)
                } : r;
                i.push(o), n || (n = !0, e(t, 0))
            }
        }(),
        Pi = $.prototype;
    Pi.put = function(t, e) {
        var i = {
            key: t,
            value: e
        };
        return this._keymap[t] = i, this.tail ? (this.tail.newer = i, i.older = this.tail) : this.head = i, this.tail = i, this.size === this.limit ? this.shift() : void this.size++
    }, Pi.shift = function() {
        var t = this.head;
        return t && (this.head = this.head.newer, this.head.older = void 0, t.newer = t.older = void 0, this._keymap[t.key] = void 0), t
    }, Pi.get = function(t, e) {
        var i = this._keymap[t];
        return void 0 !== i ? i === this.tail ? e ? i : i.value : (i.newer && (i === this.head && (this.head = i.newer), i.newer.older = i.older), i.older && (i.older.newer = i.newer), i.newer = void 0, i.older = this.tail, this.tail && (this.tail.newer = i), this.tail = i, e ? i : i.value) : void 0
    };
    var Ri, Hi, Li, Wi, Bi, Vi, Mi, zi, Ii, Ui, qi, Ji, Qi = new $(1e3),
        Gi = /[^\s'"]+|'[^']*'|"[^"]*"/g,
        Zi = /^in$|^-?\d+/,
        Ki = Object.freeze({
            parseDirective: A
        }),
        Xi = /[-.*+?^${}()|[\]\/\\]/g,
        Yi = void 0,
        tn = void 0,
        en = void 0,
        nn = /[^|]\|[^|]/,
        rn = Object.freeze({
            compileRegex: N,
            parseText: T,
            tokensToExp: j,
            removeTags: F
        }),
        sn = ["{{", "}}"],
        on = ["{{{", "}}}"],
        an = Object.defineProperties({
            debug: !1,
            silent: !1,
            async: !0,
            warnExpressionErrors: !0,
            convertAllProperties: !1,
            _delimitersChanged: !0,
            _assetTypes: ["component", "directive", "elementDirective", "filter", "transition", "partial"],
            _propBindingModes: {
                ONE_WAY: 0,
                TWO_WAY: 1,
                ONE_TIME: 2
            },
            _maxUpdateCount: 100
        }, {
            delimiters: {
                get: function() {
                    return sn
                },
                set: function(t) {
                    sn = t, N()
                },
                configurable: !0,
                enumerable: !0
            },
            unsafeDelimiters: {
                get: function() {
                    return on
                },
                set: function(t) {
                    on = t, N()
                },
                configurable: !0,
                enumerable: !0
            }
        }),
        hn = void 0,
        ln = /^v-ref:/,
        cn = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/,
        un = /^(slot|partial|component)$/,
        fn = an.optionMergeStrategies = Object.create(null);
    fn.data = function(t, e, i) {
        return i ? t || e ? function() {
            var n = "function" == typeof e ? e.call(i) : e,
                r = "function" == typeof t ? t.call(i) : void 0;
            return n ? ft(n, r) : r
        } : void 0 : e ? "function" != typeof e ? t : t ? function() {
            return ft(e.call(this), t.call(this))
        } : e : t
    }, fn.el = function(t, e, i) {
        if (i || !e || "function" == typeof e) {
            var n = e || t;
            return i && "function" == typeof n ? n.call(i) : n
        }
    }, fn.init = fn.created = fn.ready = fn.attached = fn.detached = fn.beforeCompile = fn.compiled = fn.beforeDestroy = fn.destroyed = function(t, e) {
        return e ? t ? t.concat(e) : $i(e) ? e : [e] : t
    }, fn.paramAttributes = function() {}, an._assetTypes.forEach(function(t) {
        fn[t + "s"] = pt
    }), fn.watch = fn.events = function(t, e) {
        if (!e) return t;
        if (!t) return e;
        var i = {};
        v(i, t);
        for (var n in e) {
            var r = i[n],
                s = e[n];
            r && !$i(r) && (r = [r]), i[n] = r ? r.concat(s) : [s]
        }
        return i
    }, fn.props = fn.methods = fn.computed = function(t, e) {
        if (!e) return t;
        if (!t) return e;
        var i = Object.create(null);
        return v(i, t), v(i, e), i
    };
    var pn = function(t, e) {
            return void 0 === e ? t : e
        },
        dn = Array.prototype,
        vn = Object.create(dn);
    ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(function(t) {
        var e = dn[t];
        _(vn, t, function() {
            for (var i = arguments.length, n = new Array(i); i--;) n[i] = arguments[i];
            var r, s = e.apply(this, n),
                o = this.__ob__;
            switch (t) {
                case "push":
                    r = n;
                    break;
                case "unshift":
                    r = n;
                    break;
                case "splice":
                    r = n.slice(2)
            }
            return r && o.observeArray(r), o.dep.notify(), s
        })
    }), _(dn, "$set", function(t, e) {
        return t >= this.length && (this.length = t + 1), this.splice(t, 1, e)[0]
    }), _(dn, "$remove", function(t) {
        if (this.length) {
            var e = y(this, t);
            return e > -1 ? this.splice(e, 1) : void 0
        }
    });
    var mn = 0;
    yt.target = null, yt.prototype.addSub = function(t) {
        this.subs.push(t)
    }, yt.prototype.removeSub = function(t) {
        this.subs.$remove(t)
    }, yt.prototype.depend = function() {
        yt.target.addDep(this)
    }, yt.prototype.notify = function() {
        for (var t = d(this.subs), e = 0, i = t.length; i > e; e++) t[e].update()
    };
    var gn = Object.getOwnPropertyNames(vn);
    Ct.prototype.walk = function(t) {
        for (var e = Object.keys(t), i = e.length; i--;) this.convert(e[i], t[e[i]])
    }, Ct.prototype.observeArray = function(t) {
        for (var e = t.length; e--;) kt(t[e])
    }, Ct.prototype.convert = function(t, e) {
        xt(this.value, t, e)
    }, Ct.prototype.addVm = function(t) {
        (this.vms || (this.vms = [])).push(t)
    }, Ct.prototype.removeVm = function(t) {
        this.vms.$remove(t)
    };
    var _n = Object.freeze({
            defineReactive: xt,
            set: t,
            del: e,
            hasOwn: i,
            isLiteral: n,
            isReserved: r,
            _toString: s,
            toNumber: o,
            toBoolean: a,
            stripQuotes: h,
            camelize: l,
            hyphenate: u,
            classify: f,
            bind: p,
            toArray: d,
            extend: v,
            isObject: m,
            isPlainObject: g,
            def: _,
            debounce: b,
            indexOf: y,
            cancellable: C,
            looseEqual: w,
            isArray: $i,
            hasProto: ki,
            inBrowser: xi,
            isIE9: Ai,
            isAndroid: Oi,
            get transitionProp() {
                return Ni
            },
            get transitionEndEvent() {
                return Ti
            },
            get animationProp() {
                return ji
            },
            get animationEndEvent() {
                return Ei
            },
            nextTick: Di,
            query: L,
            inDoc: W,
            getAttr: B,
            getBindAttr: V,
            hasBindAttr: M,
            before: z,
            after: I,
            remove: U,
            prepend: q,
            replace: J,
            on: Q,
            off: G,
            setClass: Z,
            addClass: K,
            removeClass: X,
            extractContent: Y,
            trimNode: tt,
            isTemplate: it,
            createAnchor: nt,
            findRef: rt,
            mapNodeRange: st,
            removeNodeRange: ot,
            mergeOptions: gt,
            resolveAsset: _t,
            assertAsset: bt,
            checkComponentAttr: at,
            initProp: lt,
            assertProp: ct,
            coerceProp: ut,
            commonTagRE: cn,
            reservedTagRE: un,
            warn: hn
        }),
        bn = 0,
        yn = new $(1e3),
        Cn = 0,
        wn = 1,
        $n = 2,
        kn = 3,
        xn = 0,
        An = 1,
        On = 2,
        Nn = 3,
        Tn = 4,
        jn = 5,
        En = 6,
        Sn = 7,
        Fn = 8,
        Dn = [];
    Dn[xn] = {
        ws: [xn],
        ident: [Nn, Cn],
        "[": [Tn],
        eof: [Sn]
    }, Dn[An] = {
        ws: [An],
        ".": [On],
        "[": [Tn],
        eof: [Sn]
    }, Dn[On] = {
        ws: [On],
        ident: [Nn, Cn]
    }, Dn[Nn] = {
        ident: [Nn, Cn],
        0: [Nn, Cn],
        number: [Nn, Cn],
        ws: [An, wn],
        ".": [On, wn],
        "[": [Tn, wn],
        eof: [Sn, wn]
    }, Dn[Tn] = {
        "'": [jn, Cn],
        '"': [En, Cn],
        "[": [Tn, $n],
        "]": [An, kn],
        eof: Fn,
        "else": [Tn, Cn]
    }, Dn[jn] = {
        "'": [Tn, Cn],
        eof: Fn,
        "else": [jn, Cn]
    }, Dn[En] = {
        '"': [Tn, Cn],
        eof: Fn,
        "else": [En, Cn]
    };
    var Pn = Object.freeze({
            parsePath: jt,
            getPath: Et,
            setPath: St
        }),
        Rn = new $(1e3),
        Hn = "Math,Date,this,true,false,null,undefined,Infinity,NaN,isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,parseInt,parseFloat",
        Ln = new RegExp("^(" + Hn.replace(/,/g, "\\b|") + "\\b)"),
        Wn = "break,case,class,catch,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,in,instanceof,let,return,super,switch,throw,try,var,while,with,yield,enum,await,implements,package,proctected,static,interface,private,public",
        Bn = new RegExp("^(" + Wn.replace(/,/g, "\\b|") + "\\b)"),
        Vn = /\s/g,
        Mn = /\n/g,
        zn = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*")|new |typeof |void /g,
        In = /"(\d+)"/g,
        Un = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/,
        qn = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g,
        Jn = /^(?:true|false)$/,
        Qn = [],
        Gn = Object.freeze({
            parseExpression: Wt,
            isSimplePath: Bt
        }),
        Zn = [],
        Kn = [],
        Xn = {},
        Yn = {},
        tr = !1,
        er = !1,
        ir = 0;
    Ut.prototype.addDep = function(t) {
        var e = t.id;
        this.newDeps[e] || (this.newDeps[e] = t, this.deps[e] || (this.deps[e] = t, t.addSub(this)))
    }, Ut.prototype.get = function() {
        this.beforeGet();
        var t, e = this.scope || this.vm;
        try {
            t = this.getter.call(e, e)
        } catch (i) {}
        return this.deep && qt(t), this.preProcess && (t = this.preProcess(t)), this.filters && (t = e._applyFilters(t, null, this.filters, !1)), this.postProcess && (t = this.postProcess(t)), this.afterGet(), t
    }, Ut.prototype.set = function(t) {
        var e = this.scope || this.vm;
        this.filters && (t = e._applyFilters(t, this.value, this.filters, !0));
        try {
            this.setter.call(e, e, t)
        } catch (i) {}
        var n = e.$forContext;
        if (n && n.alias === this.expression) {
            if (n.filters) return;
            n._withLock(function() {
                e.$key ? n.rawValue[e.$key] = t : n.rawValue.$set(e.$index, t)
            })
        }
    }, Ut.prototype.beforeGet = function() {
        yt.target = this, this.newDeps = Object.create(null)
    }, Ut.prototype.afterGet = function() {
        yt.target = null;
        for (var t = Object.keys(this.deps), e = t.length; e--;) {
            var i = t[e];
            this.newDeps[i] || this.deps[i].removeSub(this)
        }
        this.deps = this.newDeps
    }, Ut.prototype.update = function(t) {
        this.lazy ? this.dirty = !0 : this.sync || !an.async ? this.run() : (this.shallow = this.queued ? t ? this.shallow : !1 : !!t, this.queued = !0, It(this))
    }, Ut.prototype.run = function() {
        if (this.active) {
            var t = this.get();
            if (t !== this.value || (m(t) || this.deep) && !this.shallow) {
                var e = this.value;
                this.value = t, this.prevError, this.cb.call(this.vm, t, e)
            }
            this.queued = this.shallow = !1
        }
    }, Ut.prototype.evaluate = function() {
        var t = yt.target;
        this.value = this.get(), this.dirty = !1, yt.target = t
    }, Ut.prototype.depend = function() {
        for (var t = Object.keys(this.deps), e = t.length; e--;) this.deps[t[e]].depend()
    }, Ut.prototype.teardown = function() {
        if (this.active) {
            this.vm._isBeingDestroyed || this.vm._watchers.$remove(this);
            for (var t = Object.keys(this.deps), e = t.length; e--;) this.deps[t[e]].removeSub(this);
            this.active = !1, this.vm = this.cb = this.value = null
        }
    };
    var nr = {
            bind: function() {
                var t = this.el;
                this.vm.$once("hook:compiled", function() {
                    t.removeAttribute("v-cloak")
                })
            }
        },
        rr = {
            bind: function() {}
        },
        sr = {
            priority: 1500,
            bind: function() {
                if (this.arg) {
                    var t = this.id = l(this.arg),
                        e = (this._scope || this.vm).$els;
                    i(e, t) ? e[t] = this.el : xt(e, t, this.el)
                }
            },
            unbind: function() {
                var t = (this._scope || this.vm).$els;
                t[this.id] === this.el && (t[this.id] = null)
            }
        },
        or = ["-webkit-", "-moz-", "-ms-"],
        ar = ["Webkit", "Moz", "ms"],
        hr = /!important;?$/,
        lr = Object.create(null),
        cr = null,
        ur = {
            deep: !0,
            update: function(t) {
                "string" == typeof t ? this.el.style.cssText = t : $i(t) ? this.handleObject(t.reduce(v, {})) : this.handleObject(t || {})
            },
            handleObject: function(t) {
                var e, i, n = this.cache || (this.cache = {});
                for (e in n) e in t || (this.handleSingle(e, null), delete n[e]);
                for (e in t) i = t[e], i !== n[e] && (n[e] = i, this.handleSingle(e, i))
            },
            handleSingle: function(t, e) {
                if (t = Jt(t))
                    if (null != e && (e += ""), e) {
                        var i = hr.test(e) ? "important" : "";
                        i && (e = e.replace(hr, "").trim()), this.el.style.setProperty(t, e, i)
                    } else this.el.style.removeProperty(t)
            }
        },
        fr = "http://www.w3.org/1999/xlink",
        pr = /^xlink:/,
        dr = /^v-|^:|^@|^(is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/,
        vr = /^(value|checked|selected|muted)$/,
        mr = {
            value: "_value",
            "true-value": "_trueValue",
            "false-value": "_falseValue"
        },
        gr = {
            priority: 850,
            bind: function() {
                var t = this.arg,
                    e = this.el.tagName;
                t || (this.deep = !0), this.descriptor.interp && (dr.test(t) || "name" === t && ("PARTIAL" === e || "SLOT" === e)) && (this.el.removeAttribute(t), this.invalid = !0)
            },
            update: function(t) {
                if (!this.invalid) {
                    var e = this.arg;
                    this.arg ? this.handleSingle(e, t) : this.handleObject(t || {})
                }
            },
            handleObject: ur.handleObject,
            handleSingle: function(t, e) {
                !this.descriptor.interp && vr.test(t) && t in this.el && (this.el[t] = "value" === t && null == e ? "" : e);
                var i = mr[t];
                if (i) {
                    this.el[i] = e;
                    var n = this.el.__v_model;
                    n && n.listener()
                }
                return "value" === t && "TEXTAREA" === this.el.tagName ? void this.el.removeAttribute(t) : void(null != e && e !== !1 ? pr.test(t) ? this.el.setAttributeNS(fr, t, e) : this.el.setAttribute(t, e) : this.el.removeAttribute(t))
            }
        },
        _r = {
            esc: 27,
            tab: 9,
            enter: 13,
            space: 32,
            "delete": 46,
            up: 38,
            left: 37,
            right: 39,
            down: 40
        },
        br = {
            acceptStatement: !0,
            priority: 700,
            bind: function() {
                if ("IFRAME" === this.el.tagName && "load" !== this.arg) {
                    var t = this;
                    this.iframeBind = function() {
                        Q(t.el.contentWindow, t.arg, t.handler)
                    }, this.on("load", this.iframeBind)
                }
            },
            update: function(t) {
                if (this.descriptor.raw || (t = function() {}), "function" == typeof t) {
                    this.modifiers.stop && (t = Zt(t)), this.modifiers.prevent && (t = Kt(t));
                    var e = Object.keys(this.modifiers).filter(function(t) {
                        return "stop" !== t && "prevent" !== t
                    });
                    e.length && (t = Gt(t, e)), this.reset(), this.handler = t, this.iframeBind ? this.iframeBind() : Q(this.el, this.arg, this.handler)
                }
            },
            reset: function() {
                var t = this.iframeBind ? this.el.contentWindow : this.el;
                this.handler && G(t, this.arg, this.handler)
            },
            unbind: function() {
                this.reset()
            }
        },
        yr = {
            bind: function() {
                function t() {
                    var t = i.checked;
                    return t && i.hasOwnProperty("_trueValue") ? i._trueValue : !t && i.hasOwnProperty("_falseValue") ? i._falseValue : t
                }
                var e = this,
                    i = this.el;
                this.getValue = function() {
                    return i.hasOwnProperty("_value") ? i._value : e.params.number ? o(i.value) : i.value
                }, this.listener = function() {
                    var n = e._watcher.value;
                    if ($i(n)) {
                        var r = e.getValue();
                        i.checked ? y(n, r) < 0 && n.push(r) : n.$remove(r)
                    } else e.set(t())
                }, this.on("change", this.listener), i.hasAttribute("checked") && (this.afterBind = this.listener)
            },
            update: function(t) {
                var e = this.el;
                $i(t) ? e.checked = y(t, this.getValue()) > -1 : e.hasOwnProperty("_trueValue") ? e.checked = w(t, e._trueValue) : e.checked = !!t
            }
        },
        Cr = {
            bind: function() {
                var t = this,
                    e = this.el;
                this.forceUpdate = function() {
                    t._watcher && t.update(t._watcher.get())
                };
                var i = this.multiple = e.hasAttribute("multiple");
                this.listener = function() {
                    var n = Xt(e, i);
                    n = t.params.number ? $i(n) ? n.map(o) : o(n) : n, t.set(n)
                }, this.on("change", this.listener);
                var n = Xt(e, i, !0);
                (i && n.length || !i && null !== n) && (this.afterBind = this.listener), this.vm.$on("hook:attached", this.forceUpdate)
            },
            update: function(t) {
                var e = this.el;
                e.selectedIndex = -1;
                for (var i, n, r = this.multiple && $i(t), s = e.options, o = s.length; o--;) i = s[o], n = i.hasOwnProperty("_value") ? i._value : i.value, i.selected = r ? Yt(t, n) > -1 : w(t, n)
            },
            unbind: function() {
                this.vm.$off("hook:attached", this.forceUpdate)
            }
        },
        wr = {
            bind: function() {
                var t = this,
                    e = this.el;
                this.getValue = function() {
                    if (e.hasOwnProperty("_value")) return e._value;
                    var i = e.value;
                    return t.params.number && (i = o(i)), i
                }, this.listener = function() {
                    t.set(t.getValue())
                }, this.on("change", this.listener), e.hasAttribute("checked") && (this.afterBind = this.listener)
            },
            update: function(t) {
                this.el.checked = w(t, this.getValue())
            }
        },
        $r = {
            bind: function() {
                var t = this,
                    e = this.el,
                    i = "range" === e.type,
                    n = this.params.lazy,
                    r = this.params.number,
                    s = this.params.debounce,
                    a = !1;
                Oi || i || (this.on("compositionstart", function() {
                    a = !0
                }), this.on("compositionend", function() {
                    a = !1, n || t.listener()
                })), this.focused = !1, i || (this.on("focus", function() {
                    t.focused = !0
                }), this.on("blur", function() {
                    t.focused = !1, (!t._frag || t._frag.inserted) && t.rawListener()
                })), this.listener = this.rawListener = function() {
                    if (!a && t._bound) {
                        var n = r || i ? o(e.value) : e.value;
                        t.set(n), Di(function() {
                            t._bound && !t.focused && t.update(t._watcher.value)
                        })
                    }
                }, s && (this.listener = b(this.listener, s)), this.hasjQuery = "function" == typeof jQuery, this.hasjQuery ? (jQuery(e).on("change", this.listener), n || jQuery(e).on("input", this.listener)) : (this.on("change", this.listener), n || this.on("input", this.listener)), !n && Ai && (this.on("cut", function() {
                    Di(t.listener)
                }), this.on("keyup", function(e) {
                    (46 === e.keyCode || 8 === e.keyCode) && t.listener()
                })), (e.hasAttribute("value") || "TEXTAREA" === e.tagName && e.value.trim()) && (this.afterBind = this.listener)
            },
            update: function(t) {
                this.el.value = s(t)
            },
            unbind: function() {
                var t = this.el;
                this.hasjQuery && (jQuery(t).off("change", this.listener), jQuery(t).off("input", this.listener))
            }
        },
        kr = {
            text: $r,
            radio: wr,
            select: Cr,
            checkbox: yr
        },
        xr = {
            priority: 800,
            twoWay: !0,
            handlers: kr,
            params: ["lazy", "number", "debounce"],
            bind: function() {
                this.checkFilters(), this.hasRead && !this.hasWrite;
                var t, e = this.el,
                    i = e.tagName;
                if ("INPUT" === i) t = kr[e.type] || kr.text;
                else if ("SELECT" === i) t = kr.select;
                else {
                    if ("TEXTAREA" !== i) return;
                    t = kr.text
                }
                e.__v_model = this, t.bind.call(this), this.update = t.update, this._unbind = t.unbind
            },
            checkFilters: function() {
                var t = this.filters;
                if (t)
                    for (var e = t.length; e--;) {
                        var i = _t(this.vm.$options, "filters", t[e].name);
                        ("function" == typeof i || i.read) && (this.hasRead = !0), i.write && (this.hasWrite = !0)
                    }
            },
            unbind: function() {
                this.el.__v_model = null, this._unbind && this._unbind()
            }
        },
        Ar = {
            bind: function() {
                var t = this.el.nextElementSibling;
                t && null !== B(t, "v-else") && (this.elseEl = t)
            },
            update: function(t) {
                this.apply(this.el, t), this.elseEl && this.apply(this.elseEl, !t)
            },
            apply: function(t, e) {
                function i() {
                    t.style.display = e ? "" : "none"
                }
                W(t) ? H(t, e ? 1 : -1, i, this.vm) : i()
            }
        },
        Or = new $(1e3),
        Nr = new $(1e3),
        Tr = {
            efault: [0, "", ""],
            legend: [1, "<fieldset>", "</fieldset>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"]
        };
    Tr.td = Tr.th = [3, "<table><tbody><tr>", "</tr></tbody></table>"], Tr.option = Tr.optgroup = [1, '<select multiple="multiple">', "</select>"], Tr.thead = Tr.tbody = Tr.colgroup = Tr.caption = Tr.tfoot = [1, "<table>", "</table>"], Tr.g = Tr.defs = Tr.symbol = Tr.use = Tr.image = Tr.text = Tr.circle = Tr.ellipse = Tr.line = Tr.path = Tr.polygon = Tr.polyline = Tr.rect = [1, '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ev="http://www.w3.org/2001/xml-events"version="1.1">', "</svg>"];
    var jr = /<([\w:]+)/,
        Er = /&#?\w+?;/,
        Sr = function() {
            if (xi) {
                var t = document.createElement("div");
                return t.innerHTML = "<template>1</template>", !t.cloneNode(!0).firstChild.innerHTML
            }
            return !1
        }(),
        Fr = function() {
            if (xi) {
                var t = document.createElement("textarea");
                return t.placeholder = "t", "t" === t.cloneNode(!0).value
            }
            return !1
        }(),
        Dr = Object.freeze({
            cloneNode: ne,
            parseTemplate: re
        });
    se.prototype.callHook = function(t) {
        var e, i;
        for (e = 0, i = this.children.length; i > e; e++) t(this.children[e]);
        for (e = 0, i = this.childFrags.length; i > e; e++) this.childFrags[e].callHook(t)
    }, se.prototype.destroy = function() {
        this.parentFrag && this.parentFrag.childFrags.$remove(this), this.unlink()
    };
    var Pr = new $(5e3);
    pe.prototype.create = function(t, e, i) {
        var n = ne(this.template);
        return new se(this.linker, this.vm, n, t, e, i)
    };
    var Rr = {
            priority: 2e3,
            bind: function() {
                var t = this.el;
                if (t.__vue__) this.invalid = !0;
                else {
                    var e = t.nextElementSibling;
                    e && null !== B(e, "v-else") && (U(e), this.elseFactory = new pe(this.vm, e)), this.anchor = nt("v-if"), J(t, this.anchor), this.factory = new pe(this.vm, t)
                }
            },
            update: function(t) {
                this.invalid || (t ? this.frag || this.insert() : this.remove())
            },
            insert: function() {
                this.elseFrag && (this.elseFrag.remove(), this.elseFrag = null), this.frag = this.factory.create(this._host, this._scope, this._frag), this.frag.before(this.anchor)
            },
            remove: function() {
                this.frag && (this.frag.remove(), this.frag = null), this.elseFactory && !this.elseFrag && (this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag), this.elseFrag.before(this.anchor))
            },
            unbind: function() {
                this.frag && this.frag.destroy()
            }
        },
        Hr = 0,
        Lr = {
            priority: 2e3,
            params: ["track-by", "stagger", "enter-stagger", "leave-stagger"],
            bind: function() {
                var t = this.expression.match(/(.*) in (.*)/);
                if (t) {
                    var e = t[1].match(/\((.*),(.*)\)/);
                    e ? (this.iterator = e[1].trim(), this.alias = e[2].trim()) : this.alias = t[1].trim(), this.expression = t[2]
                }
                if (this.alias) {
                    this.id = "__v-for__" + ++Hr;
                    var i = this.el.tagName;
                    this.isOption = ("OPTION" === i || "OPTGROUP" === i) && "SELECT" === this.el.parentNode.tagName, this.start = nt("v-for-start"), this.end = nt("v-for-end"), J(this.el, this.end), z(this.start, this.end), this.cache = Object.create(null), this.factory = new pe(this.vm, this.el)
                }
            },
            update: function(t) {
                this.diff(t), this.updateRef(), this.updateModel()
            },
            diff: function(t) {
                var e, n, r, s, o, a, h = t[0],
                    l = this.fromObject = m(h) && i(h, "$key") && i(h, "$value"),
                    c = this.params.trackBy,
                    u = this.frags,
                    f = this.frags = new Array(t.length),
                    p = this.alias,
                    d = this.iterator,
                    v = this.start,
                    g = this.end,
                    _ = W(v),
                    b = !u;
                for (e = 0, n = t.length; n > e; e++) h = t[e], s = l ? h.$key : null, o = l ? h.$value : h, a = !m(o), r = !b && this.getCachedFrag(o, e, s), r ? (r.reused = !0, r.scope.$index = e, s && (r.scope.$key = s), d && (r.scope[d] = null !== s ? s : e), (c || l || a) && (r.scope[p] = o)) : (r = this.create(o, p, e, s), r.fresh = !b), f[e] = r, b && r.before(g);
                if (!b) {
                    var y = 0,
                        C = u.length - f.length;
                    for (e = 0, n = u.length; n > e; e++) r = u[e], r.reused || (this.deleteCachedFrag(r), this.remove(r, y++, C, _));
                    var w, $, k, x = 0;
                    for (e = 0, n = f.length; n > e; e++) r = f[e], w = f[e - 1], $ = w ? w.staggerCb ? w.staggerAnchor : w.end || w.node : v, r.reused && !r.staggerCb ? (k = de(r, v, this.id), k === w || k && de(k, v, this.id) === w || this.move(r, $)) : this.insert(r, x++, $, _), r.reused = r.fresh = !1
                }
            },
            create: function(t, e, i, n) {
                var r = this._host,
                    s = this._scope || this.vm,
                    o = Object.create(s);
                o.$refs = Object.create(s.$refs), o.$els = Object.create(s.$els), o.$parent = s, o.$forContext = this, xt(o, e, t), xt(o, "$index", i), n ? xt(o, "$key", n) : o.$key && _(o, "$key", null), this.iterator && xt(o, this.iterator, null !== n ? n : i);
                var a = this.factory.create(r, o, this._frag);
                return a.forId = this.id, this.cacheFrag(t, a, i, n), a
            },
            updateRef: function() {
                var t = this.descriptor.ref;
                if (t) {
                    var e, i = (this._scope || this.vm).$refs;
                    this.fromObject ? (e = {}, this.frags.forEach(function(t) {
                        e[t.scope.$key] = ve(t)
                    })) : e = this.frags.map(ve), i[t] = e
                }
            },
            updateModel: function() {
                if (this.isOption) {
                    var t = this.start.parentNode,
                        e = t && t.__v_model;
                    e && e.forceUpdate()
                }
            },
            insert: function(t, e, i, n) {
                t.staggerCb && (t.staggerCb.cancel(), t.staggerCb = null);
                var r = this.getStagger(t, e, null, "enter");
                if (n && r) {
                    var s = t.staggerAnchor;
                    s || (s = t.staggerAnchor = nt("stagger-anchor"), s.__vfrag__ = t), I(s, i);
                    var o = t.staggerCb = C(function() {
                        t.staggerCb = null, t.before(s), U(s)
                    });
                    setTimeout(o, r)
                } else t.before(i.nextSibling)
            },
            remove: function(t, e, i, n) {
                if (t.staggerCb) return t.staggerCb.cancel(), void(t.staggerCb = null);
                var r = this.getStagger(t, e, i, "leave");
                if (n && r) {
                    var s = t.staggerCb = C(function() {
                        t.staggerCb = null, t.remove()
                    });
                    setTimeout(s, r)
                } else t.remove()
            },
            move: function(t, e) {
                t.before(e.nextSibling, !1)
            },
            cacheFrag: function(t, e, n, r) {
                var s, o = this.params.trackBy,
                    a = this.cache,
                    h = !m(t);
                r || o || h ? (s = o ? "$index" === o ? n : t[o] : r || t, a[s] || (a[s] = e)) : (s = this.id, i(t, s) ? null === t[s] && (t[s] = e) : _(t, s, e)), e.raw = t
            },
            getCachedFrag: function(t, e, i) {
                var n, r = this.params.trackBy,
                    s = !m(t);
                if (i || r || s) {
                    var o = r ? "$index" === r ? e : t[r] : i || t;
                    n = this.cache[o]
                } else n = t[this.id];
                return n && (n.reused || n.fresh), n
            },
            deleteCachedFrag: function(t) {
                var e = t.raw,
                    n = this.params.trackBy,
                    r = t.scope,
                    s = r.$index,
                    o = i(r, "$key") && r.$key,
                    a = !m(e);
                if (n || o || a) {
                    var h = n ? "$index" === n ? s : e[n] : o || e;
                    this.cache[h] = null
                } else e[this.id] = null, t.raw = null
            },
            getStagger: function(t, e, i, n) {
                n += "Stagger";
                var r = t.node.__v_trans,
                    s = r && r.hooks,
                    o = s && (s[n] || s.stagger);
                return o ? o.call(t, e, i) : e * parseInt(this.params[n] || this.params.stagger, 10)
            },
            _preProcess: function(t) {
                return this.rawValue = t, t
            },
            _postProcess: function(t) {
                if ($i(t)) return t;
                if (g(t)) {
                    for (var e, i = Object.keys(t), n = i.length, r = new Array(n); n--;) e = i[n], r[n] = {
                        $key: e,
                        $value: t[e]
                    };
                    return r
                }
                return "number" == typeof t && (t = me(t)), t || []
            },
            unbind: function() {
                if (this.descriptor.ref && ((this._scope || this.vm).$refs[this.descriptor.ref] = null), this.frags)
                    for (var t, e = this.frags.length; e--;) t = this.frags[e], this.deleteCachedFrag(t), t.destroy()
            }
        },
        Wr = {
            bind: function() {
                8 === this.el.nodeType && (this.nodes = [], this.anchor = nt("v-html"), J(this.el, this.anchor))
            },
            update: function(t) {
                t = s(t), this.nodes ? this.swap(t) : this.el.innerHTML = t
            },
            swap: function(t) {
                for (var e = this.nodes.length; e--;) U(this.nodes[e]);
                var i = re(t, !0, !0);
                this.nodes = d(i.childNodes), z(i, this.anchor)
            }
        },
        Br = {
            bind: function() {
                this.attr = 3 === this.el.nodeType ? "data" : "textContent"
            },
            update: function(t) {
                this.el[this.attr] = s(t)
            }
        },
        Vr = {
            text: Br,
            html: Wr,
            "for": Lr,
            "if": Rr,
            show: Ar,
            model: xr,
            on: br,
            bind: gr,
            el: sr,
            ref: rr,
            cloak: nr
        },
        Mr = [],
        zr = !1,
        Ir = 1,
        Ur = 2,
        qr = Ni + "Duration",
        Jr = ji + "Duration",
        Qr = be.prototype;
    Qr.enter = function(t, e) {
        this.cancelPending(), this.callHook("beforeEnter"), this.cb = e, K(this.el, this.enterClass), t(), this.entered = !1, this.callHookWithCb("enter"), this.entered || (this.cancel = this.hooks && this.hooks.enterCancelled, ge(this.enterNextTick))
    }, Qr.enterNextTick = function() {
        this.justEntered = !0;
        var t = this;
        setTimeout(function() {
            t.justEntered = !1
        }, 17);
        var e = this.enterDone,
            i = this.getCssTransitionType(this.enterClass);
        this.pendingJsCb ? i === Ir && X(this.el, this.enterClass) : i === Ir ? (X(this.el, this.enterClass), this.setupCssCb(Ti, e)) : i === Ur ? this.setupCssCb(Ei, e) : e()
    }, Qr.enterDone = function() {
        this.entered = !0, this.cancel = this.pendingJsCb = null, X(this.el, this.enterClass), this.callHook("afterEnter"), this.cb && this.cb()
    }, Qr.leave = function(t, e) {
        this.cancelPending(), this.callHook("beforeLeave"), this.op = t, this.cb = e, K(this.el, this.leaveClass), this.left = !1, this.callHookWithCb("leave"), this.left || (this.cancel = this.hooks && this.hooks.leaveCancelled, this.op && !this.pendingJsCb && (this.justEntered ? this.leaveDone() : ge(this.leaveNextTick)))
    }, Qr.leaveNextTick = function() {
        var t = this.getCssTransitionType(this.leaveClass);
        if (t) {
            var e = t === Ir ? Ti : Ei;
            this.setupCssCb(e, this.leaveDone)
        } else this.leaveDone()
    }, Qr.leaveDone = function() {
        this.left = !0, this.cancel = this.pendingJsCb = null, this.op(), X(this.el, this.leaveClass), this.callHook("afterLeave"), this.cb && this.cb(), this.op = null
    }, Qr.cancelPending = function() {
        this.op = this.cb = null;
        var t = !1;
        this.pendingCssCb && (t = !0, G(this.el, this.pendingCssEvent, this.pendingCssCb), this.pendingCssEvent = this.pendingCssCb = null), this.pendingJsCb && (t = !0, this.pendingJsCb.cancel(), this.pendingJsCb = null), t && (X(this.el, this.enterClass), X(this.el, this.leaveClass)), this.cancel && (this.cancel.call(this.vm, this.el), this.cancel = null)
    }, Qr.callHook = function(t) {
        this.hooks && this.hooks[t] && this.hooks[t].call(this.vm, this.el)
    }, Qr.callHookWithCb = function(t) {
        var e = this.hooks && this.hooks[t];
        e && (e.length > 1 && (this.pendingJsCb = C(this[t + "Done"])), e.call(this.vm, this.el, this.pendingJsCb))
    }, Qr.getCssTransitionType = function(t) {
        if (!(!Ti || document.hidden || this.hooks && this.hooks.css === !1 || ye(this.el))) {
            var e = this.typeCache[t];
            if (e) return e;
            var i = this.el.style,
                n = window.getComputedStyle(this.el),
                r = i[qr] || n[qr];
            if (r && "0s" !== r) e = Ir;
            else {
                var s = i[Jr] || n[Jr];
                s && "0s" !== s && (e = Ur)
            }
            return e && (this.typeCache[t] = e), e
        }
    }, Qr.setupCssCb = function(t, e) {
        this.pendingCssEvent = t;
        var i = this,
            n = this.el,
            r = this.pendingCssCb = function(s) {
                s.target === n && (G(n, t, r), i.pendingCssEvent = i.pendingCssCb = null, !i.pendingJsCb && e && e())
            };
        Q(n, t, r)
    };
    var Gr = {
            priority: 1100,
            update: function(t, e) {
                var i = this.el,
                    n = _t(this.vm.$options, "transitions", t);
                t = t || "v", i.__v_trans = new be(i, t, n, this.el.__vue__ || this.vm), e && X(i, e + "-transition"), K(i, t + "-transition")
            }
        },
        Zr = an._propBindingModes,
        Kr = {
            bind: function() {
                var t = this.vm,
                    e = t._context,
                    i = this.descriptor.prop,
                    n = i.path,
                    r = i.parentPath,
                    s = i.mode === Zr.TWO_WAY,
                    o = this.parentWatcher = new Ut(e, r, function(e) {
                        e = ut(i, e), ct(i, e) && (t[n] = e)
                    }, {
                        twoWay: s,
                        filters: i.filters,
                        scope: this._scope
                    });
                if (lt(t, i, o.value), s) {
                    var a = this;
                    t.$once("hook:created", function() {
                        a.childWatcher = new Ut(t, n, function(t) {
                            o.set(t)
                        }, {
                            sync: !0
                        })
                    })
                }
            },
            unbind: function() {
                this.parentWatcher.teardown(), this.childWatcher && this.childWatcher.teardown()
            }
        },
        Xr = {
            priority: 1500,
            params: ["keep-alive", "transition-mode", "inline-template"],
            bind: function() {
                this.el.__vue__ || (this.keepAlive = this.params.keepAlive, this.keepAlive && (this.cache = {}), this.params.inlineTemplate && (this.inlineTemplate = Y(this.el, !0)), this.pendingComponentCb = this.Component = null, this.pendingRemovals = 0, this.pendingRemovalCb = null, this.anchor = nt("v-component"), J(this.el, this.anchor), this.el.removeAttribute("is"), this.descriptor.ref && this.el.removeAttribute("v-ref:" + u(this.descriptor.ref)), this.literal && this.setComponent(this.expression))
            },
            update: function(t) {
                this.literal || this.setComponent(t)
            },
            setComponent: function(t, e) {
                if (this.invalidatePending(), t) {
                    var i = this;
                    this.resolveComponent(t, function() {
                        i.mountComponent(e)
                    })
                } else this.unbuild(!0), this.remove(this.childVM, e), this.childVM = null
            },
            resolveComponent: function(t, e) {
                var i = this;
                this.pendingComponentCb = C(function(n) {
                    i.ComponentName = n.options.name || t, i.Component = n, e()
                }), this.vm._resolveComponent(t, this.pendingComponentCb)
            },
            mountComponent: function(t) {
                this.unbuild(!0);
                var e = this,
                    i = this.Component.options.activate,
                    n = this.getCached(),
                    r = this.build();
                i && !n ? (this.waitingFor = r, i.call(r, function() {
                    e.waitingFor === r && (e.waitingFor = null, e.transition(r, t))
                })) : (n && r._updateRef(), this.transition(r, t))
            },
            invalidatePending: function() {
                this.pendingComponentCb && (this.pendingComponentCb.cancel(),
                    this.pendingComponentCb = null)
            },
            build: function(t) {
                var e = this.getCached();
                if (e) return e;
                if (this.Component) {
                    var i = {
                        name: this.ComponentName,
                        el: ne(this.el),
                        template: this.inlineTemplate,
                        parent: this._host || this.vm,
                        _linkerCachable: !this.inlineTemplate,
                        _ref: this.descriptor.ref,
                        _asComponent: !0,
                        _isRouterView: this._isRouterView,
                        _context: this.vm,
                        _scope: this._scope,
                        _frag: this._frag
                    };
                    t && v(i, t);
                    var n = new this.Component(i);
                    return this.keepAlive && (this.cache[this.Component.cid] = n), n
                }
            },
            getCached: function() {
                return this.keepAlive && this.cache[this.Component.cid]
            },
            unbuild: function(t) {
                this.waitingFor && (this.waitingFor.$destroy(), this.waitingFor = null);
                var e = this.childVM;
                return !e || this.keepAlive ? void(e && e._updateRef(!0)) : void e.$destroy(!1, t)
            },
            remove: function(t, e) {
                var i = this.keepAlive;
                if (t) {
                    this.pendingRemovals++, this.pendingRemovalCb = e;
                    var n = this;
                    t.$remove(function() {
                        n.pendingRemovals--, i || t._cleanup(), !n.pendingRemovals && n.pendingRemovalCb && (n.pendingRemovalCb(), n.pendingRemovalCb = null)
                    })
                } else e && e()
            },
            transition: function(t, e) {
                var i = this,
                    n = this.childVM;
                switch (this.childVM = t, i.params.transitionMode) {
                    case "in-out":
                        t.$before(i.anchor, function() {
                            i.remove(n, e)
                        });
                        break;
                    case "out-in":
                        i.remove(n, function() {
                            t.$before(i.anchor, e)
                        });
                        break;
                    default:
                        i.remove(n), t.$before(i.anchor, e)
                }
            },
            unbind: function() {
                if (this.invalidatePending(), this.unbuild(), this.cache) {
                    for (var t in this.cache) this.cache[t].$destroy();
                    this.cache = null
                }
            }
        },
        Yr = {
            deep: !0,
            update: function(t) {
                t && "string" == typeof t ? this.handleObject(Ce(t)) : g(t) ? this.handleObject(t) : $i(t) ? this.handleArray(t) : this.cleanup()
            },
            handleObject: function(t) {
                this.cleanup(t);
                for (var e = this.prevKeys = Object.keys(t), i = 0, n = e.length; n > i; i++) {
                    var r = e[i];
                    t[r] ? K(this.el, r) : X(this.el, r)
                }
            },
            handleArray: function(t) {
                this.cleanup(t);
                for (var e = 0, i = t.length; i > e; e++) t[e] && K(this.el, t[e]);
                this.prevKeys = t.slice()
            },
            cleanup: function(t) {
                if (this.prevKeys)
                    for (var e = this.prevKeys.length; e--;) {
                        var i = this.prevKeys[e];
                        !i || t && we(t, i) || X(this.el, i)
                    }
            }
        },
        ts = {
            style: ur,
            "class": Yr,
            component: Xr,
            prop: Kr,
            transition: Gr
        },
        es = an._propBindingModes,
        is = {},
        ns = /^[$_a-zA-Z]+[\w$]*$/,
        rs = /^v-bind:|^:/,
        ss = /^v-on:|^@/,
        os = /:(.*)$/,
        as = /\.[^\.]+/g,
        hs = /^(v-bind:|:)?transition$/,
        ls = ["for", "if"],
        cs = 1e3;
    Ie.terminal = !0;
    var us = /[^\w\-:\.]/,
        fs = Object.freeze({
            compile: Ae,
            compileAndLinkProps: Ee,
            compileRoot: Se,
            transclude: Ge
        }),
        ps = /^v-on:|^@/;
    ii.prototype._bind = function() {
        var t = this.name,
            e = this.descriptor;
        if (("cloak" !== t || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
            var i = e.attr || "v-" + t;
            "class" !== i ? this.el.removeAttribute(i) : Z(this.el, F(this.el.getAttribute("class")).trim().replace(/\s+/g, " "))
        }
        var n = e.def;
        if ("function" == typeof n ? this.update = n : v(this, n), this._setupParams(), this.bind && this.bind(), this._bound = !0, this.literal) this.update && this.update(e.raw);
        else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
            var r = this;
            this.update ? this._update = function(t, e) {
                r._locked || r.update(t, e)
            } : this._update = ei;
            var s = this._preProcess ? p(this._preProcess, this) : null,
                o = this._postProcess ? p(this._postProcess, this) : null,
                a = this._watcher = new Ut(this.vm, this.expression, this._update, {
                    filters: this.filters,
                    twoWay: this.twoWay,
                    deep: this.deep,
                    preProcess: s,
                    postProcess: o,
                    scope: this._scope
                });
            this.afterBind ? this.afterBind() : this.update && this.update(a.value)
        }
    }, ii.prototype._setupParams = function() {
        if (this.params) {
            var t = this.params;
            this.params = Object.create(null);
            for (var e, i, n, r = t.length; r--;) e = t[r], n = l(e), i = V(this.el, e), null != i ? this._setupParamWatcher(n, i) : (i = B(this.el, e), null != i && (this.params[n] = "" === i ? !0 : i))
        }
    }, ii.prototype._setupParamWatcher = function(t, e) {
        var i = this,
            n = !1,
            r = (this._scope || this.vm).$watch(e, function(e, r) {
                if (i.params[t] = e, n) {
                    var s = i.paramWatchers && i.paramWatchers[t];
                    s && s.call(i, e, r)
                } else n = !0
            }, {
                immediate: !0
            });
        (this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(r)
    }, ii.prototype._checkStatement = function() {
        var t = this.expression;
        if (t && this.acceptStatement && !Bt(t)) {
            var e = Wt(t).get,
                i = this._scope || this.vm,
                n = function(t) {
                    i.$event = t, e.call(i, i), i.$event = null
                };
            return this.filters && (n = i._applyFilters(n, null, this.filters)), this.update(n), !0
        }
    }, ii.prototype.set = function(t) {
        this.twoWay && this._withLock(function() {
            this._watcher.set(t)
        })
    }, ii.prototype._withLock = function(t) {
        var e = this;
        e._locked = !0, t.call(e), Di(function() {
            e._locked = !1
        })
    }, ii.prototype.on = function(t, e) {
        Q(this.el, t, e), (this._listeners || (this._listeners = [])).push([t, e])
    }, ii.prototype._teardown = function() {
        if (this._bound) {
            this._bound = !1, this.unbind && this.unbind(), this._watcher && this._watcher.teardown();
            var t, e = this._listeners;
            if (e)
                for (t = e.length; t--;) G(this.el, e[t][0], e[t][1]);
            var i = this._paramUnwatchFns;
            if (i)
                for (t = i.length; t--;) i[t]();
            this.vm = this.el = this._watcher = this._listeners = null
        }
    };
    var ds = /[^|]\|[^|]/;
    At(ci), Ye(ci), ti(ci), ni(ci), ri(ci), si(ci), oi(ci), ai(ci), hi(ci), li(ci);
    var vs = Lr._postProcess,
        ms = /(\d{3})(?=\d)/g,
        gs = {
            orderBy: pi,
            filterBy: fi,
            limitBy: ui,
            json: {
                read: function(t, e) {
                    return "string" == typeof t ? t : JSON.stringify(t, null, Number(e) || 2)
                },
                write: function(t) {
                    try {
                        return JSON.parse(t)
                    } catch (e) {
                        return t
                    }
                }
            },
            capitalize: function(t) {
                return t || 0 === t ? (t = t.toString(), t.charAt(0).toUpperCase() + t.slice(1)) : ""
            },
            uppercase: function(t) {
                return t || 0 === t ? t.toString().toUpperCase() : ""
            },
            lowercase: function(t) {
                return t || 0 === t ? t.toString().toLowerCase() : ""
            },
            currency: function(t, e) {
                if (t = parseFloat(t), !isFinite(t) || !t && 0 !== t) return "";
                e = null != e ? e : "$";
                var i = Math.abs(t).toFixed(2),
                    n = i.slice(0, -3),
                    r = n.length % 3,
                    s = r > 0 ? n.slice(0, r) + (n.length > 3 ? "," : "") : "",
                    o = i.slice(-3),
                    a = 0 > t ? "-" : "";
                return e + a + s + n.slice(r).replace(ms, "$1,") + o
            },
            pluralize: function(t) {
                var e = d(arguments, 1);
                return e.length > 1 ? e[t % 10 - 1] || e[e.length - 1] : e[0] + (1 === t ? "" : "s")
            },
            debounce: function(t, e) {
                return t ? (e || (e = 300), b(t, e)) : void 0
            }
        },
        _s = {
            priority: 1750,
            params: ["name"],
            paramWatchers: {
                name: function(t) {
                    Rr.remove.call(this), t && this.insert(t)
                }
            },
            bind: function() {
                this.anchor = nt("v-partial"), J(this.el, this.anchor), this.insert(this.params.name)
            },
            insert: function(t) {
                var e = _t(this.vm.$options, "partials", t);
                e && (this.factory = new pe(this.vm, e), Rr.insert.call(this))
            },
            unbind: function() {
                this.frag && this.frag.destroy()
            }
        },
        bs = {
            priority: 1750,
            bind: function() {
                var t = this.vm,
                    e = t.$options._content;
                if (!e) return void this.fallback();
                var i = t._context,
                    n = this.params && this.params.name;
                if (n) {
                    var r = '[slot="' + n + '"]',
                        s = e.querySelectorAll(r);
                    s.length ? this.tryCompile(vi(s, e), i, t) : this.fallback()
                } else this.tryCompile(vi(e.childNodes, e, !0), i, t)
            },
            tryCompile: function(t, e, i) {
                t.hasChildNodes() ? this.compile(t, e, i) : this.fallback()
            },
            compile: function(t, e, i) {
                if (t && e) {
                    var n = i ? i._scope : this._scope;
                    this.unlink = e.$compile(t, i, n, this._frag)
                }
                t ? J(this.el, t) : U(this.el)
            },
            fallback: function() {
                this.compile(Y(this.el, !0), this.vm)
            },
            unbind: function() {
                this.unlink && this.unlink()
            }
        },
        ys = v(v({}, bs), {
            priority: bs.priority + 1,
            params: ["name"]
        }),
        Cs = {
            slot: bs,
            _namedSlot: ys,
            partial: _s
        };
    return ci.version = "1.0.12", ci.options = {
        directives: Vr,
        elementDirectives: Cs,
        filters: gs,
        transitions: {},
        components: {},
        partials: {},
        replace: !0
    }, ci
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJ2dWUubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIiEgZnVuY3Rpb24odCwgZSkge1xuICAgIFwib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgPSBlKCkgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGUpIDogdC5WdWUgPSBlKClcbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiB0KGUsIG4sIHIpIHtcbiAgICAgICAgaWYgKGkoZSwgbikpIHJldHVybiB2b2lkKGVbbl0gPSByKTtcbiAgICAgICAgaWYgKGUuX2lzVnVlKSByZXR1cm4gdm9pZCB0KGUuX2RhdGEsIG4sIHIpO1xuICAgICAgICB2YXIgcyA9IGUuX19vYl9fO1xuICAgICAgICBpZiAoIXMpIHJldHVybiB2b2lkKGVbbl0gPSByKTtcbiAgICAgICAgaWYgKHMuY29udmVydChuLCByKSwgcy5kZXAubm90aWZ5KCksIHMudm1zKVxuICAgICAgICAgICAgZm9yICh2YXIgbyA9IHMudm1zLmxlbmd0aDsgby0tOykge1xuICAgICAgICAgICAgICAgIHZhciBhID0gcy52bXNbb107XG4gICAgICAgICAgICAgICAgYS5fcHJveHkobiksIGEuX2RpZ2VzdCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZSh0LCBlKSB7XG4gICAgICAgIGlmIChpKHQsIGUpKSB7XG4gICAgICAgICAgICBkZWxldGUgdFtlXTtcbiAgICAgICAgICAgIHZhciBuID0gdC5fX29iX187XG4gICAgICAgICAgICBpZiAobiAmJiAobi5kZXAubm90aWZ5KCksIG4udm1zKSlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gbi52bXMubGVuZ3RoOyByLS07KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gbi52bXNbcl07XG4gICAgICAgICAgICAgICAgICAgIHMuX3VucHJveHkoZSksIHMuX2RpZ2VzdCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaSh0LCBlKSB7XG4gICAgICAgIHJldHVybiBtaS5jYWxsKHQsIGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbih0KSB7XG4gICAgICAgIHJldHVybiBnaS50ZXN0KHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcih0KSB7XG4gICAgICAgIHZhciBlID0gKHQgKyBcIlwiKS5jaGFyQ29kZUF0KDApO1xuICAgICAgICByZXR1cm4gMzYgPT09IGUgfHwgOTUgPT09IGVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzKHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGwgPT0gdCA/IFwiXCIgOiB0LnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvKHQpIHtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIHQpIHJldHVybiB0O1xuICAgICAgICB2YXIgZSA9IE51bWJlcih0KTtcbiAgICAgICAgcmV0dXJuIGlzTmFOKGUpID8gdCA6IGVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhKHQpIHtcbiAgICAgICAgcmV0dXJuIFwidHJ1ZVwiID09PSB0ID8gITAgOiBcImZhbHNlXCIgPT09IHQgPyAhMSA6IHRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0LmNoYXJDb2RlQXQoMCksXG4gICAgICAgICAgICBpID0gdC5jaGFyQ29kZUF0KHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBlICE9PSBpIHx8IDM0ICE9PSBlICYmIDM5ICE9PSBlID8gdCA6IHQuc2xpY2UoMSwgLTEpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbCh0KSB7XG4gICAgICAgIHJldHVybiB0LnJlcGxhY2UoX2ksIGMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYyh0LCBlKSB7XG4gICAgICAgIHJldHVybiBlID8gZS50b1VwcGVyQ2FzZSgpIDogXCJcIlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHUodCkge1xuICAgICAgICByZXR1cm4gdC5yZXBsYWNlKGJpLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmKHQpIHtcbiAgICAgICAgcmV0dXJuIHQucmVwbGFjZSh5aSwgYylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBuID8gbiA+IDEgPyB0LmFwcGx5KGUsIGFyZ3VtZW50cykgOiB0LmNhbGwoZSwgaSkgOiB0LmNhbGwoZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGQodCwgZSkge1xuICAgICAgICBlID0gZSB8fCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gdC5sZW5ndGggLSBlLCBuID0gbmV3IEFycmF5KGkpOyBpLS07KSBuW2ldID0gdFtpICsgZV07XG4gICAgICAgIHJldHVybiBuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdih0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBPYmplY3Qua2V5cyhlKSwgbiA9IGkubGVuZ3RoOyBuLS07KSB0W2lbbl1dID0gZVtpW25dXTtcbiAgICAgICAgcmV0dXJuIHRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtKHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGwgIT09IHQgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGcodCkge1xuICAgICAgICByZXR1cm4gQ2kuY2FsbCh0KSA9PT0gd2lcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfKHQsIGUsIGksIG4pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIGUsIHtcbiAgICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogISFuLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGIodCwgZSkge1xuICAgICAgICB2YXIgaSwgbiwgciwgcywgbywgYSA9IGZ1bmN0aW9uIGgoKSB7XG4gICAgICAgICAgICB2YXIgYSA9IERhdGUubm93KCkgLSBzO1xuICAgICAgICAgICAgZSA+IGEgJiYgYSA+PSAwID8gaSA9IHNldFRpbWVvdXQoaCwgZSAtIGEpIDogKGkgPSBudWxsLCBvID0gdC5hcHBseShyLCBuKSwgaSB8fCAociA9IG4gPSBudWxsKSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHIgPSB0aGlzLCBuID0gYXJndW1lbnRzLCBzID0gRGF0ZS5ub3coKSwgaSB8fCAoaSA9IHNldFRpbWVvdXQoYSwgZSkpLCBvXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB5KHQsIGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHQubGVuZ3RoOyBpLS07KVxuICAgICAgICAgICAgaWYgKHRbaV0gPT09IGUpIHJldHVybiBpO1xuICAgICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDKHQpIHtcbiAgICAgICAgdmFyIGUgPSBmdW5jdGlvbiBpKCkge1xuICAgICAgICAgICAgcmV0dXJuIGkuY2FuY2VsbGVkID8gdm9pZCAwIDogdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZS5jYW5jZWxsZWQgPSAhMFxuICAgICAgICB9LCBlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdyh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0ID09IGUgfHwgKG0odCkgJiYgbShlKSA/IEpTT04uc3RyaW5naWZ5KHQpID09PSBKU09OLnN0cmluZ2lmeShlKSA6ICExKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQodCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwLCB0aGlzLmxpbWl0ID0gdCwgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gdm9pZCAwLCB0aGlzLl9rZXltYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaygpIHtcbiAgICAgICAgdmFyIHQsIGUgPSBSaS5zbGljZShNaSwgQmkpLnRyaW0oKTtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIHQgPSB7fTtcbiAgICAgICAgICAgIHZhciBpID0gZS5tYXRjaChHaSk7XG4gICAgICAgICAgICB0Lm5hbWUgPSBpWzBdLCBpLmxlbmd0aCA+IDEgJiYgKHQuYXJncyA9IGkuc2xpY2UoMSkubWFwKHgpKVxuICAgICAgICB9XG4gICAgICAgIHQgJiYgKEhpLmZpbHRlcnMgPSBIaS5maWx0ZXJzIHx8IFtdKS5wdXNoKHQpLCBNaSA9IEJpICsgMVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHgodCkge1xuICAgICAgICBpZiAoWmkudGVzdCh0KSkgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBvKHQpLFxuICAgICAgICAgICAgZHluYW1pYzogITFcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGUgPSBoKHQpLFxuICAgICAgICAgICAgaSA9IGUgPT09IHQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogaSA/IHQgOiBlLFxuICAgICAgICAgICAgZHluYW1pYzogaVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQSh0KSB7XG4gICAgICAgIHZhciBlID0gUWkuZ2V0KHQpO1xuICAgICAgICBpZiAoZSkgcmV0dXJuIGU7XG4gICAgICAgIGZvciAoUmkgPSB0LCB6aSA9IElpID0gITEsIFVpID0gcWkgPSBKaSA9IDAsIE1pID0gMCwgSGkgPSB7fSwgQmkgPSAwLCBWaSA9IFJpLmxlbmd0aDsgVmkgPiBCaTsgQmkrKylcbiAgICAgICAgICAgIGlmIChXaSA9IExpLCBMaSA9IFJpLmNoYXJDb2RlQXQoQmkpLCB6aSkgMzkgPT09IExpICYmIDkyICE9PSBXaSAmJiAoemkgPSAhemkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoSWkpIDM0ID09PSBMaSAmJiA5MiAhPT0gV2kgJiYgKElpID0gIUlpKTtcbiAgICAgICAgZWxzZSBpZiAoMTI0ID09PSBMaSAmJiAxMjQgIT09IFJpLmNoYXJDb2RlQXQoQmkgKyAxKSAmJiAxMjQgIT09IFJpLmNoYXJDb2RlQXQoQmkgLSAxKSkgbnVsbCA9PSBIaS5leHByZXNzaW9uID8gKE1pID0gQmkgKyAxLCBIaS5leHByZXNzaW9uID0gUmkuc2xpY2UoMCwgQmkpLnRyaW0oKSkgOiBrKCk7XG4gICAgICAgIGVsc2Ugc3dpdGNoIChMaSkge1xuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICBJaSA9ICEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgICB6aSA9ICEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgICBKaSsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0MTpcbiAgICAgICAgICAgICAgICBKaS0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgICAgICAgICBxaSsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA5MzpcbiAgICAgICAgICAgICAgICBxaS0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgICAgICAgVWkrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgICAgICAgIFVpLS1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbCA9PSBIaS5leHByZXNzaW9uID8gSGkuZXhwcmVzc2lvbiA9IFJpLnNsaWNlKDAsIEJpKS50cmltKCkgOiAwICE9PSBNaSAmJiBrKCksIFFpLnB1dCh0LCBIaSksIEhpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTyh0KSB7XG4gICAgICAgIHJldHVybiB0LnJlcGxhY2UoWGksIFwiXFxcXCQmXCIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTigpIHtcbiAgICAgICAgdmFyIHQgPSBPKGFuLmRlbGltaXRlcnNbMF0pLFxuICAgICAgICAgICAgZSA9IE8oYW4uZGVsaW1pdGVyc1sxXSksXG4gICAgICAgICAgICBpID0gTyhhbi51bnNhZmVEZWxpbWl0ZXJzWzBdKSxcbiAgICAgICAgICAgIG4gPSBPKGFuLnVuc2FmZURlbGltaXRlcnNbMV0pO1xuICAgICAgICB0biA9IG5ldyBSZWdFeHAoaSArIFwiKC4rPylcIiArIG4gKyBcInxcIiArIHQgKyBcIiguKz8pXCIgKyBlLCBcImdcIiksIGVuID0gbmV3IFJlZ0V4cChcIl5cIiArIGkgKyBcIi4qXCIgKyBuICsgXCIkXCIpLCBZaSA9IG5ldyAkKDFlMylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBUKHQpIHtcbiAgICAgICAgWWkgfHwgTigpO1xuICAgICAgICB2YXIgZSA9IFlpLmdldCh0KTtcbiAgICAgICAgaWYgKGUpIHJldHVybiBlO1xuICAgICAgICBpZiAodCA9IHQucmVwbGFjZSgvXFxuL2csIFwiXCIpLCAhdG4udGVzdCh0KSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAodmFyIGksIG4sIHIsIHMsIG8sIGEsIGggPSBbXSwgbCA9IHRuLmxhc3RJbmRleCA9IDA7IGkgPSB0bi5leGVjKHQpOykgbiA9IGkuaW5kZXgsIG4gPiBsICYmIGgucHVzaCh7XG4gICAgICAgICAgICB2YWx1ZTogdC5zbGljZShsLCBuKVxuICAgICAgICB9KSwgciA9IGVuLnRlc3QoaVswXSksIHMgPSByID8gaVsxXSA6IGlbMl0sIG8gPSBzLmNoYXJDb2RlQXQoMCksIGEgPSA0MiA9PT0gbywgcyA9IGEgPyBzLnNsaWNlKDEpIDogcywgaC5wdXNoKHtcbiAgICAgICAgICAgIHRhZzogITAsXG4gICAgICAgICAgICB2YWx1ZTogcy50cmltKCksXG4gICAgICAgICAgICBodG1sOiByLFxuICAgICAgICAgICAgb25lVGltZTogYVxuICAgICAgICB9KSwgbCA9IG4gKyBpWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGwgPCB0Lmxlbmd0aCAmJiBoLnB1c2goe1xuICAgICAgICAgICAgdmFsdWU6IHQuc2xpY2UobClcbiAgICAgICAgfSksIFlpLnB1dCh0LCBoKSwgaFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGoodCkge1xuICAgICAgICByZXR1cm4gdC5sZW5ndGggPiAxID8gdC5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIEUodClcbiAgICAgICAgfSkuam9pbihcIitcIikgOiBFKHRbMF0sICEwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEUodCwgZSkge1xuICAgICAgICByZXR1cm4gdC50YWcgPyBTKHQudmFsdWUsIGUpIDogJ1wiJyArIHQudmFsdWUgKyAnXCInXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUyh0LCBlKSB7XG4gICAgICAgIGlmIChubi50ZXN0KHQpKSB7XG4gICAgICAgICAgICB2YXIgaSA9IEEodCk7XG4gICAgICAgICAgICByZXR1cm4gaS5maWx0ZXJzID8gXCJ0aGlzLl9hcHBseUZpbHRlcnMoXCIgKyBpLmV4cHJlc3Npb24gKyBcIixudWxsLFwiICsgSlNPTi5zdHJpbmdpZnkoaS5maWx0ZXJzKSArIFwiLGZhbHNlKVwiIDogXCIoXCIgKyB0ICsgXCIpXCJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZSA/IHQgOiBcIihcIiArIHQgKyBcIilcIlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEYodCkge1xuICAgICAgICByZXR1cm4gdC5yZXBsYWNlKHRuLCBcIlwiKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEQodCwgZSwgaSwgbikge1xuICAgICAgICBIKHQsIDEsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0KVxuICAgICAgICB9LCBpLCBuKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFAodCwgZSwgaSwgbikge1xuICAgICAgICBIKHQsIDEsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgeih0LCBlKVxuICAgICAgICB9LCBpLCBuKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFIodCwgZSwgaSkge1xuICAgICAgICBIKHQsIC0xLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFUodClcbiAgICAgICAgfSwgZSwgaSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBIKHQsIGUsIGksIG4sIHIpIHtcbiAgICAgICAgdmFyIHMgPSB0Ll9fdl90cmFucztcbiAgICAgICAgaWYgKCFzIHx8ICFzLmhvb2tzICYmICFUaSB8fCAhbi5faXNDb21waWxlZCB8fCBuLiRwYXJlbnQgJiYgIW4uJHBhcmVudC5faXNDb21waWxlZCkgcmV0dXJuIGkoKSwgdm9pZChyICYmIHIoKSk7XG4gICAgICAgIHZhciBvID0gZSA+IDAgPyBcImVudGVyXCIgOiBcImxlYXZlXCI7XG4gICAgICAgIHNbb10oaSwgcilcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMKHQpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgKHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpKSwgdFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFcodCkge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICAgIGkgPSB0ICYmIHQucGFyZW50Tm9kZTtcbiAgICAgICAgcmV0dXJuIGUgPT09IHQgfHwgZSA9PT0gaSB8fCAhKCFpIHx8IDEgIT09IGkubm9kZVR5cGUgfHwgIWUuY29udGFpbnMoaSkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQih0LCBlKSB7XG4gICAgICAgIHZhciBpID0gdC5nZXRBdHRyaWJ1dGUoZSk7XG4gICAgICAgIHJldHVybiBudWxsICE9PSBpICYmIHQucmVtb3ZlQXR0cmlidXRlKGUpLCBpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVih0LCBlKSB7XG4gICAgICAgIHZhciBpID0gQih0LCBcIjpcIiArIGUpO1xuICAgICAgICByZXR1cm4gbnVsbCA9PT0gaSAmJiAoaSA9IEIodCwgXCJ2LWJpbmQ6XCIgKyBlKSksIGlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHQuaGFzQXR0cmlidXRlKGUpIHx8IHQuaGFzQXR0cmlidXRlKFwiOlwiICsgZSkgfHwgdC5oYXNBdHRyaWJ1dGUoXCJ2LWJpbmQ6XCIgKyBlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHoodCwgZSkge1xuICAgICAgICBlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsIGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSSh0LCBlKSB7XG4gICAgICAgIGUubmV4dFNpYmxpbmcgPyB6KHQsIGUubmV4dFNpYmxpbmcpIDogZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVSh0KSB7XG4gICAgICAgIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHEodCwgZSkge1xuICAgICAgICBlLmZpcnN0Q2hpbGQgPyB6KHQsIGUuZmlyc3RDaGlsZCkgOiBlLmFwcGVuZENoaWxkKHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSih0LCBlKSB7XG4gICAgICAgIHZhciBpID0gdC5wYXJlbnROb2RlO1xuICAgICAgICBpICYmIGkucmVwbGFjZUNoaWxkKGUsIHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUSh0LCBlLCBpKSB7XG4gICAgICAgIHQuYWRkRXZlbnRMaXN0ZW5lcihlLCBpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEcodCwgZSwgaSkge1xuICAgICAgICB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgaSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBaKHQsIGUpIHtcbiAgICAgICAgIUFpIHx8IHQgaW5zdGFuY2VvZiBTVkdFbGVtZW50ID8gdC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBlKSA6IHQuY2xhc3NOYW1lID0gZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEsodCwgZSkge1xuICAgICAgICBpZiAodC5jbGFzc0xpc3QpIHQuY2xhc3NMaXN0LmFkZChlKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaSA9IFwiIFwiICsgKHQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIikgKyBcIiBcIjtcbiAgICAgICAgICAgIGkuaW5kZXhPZihcIiBcIiArIGUgKyBcIiBcIikgPCAwICYmIFoodCwgKGkgKyBlKS50cmltKCkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBYKHQsIGUpIHtcbiAgICAgICAgaWYgKHQuY2xhc3NMaXN0KSB0LmNsYXNzTGlzdC5yZW1vdmUoZSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IFwiIFwiICsgKHQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIikgKyBcIiBcIiwgbiA9IFwiIFwiICsgZSArIFwiIFwiOyBpLmluZGV4T2YobikgPj0gMDspIGkgPSBpLnJlcGxhY2UobiwgXCIgXCIpO1xuICAgICAgICAgICAgWih0LCBpLnRyaW0oKSlcbiAgICAgICAgfVxuICAgICAgICB0LmNsYXNzTmFtZSB8fCB0LnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWSh0LCBlKSB7XG4gICAgICAgIHZhciBpLCBuO1xuICAgICAgICBpZiAoaXQodCkgJiYgdC5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCAmJiAodCA9IHQuY29udGVudCksIHQuaGFzQ2hpbGROb2RlcygpKVxuICAgICAgICAgICAgZm9yICh0dCh0KSwgbiA9IGUgPyBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpOyBpID0gdC5maXJzdENoaWxkOykgbi5hcHBlbmRDaGlsZChpKTtcbiAgICAgICAgcmV0dXJuIG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0dCh0KSB7XG4gICAgICAgIGV0KHQsIHQuZmlyc3RDaGlsZCksIGV0KHQsIHQubGFzdENoaWxkKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV0KHQsIGUpIHtcbiAgICAgICAgZSAmJiAzID09PSBlLm5vZGVUeXBlICYmICFlLmRhdGEudHJpbSgpICYmIHQucmVtb3ZlQ2hpbGQoZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdCh0KSB7XG4gICAgICAgIHJldHVybiB0LnRhZ05hbWUgJiYgXCJ0ZW1wbGF0ZVwiID09PSB0LnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG50KHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSBhbi5kZWJ1ZyA/IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodCkgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlID8gXCIgXCIgOiBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGkuX192dWVfYW5jaG9yID0gITAsIGlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydCh0KSB7XG4gICAgICAgIGlmICh0Lmhhc0F0dHJpYnV0ZXMoKSlcbiAgICAgICAgICAgIGZvciAodmFyIGUgPSB0LmF0dHJpYnV0ZXMsIGkgPSAwLCBuID0gZS5sZW5ndGg7IG4gPiBpOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGVbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobG4udGVzdChyKSkgcmV0dXJuIGwoci5yZXBsYWNlKGxuLCBcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdCh0LCBlLCBpKSB7XG4gICAgICAgIGZvciAodmFyIG47IHQgIT09IGU7KSBuID0gdC5uZXh0U2libGluZywgaSh0KSwgdCA9IG47XG4gICAgICAgIGkoZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvdCh0LCBlLCBpLCBuLCByKSB7XG4gICAgICAgIGZ1bmN0aW9uIHMoKSB7XG4gICAgICAgICAgICBpZiAoYSsrLCBvICYmIGEgPj0gaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGgubGVuZ3RoOyB0KyspIG4uYXBwZW5kQ2hpbGQoaFt0XSk7XG4gICAgICAgICAgICAgICAgciAmJiByKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbyA9ICExLFxuICAgICAgICAgICAgYSA9IDAsXG4gICAgICAgICAgICBoID0gW107XG4gICAgICAgIHN0KHQsIGUsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHQgPT09IGUgJiYgKG8gPSAhMCksIGgucHVzaCh0KSwgUih0LCBpLCBzKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF0KHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSB0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIG4gPSB0Lmhhc0F0dHJpYnV0ZXMoKTtcbiAgICAgICAgaWYgKGNuLnRlc3QoaSkgfHwgdW4udGVzdChpKSkge1xuICAgICAgICAgICAgaWYgKG4pIHJldHVybiBodCh0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKF90KGUsIFwiY29tcG9uZW50c1wiLCBpKSkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByID0gbiAmJiBodCh0KTtcbiAgICAgICAgICAgIGlmIChyKSByZXR1cm4gclxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHQodCkge1xuICAgICAgICB2YXIgZSA9IEIodCwgXCJpc1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGwgIT0gZSA/IHtcbiAgICAgICAgICAgIGlkOiBlXG4gICAgICAgIH0gOiAoZSA9IFYodCwgXCJpc1wiKSwgbnVsbCAhPSBlID8ge1xuICAgICAgICAgICAgaWQ6IGUsXG4gICAgICAgICAgICBkeW5hbWljOiAhMFxuICAgICAgICB9IDogdm9pZCAwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGx0KHQsIGUsIGkpIHtcbiAgICAgICAgdmFyIG4gPSBlLnBhdGg7XG4gICAgICAgIGkgPSB1dChlLCBpKSwgdFtuXSA9IHQuX2RhdGFbbl0gPSBjdChlLCBpKSA/IGkgOiB2b2lkIDBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdCh0LCBlKSB7XG4gICAgICAgIGlmIChudWxsID09PSB0LnJhdyAmJiAhdC5yZXF1aXJlZCkgcmV0dXJuICEwO1xuICAgICAgICB2YXIgaSwgbiA9IHQub3B0aW9ucyxcbiAgICAgICAgICAgIHIgPSBuLnR5cGUsXG4gICAgICAgICAgICBzID0gITA7XG4gICAgICAgIGlmIChyICYmIChyID09PSBTdHJpbmcgPyAoaSA9IFwic3RyaW5nXCIsIHMgPSB0eXBlb2YgZSA9PT0gaSkgOiByID09PSBOdW1iZXIgPyAoaSA9IFwibnVtYmVyXCIsIHMgPSBcIm51bWJlclwiID09IHR5cGVvZiBlKSA6IHIgPT09IEJvb2xlYW4gPyAoaSA9IFwiYm9vbGVhblwiLCBzID0gXCJib29sZWFuXCIgPT0gdHlwZW9mIGUpIDogciA9PT0gRnVuY3Rpb24gPyAoaSA9IFwiZnVuY3Rpb25cIiwgcyA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkgOiByID09PSBPYmplY3QgPyAoaSA9IFwib2JqZWN0XCIsIHMgPSBnKGUpKSA6IHIgPT09IEFycmF5ID8gKGkgPSBcImFycmF5XCIsIHMgPSAkaShlKSkgOiBzID0gZSBpbnN0YW5jZW9mIHIpLCAhcykgcmV0dXJuICExO1xuICAgICAgICB2YXIgbyA9IG4udmFsaWRhdG9yO1xuICAgICAgICByZXR1cm4gbyAmJiAhby5jYWxsKG51bGwsIGUpID8gITEgOiAhMFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV0KHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSB0Lm9wdGlvbnMuY29lcmNlO1xuICAgICAgICByZXR1cm4gaSA/IGkoZSkgOiBlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnQoZSwgbikge1xuICAgICAgICB2YXIgciwgcywgbztcbiAgICAgICAgZm9yIChyIGluIG4pIHMgPSBlW3JdLCBvID0gbltyXSwgaShlLCByKSA/IG0ocykgJiYgbShvKSAmJiBmdChzLCBvKSA6IHQoZSwgciwgbyk7XG4gICAgICAgIHJldHVybiBlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHQodCwgZSkge1xuICAgICAgICB2YXIgaSA9IE9iamVjdC5jcmVhdGUodCk7XG4gICAgICAgIHJldHVybiBlID8gdihpLCBtdChlKSkgOiBpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHQodCkge1xuICAgICAgICBpZiAodC5jb21wb25lbnRzKVxuICAgICAgICAgICAgZm9yICh2YXIgZSwgaSA9IHQuY29tcG9uZW50cyA9IG10KHQuY29tcG9uZW50cyksIG4gPSBPYmplY3Qua2V5cyhpKSwgciA9IDAsIHMgPSBuLmxlbmd0aDsgcyA+IHI7IHIrKykge1xuICAgICAgICAgICAgICAgIHZhciBvID0gbltyXTtcbiAgICAgICAgICAgICAgICBjbi50ZXN0KG8pIHx8IHVuLnRlc3QobykgfHwgKGUgPSBpW29dLCBnKGUpICYmIChpW29dID0gY2kuZXh0ZW5kKGUpKSlcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2dCh0KSB7XG4gICAgICAgIHZhciBlLCBpLCBuID0gdC5wcm9wcztcbiAgICAgICAgaWYgKCRpKG4pKVxuICAgICAgICAgICAgZm9yICh0LnByb3BzID0ge30sIGUgPSBuLmxlbmd0aDsgZS0tOykgaSA9IG5bZV0sIFwic3RyaW5nXCIgPT0gdHlwZW9mIGkgPyB0LnByb3BzW2ldID0gbnVsbCA6IGkubmFtZSAmJiAodC5wcm9wc1tpLm5hbWVdID0gaSk7XG4gICAgICAgIGVsc2UgaWYgKGcobikpIHtcbiAgICAgICAgICAgIHZhciByID0gT2JqZWN0LmtleXMobik7XG4gICAgICAgICAgICBmb3IgKGUgPSByLmxlbmd0aDsgZS0tOykgaSA9IG5bcltlXV0sIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaSAmJiAobltyW2VdXSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXQodCkge1xuICAgICAgICBpZiAoJGkodCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGUsIGkgPSB7fSwgbiA9IHQubGVuZ3RoOyBuLS07KSB7XG4gICAgICAgICAgICAgICAgZSA9IHRbbl07XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgPyBlLm9wdGlvbnMgJiYgZS5vcHRpb25zLm5hbWUgfHwgZS5pZCA6IGUubmFtZSB8fCBlLmlkO1xuICAgICAgICAgICAgICAgIHIgJiYgKGlbcl0gPSBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGd0KHQsIGUsIG4pIHtcbiAgICAgICAgZnVuY3Rpb24gcihpKSB7XG4gICAgICAgICAgICB2YXIgciA9IGZuW2ldIHx8IHBuO1xuICAgICAgICAgICAgb1tpXSA9IHIodFtpXSwgZVtpXSwgbiwgaSlcbiAgICAgICAgfVxuICAgICAgICBkdChlKSwgdnQoZSk7XG4gICAgICAgIHZhciBzLCBvID0ge307XG4gICAgICAgIGlmIChlLm1peGlucylcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwLCBoID0gZS5taXhpbnMubGVuZ3RoOyBoID4gYTsgYSsrKSB0ID0gZ3QodCwgZS5taXhpbnNbYV0sIG4pO1xuICAgICAgICBmb3IgKHMgaW4gdCkgcihzKTtcbiAgICAgICAgZm9yIChzIGluIGUpIGkodCwgcykgfHwgcihzKTtcbiAgICAgICAgcmV0dXJuIG9cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdCh0LCBlLCBpKSB7XG4gICAgICAgIHZhciBuLCByID0gdFtlXTtcbiAgICAgICAgcmV0dXJuIHJbaV0gfHwgcltuID0gbChpKV0gfHwgcltuLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbi5zbGljZSgxKV1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidCh0LCBlLCBpKSB7fVxuXG4gICAgZnVuY3Rpb24geXQoKSB7XG4gICAgICAgIHRoaXMuaWQgPSBtbisrLCB0aGlzLnN1YnMgPSBbXVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEN0KHQpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPSB0LCB0aGlzLmRlcCA9IG5ldyB5dCwgXyh0LCBcIl9fb2JfX1wiLCB0aGlzKSwgJGkodCkpIHtcbiAgICAgICAgICAgIHZhciBlID0ga2kgPyB3dCA6ICR0O1xuICAgICAgICAgICAgZSh0LCB2biwgZ24pLCB0aGlzLm9ic2VydmVBcnJheSh0KVxuICAgICAgICB9IGVsc2UgdGhpcy53YWxrKHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3QodCwgZSkge1xuICAgICAgICB0Ll9fcHJvdG9fXyA9IGVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkdCh0LCBlLCBpKSB7XG4gICAgICAgIGZvciAodmFyIG4sIHIgPSBpLmxlbmd0aDsgci0tOykgbiA9IGlbcl0sIF8odCwgbiwgZVtuXSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrdCh0LCBlKSB7XG4gICAgICAgIGlmICh0ICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHQpIHtcbiAgICAgICAgICAgIHZhciBuO1xuICAgICAgICAgICAgcmV0dXJuIGkodCwgXCJfX29iX19cIikgJiYgdC5fX29iX18gaW5zdGFuY2VvZiBDdCA/IG4gPSB0Ll9fb2JfXyA6ICgkaSh0KSB8fCBnKHQpKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHQpICYmICF0Ll9pc1Z1ZSAmJiAobiA9IG5ldyBDdCh0KSksIG4gJiYgZSAmJiBuLmFkZFZtKGUpLCBuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB4dCh0LCBlLCBpKSB7XG4gICAgICAgIHZhciBuLCByLCBzID0gbmV3IHl0O1xuICAgICAgICBpZiAoYW4uY29udmVydEFsbFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCBlKTtcbiAgICAgICAgICAgIGlmIChvICYmIG8uY29uZmlndXJhYmxlID09PSAhMSkgcmV0dXJuO1xuICAgICAgICAgICAgbiA9IG8gJiYgby5nZXQsIHIgPSBvICYmIG8uc2V0XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSBrdChpKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIGUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBuID8gbi5jYWxsKHQpIDogaTtcbiAgICAgICAgICAgICAgICBpZiAoeXQudGFyZ2V0ICYmIChzLmRlcGVuZCgpLCBhICYmIGEuZGVwLmRlcGVuZCgpLCAkaShlKSkpXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIsIG8gPSAwLCBoID0gZS5sZW5ndGg7IGggPiBvOyBvKyspIHIgPSBlW29dLCByICYmIHIuX19vYl9fICYmIHIuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHZhciBvID0gbiA/IG4uY2FsbCh0KSA6IGk7XG4gICAgICAgICAgICAgICAgZSAhPT0gbyAmJiAociA/IHIuY2FsbCh0LCBlKSA6IGkgPSBlLCBhID0ga3QoZSksIHMubm90aWZ5KCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQXQodCkge1xuICAgICAgICB0LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHQgPSB0IHx8IHt9LCB0aGlzLiRlbCA9IG51bGwsIHRoaXMuJHBhcmVudCA9IHQucGFyZW50LCB0aGlzLiRyb290ID0gdGhpcy4kcGFyZW50ID8gdGhpcy4kcGFyZW50LiRyb290IDogdGhpcywgdGhpcy4kY2hpbGRyZW4gPSBbXSwgdGhpcy4kcmVmcyA9IHt9LCB0aGlzLiRlbHMgPSB7fSwgdGhpcy5fd2F0Y2hlcnMgPSBbXSwgdGhpcy5fZGlyZWN0aXZlcyA9IFtdLCB0aGlzLl91aWQgPSBibisrLCB0aGlzLl9pc1Z1ZSA9ICEwLCB0aGlzLl9ldmVudHMgPSB7fSwgdGhpcy5fZXZlbnRzQ291bnQgPSB7fSwgdGhpcy5faXNGcmFnbWVudCA9ICExLCB0aGlzLl9mcmFnbWVudCA9IHRoaXMuX2ZyYWdtZW50U3RhcnQgPSB0aGlzLl9mcmFnbWVudEVuZCA9IG51bGwsIHRoaXMuX2lzQ29tcGlsZWQgPSB0aGlzLl9pc0Rlc3Ryb3llZCA9IHRoaXMuX2lzUmVhZHkgPSB0aGlzLl9pc0F0dGFjaGVkID0gdGhpcy5faXNCZWluZ0Rlc3Ryb3llZCA9ICExLCB0aGlzLl91bmxpbmtGbiA9IG51bGwsIHRoaXMuX2NvbnRleHQgPSB0Ll9jb250ZXh0IHx8IHRoaXMuJHBhcmVudCwgdGhpcy5fc2NvcGUgPSB0Ll9zY29wZSwgdGhpcy5fZnJhZyA9IHQuX2ZyYWcsIHRoaXMuX2ZyYWcgJiYgdGhpcy5fZnJhZy5jaGlsZHJlbi5wdXNoKHRoaXMpLCB0aGlzLiRwYXJlbnQgJiYgdGhpcy4kcGFyZW50LiRjaGlsZHJlbi5wdXNoKHRoaXMpLCB0ID0gdGhpcy4kb3B0aW9ucyA9IGd0KHRoaXMuY29uc3RydWN0b3Iub3B0aW9ucywgdCwgdGhpcyksIHRoaXMuX3VwZGF0ZVJlZigpLCB0aGlzLl9kYXRhID0ge30sIHRoaXMuX2NhbGxIb29rKFwiaW5pdFwiKSwgdGhpcy5faW5pdFN0YXRlKCksIHRoaXMuX2luaXRFdmVudHMoKSwgdGhpcy5fY2FsbEhvb2soXCJjcmVhdGVkXCIpLCB0LmVsICYmIHRoaXMuJG1vdW50KHQuZWwpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBPdCh0KSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IHQpIHJldHVybiBcImVvZlwiO1xuICAgICAgICB2YXIgZSA9IHQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgICAgICBjYXNlIDkxOlxuICAgICAgICAgICAgY2FzZSA5MzpcbiAgICAgICAgICAgIGNhc2UgNDY6XG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgIGNhc2UgNDg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICBjYXNlIDk1OlxuICAgICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJpZGVudFwiO1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgY2FzZSAxNjA6XG4gICAgICAgICAgICBjYXNlIDY1Mjc5OlxuICAgICAgICAgICAgY2FzZSA4MjMyOlxuICAgICAgICAgICAgY2FzZSA4MjMzOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIndzXCJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZSA+PSA5NyAmJiAxMjIgPj0gZSB8fCBlID49IDY1ICYmIDkwID49IGUgPyBcImlkZW50XCIgOiBlID49IDQ5ICYmIDU3ID49IGUgPyBcIm51bWJlclwiIDogXCJlbHNlXCJcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBOdCh0KSB7XG4gICAgICAgIHZhciBlID0gdC50cmltKCk7XG4gICAgICAgIHJldHVybiBcIjBcIiA9PT0gdC5jaGFyQXQoMCkgJiYgaXNOYU4odCkgPyAhMSA6IG4oZSkgPyBoKGUpIDogXCIqXCIgKyBlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVHQodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0W2MgKyAxXTtcbiAgICAgICAgICAgIHJldHVybiB1ID09PSBqbiAmJiBcIidcIiA9PT0gZSB8fCB1ID09PSBFbiAmJiAnXCInID09PSBlID8gKGMrKywgbiA9IFwiXFxcXFwiICsgZSwgcFtDbl0oKSwgITApIDogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGksIG4sIHIsIHMsIG8sIGEsIGgsIGwgPSBbXSxcbiAgICAgICAgICAgIGMgPSAtMSxcbiAgICAgICAgICAgIHUgPSB4bixcbiAgICAgICAgICAgIGYgPSAwLFxuICAgICAgICAgICAgcCA9IFtdO1xuICAgICAgICBmb3IgKHBbd25dID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSByICYmIChsLnB1c2gociksIHIgPSB2b2lkIDApXG4gICAgICAgICAgICB9LCBwW0NuXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gciA/IHIgPSBuIDogciArPSBuXG4gICAgICAgICAgICB9LCBwWyRuXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBbQ25dKCksIGYrK1xuICAgICAgICAgICAgfSwgcFtrbl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZiA+IDApIGYtLSwgdSA9IFRuLCBwW0NuXSgpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZiA9IDAsIHIgPSBOdChyKSwgciA9PT0gITEpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgcFt3bl0oKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07IG51bGwgIT0gdTspXG4gICAgICAgICAgICBpZiAoYysrLCBpID0gdFtjXSwgXCJcXFxcXCIgIT09IGkgfHwgIWUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzID0gT3QoaSksIGggPSBEblt1XSwgbyA9IGhbc10gfHwgaFtcImVsc2VcIl0gfHwgRm4sIG8gPT09IEZuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHUgPSBvWzBdLCBhID0gcFtvWzFdXSwgYSAmJiAobiA9IG9bMl0sIG4gPSB2b2lkIDAgPT09IG4gPyBpIDogbiwgYSgpID09PSAhMSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodSA9PT0gU24pIHJldHVybiBsLnJhdyA9IHQsIGxcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqdCh0KSB7XG4gICAgICAgIHZhciBlID0geW4uZ2V0KHQpO1xuICAgICAgICByZXR1cm4gZSB8fCAoZSA9IFR0KHQpLCBlICYmIHluLnB1dCh0LCBlKSksIGVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBFdCh0LCBlKSB7XG4gICAgICAgIHJldHVybiBXdChlKS5nZXQodClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTdChlLCBpLCBuKSB7XG4gICAgICAgIHZhciByID0gZTtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGkgJiYgKGkgPSBUdChpKSksICFpIHx8ICFtKGUpKSByZXR1cm4gITE7XG4gICAgICAgIGZvciAodmFyIHMsIG8sIGEgPSAwLCBoID0gaS5sZW5ndGg7IGggPiBhOyBhKyspIHMgPSBlLCBvID0gaVthXSwgXCIqXCIgPT09IG8uY2hhckF0KDApICYmIChvID0gV3Qoby5zbGljZSgxKSkuZ2V0LmNhbGwociwgcikpLCBoIC0gMSA+IGEgPyAoZSA9IGVbb10sIG0oZSkgfHwgKGUgPSB7fSwgdChzLCBvLCBlKSkpIDogJGkoZSkgPyBlLiRzZXQobywgbikgOiBvIGluIGUgPyBlW29dID0gbiA6IHQoZSwgbywgbik7XG4gICAgICAgIHJldHVybiAhMFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEZ0KHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSBRbi5sZW5ndGg7XG4gICAgICAgIHJldHVybiBRbltpXSA9IGUgPyB0LnJlcGxhY2UoTW4sIFwiXFxcXG5cIikgOiB0LCAnXCInICsgaSArICdcIidcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdCh0KSB7XG4gICAgICAgIHZhciBlID0gdC5jaGFyQXQoMCksXG4gICAgICAgICAgICBpID0gdC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIExuLnRlc3QoaSkgPyB0IDogKGkgPSBpLmluZGV4T2YoJ1wiJykgPiAtMSA/IGkucmVwbGFjZShJbiwgUHQpIDogaSwgZSArIFwic2NvcGUuXCIgKyBpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFB0KHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIFFuW2VdXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUnQodCkge1xuICAgICAgICBCbi50ZXN0KHQpLCBRbi5sZW5ndGggPSAwO1xuICAgICAgICB2YXIgZSA9IHQucmVwbGFjZSh6biwgRnQpLnJlcGxhY2UoVm4sIFwiXCIpO1xuICAgICAgICByZXR1cm4gZSA9IChcIiBcIiArIGUpLnJlcGxhY2UocW4sIER0KS5yZXBsYWNlKEluLCBQdCksIEh0KGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSHQodCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInNjb3BlXCIsIFwicmV0dXJuIFwiICsgdCArIFwiO1wiKVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEx0KHQpIHtcbiAgICAgICAgdmFyIGUgPSBqdCh0KTtcbiAgICAgICAgcmV0dXJuIGUgPyBmdW5jdGlvbih0LCBpKSB7XG4gICAgICAgICAgICBTdCh0LCBlLCBpKVxuICAgICAgICB9IDogdm9pZCAwXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3QodCwgZSkge1xuICAgICAgICB0ID0gdC50cmltKCk7XG4gICAgICAgIHZhciBpID0gUm4uZ2V0KHQpO1xuICAgICAgICBpZiAoaSkgcmV0dXJuIGUgJiYgIWkuc2V0ICYmIChpLnNldCA9IEx0KGkuZXhwKSksIGk7XG4gICAgICAgIHZhciBuID0ge1xuICAgICAgICAgICAgZXhwOiB0XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuLmdldCA9IEJ0KHQpICYmIHQuaW5kZXhPZihcIltcIikgPCAwID8gSHQoXCJzY29wZS5cIiArIHQpIDogUnQodCksIGUgJiYgKG4uc2V0ID0gTHQodCkpLCBSbi5wdXQodCwgbiksIG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBCdCh0KSB7XG4gICAgICAgIHJldHVybiBVbi50ZXN0KHQpICYmICFKbi50ZXN0KHQpICYmIFwiTWF0aC5cIiAhPT0gdC5zbGljZSgwLCA1KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFZ0KCkge1xuICAgICAgICBabiA9IFtdLCBLbiA9IFtdLCBYbiA9IHt9LCBZbiA9IHt9LCB0ciA9IGVyID0gITFcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNdCgpIHtcbiAgICAgICAgenQoWm4pLCBlciA9ICEwLCB6dChLbiksIFZ0KClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6dCh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdC5sZW5ndGg7IGUrKykge1xuICAgICAgICAgICAgdmFyIGkgPSB0W2VdLFxuICAgICAgICAgICAgICAgIG4gPSBpLmlkO1xuICAgICAgICAgICAgWG5bbl0gPSBudWxsLCBpLnJ1bigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJdCh0KSB7XG4gICAgICAgIHZhciBlID0gdC5pZDtcbiAgICAgICAgaWYgKG51bGwgPT0gWG5bZV0pIHtcbiAgICAgICAgICAgIGlmIChlciAmJiAhdC51c2VyKSByZXR1cm4gdm9pZCB0LnJ1bigpO1xuICAgICAgICAgICAgdmFyIGkgPSB0LnVzZXIgPyBLbiA6IFpuO1xuICAgICAgICAgICAgWG5bZV0gPSBpLmxlbmd0aCwgaS5wdXNoKHQpLCB0ciB8fCAodHIgPSAhMCwgRGkoTXQpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVXQodCwgZSwgaSwgbikge1xuICAgICAgICBuICYmIHYodGhpcywgbik7XG4gICAgICAgIHZhciByID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBlO1xuICAgICAgICBpZiAodGhpcy52bSA9IHQsIHQuX3dhdGNoZXJzLnB1c2godGhpcyksIHRoaXMuZXhwcmVzc2lvbiA9IHIgPyBlLnRvU3RyaW5nKCkgOiBlLCB0aGlzLmNiID0gaSwgdGhpcy5pZCA9ICsraXIsIHRoaXMuYWN0aXZlID0gITAsIHRoaXMuZGlydHkgPSB0aGlzLmxhenksIHRoaXMuZGVwcyA9IE9iamVjdC5jcmVhdGUobnVsbCksIHRoaXMubmV3RGVwcyA9IG51bGwsIHRoaXMucHJldkVycm9yID0gbnVsbCwgcikgdGhpcy5nZXR0ZXIgPSBlLCB0aGlzLnNldHRlciA9IHZvaWQgMDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcyA9IFd0KGUsIHRoaXMudHdvV2F5KTtcbiAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gcy5nZXQsIHRoaXMuc2V0dGVyID0gcy5zZXRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5ID8gdm9pZCAwIDogdGhpcy5nZXQoKSwgdGhpcy5xdWV1ZWQgPSB0aGlzLnNoYWxsb3cgPSAhMVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHF0KHQpIHtcbiAgICAgICAgdmFyIGUsIGk7XG4gICAgICAgIGlmICgkaSh0KSlcbiAgICAgICAgICAgIGZvciAoZSA9IHQubGVuZ3RoOyBlLS07KSBxdCh0W2VdKTtcbiAgICAgICAgZWxzZSBpZiAobSh0KSlcbiAgICAgICAgICAgIGZvciAoaSA9IE9iamVjdC5rZXlzKHQpLCBlID0gaS5sZW5ndGg7IGUtLTspIHF0KHRbaVtlXV0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSnQodCkge1xuICAgICAgICBpZiAobHJbdF0pIHJldHVybiBsclt0XTtcbiAgICAgICAgdmFyIGUgPSBRdCh0KTtcbiAgICAgICAgcmV0dXJuIGxyW3RdID0gbHJbZV0gPSBlLCBlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUXQodCkge1xuICAgICAgICB0ID0gdSh0KTtcbiAgICAgICAgdmFyIGUgPSBsKHQpLFxuICAgICAgICAgICAgaSA9IGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBlLnNsaWNlKDEpO1xuICAgICAgICBpZiAoY3IgfHwgKGNyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSksIGUgaW4gY3Iuc3R5bGUpIHJldHVybiB0O1xuICAgICAgICBmb3IgKHZhciBuLCByID0gb3IubGVuZ3RoOyByLS07KVxuICAgICAgICAgICAgaWYgKG4gPSBhcltyXSArIGksIG4gaW4gY3Iuc3R5bGUpIHJldHVybiBvcltyXSArIHRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBHdCh0LCBlKSB7XG4gICAgICAgIHZhciBpID0gZS5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICByZXR1cm4gZSA+IDQ3ICYmIDU4ID4gZSA/IHBhcnNlSW50KHQsIDEwKSA6IDEgPT09IHQubGVuZ3RoICYmIChlID0gdC50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCksIGUgPiA2NCAmJiA5MSA+IGUpID8gZSA6IF9yW3RdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIGkuaW5kZXhPZihlLmtleUNvZGUpID4gLTEgPyB0LmNhbGwodGhpcywgZSkgOiB2b2lkIDBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFp0KHQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnN0b3BQcm9wYWdhdGlvbigpLCB0LmNhbGwodGhpcywgZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEt0KHQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCksIHQuY2FsbCh0aGlzLCBlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWHQodCwgZSwgaSkge1xuICAgICAgICBmb3IgKHZhciBuLCByLCBzLCBvID0gZSA/IFtdIDogbnVsbCwgYSA9IDAsIGggPSB0Lm9wdGlvbnMubGVuZ3RoOyBoID4gYTsgYSsrKVxuICAgICAgICAgICAgaWYgKG4gPSB0Lm9wdGlvbnNbYV0sIHMgPSBpID8gbi5oYXNBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKSA6IG4uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAociA9IG4uaGFzT3duUHJvcGVydHkoXCJfdmFsdWVcIikgPyBuLl92YWx1ZSA6IG4udmFsdWUsICFlKSByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICBvLnB1c2gocilcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBZdCh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0Lmxlbmd0aDsgaS0tOylcbiAgICAgICAgICAgIGlmICh3KHRbaV0sIGUpKSByZXR1cm4gaTtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGUodCkge1xuICAgICAgICByZXR1cm4gaXQodCkgJiYgdC5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVlKHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSBPci5nZXQodCk7XG4gICAgICAgIGlmIChpKSByZXR1cm4gaTtcbiAgICAgICAgdmFyIG4gPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgICAgICByID0gdC5tYXRjaChqciksXG4gICAgICAgICAgICBzID0gRXIudGVzdCh0KTtcbiAgICAgICAgaWYgKHIgfHwgcykge1xuICAgICAgICAgICAgdmFyIG8gPSByICYmIHJbMV0sXG4gICAgICAgICAgICAgICAgYSA9IFRyW29dIHx8IFRyLmVmYXVsdCxcbiAgICAgICAgICAgICAgICBoID0gYVswXSxcbiAgICAgICAgICAgICAgICBsID0gYVsxXSxcbiAgICAgICAgICAgICAgICBjID0gYVsyXSxcbiAgICAgICAgICAgICAgICB1ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGZvciAoZSB8fCAodCA9IHQudHJpbSgpKSwgdS5pbm5lckhUTUwgPSBsICsgdCArIGM7IGgtLTspIHUgPSB1Lmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGY7IGYgPSB1LmZpcnN0Q2hpbGQ7KSBuLmFwcGVuZENoaWxkKGYpXG4gICAgICAgIH0gZWxzZSBuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHQpKTtcbiAgICAgICAgcmV0dXJuIE9yLnB1dCh0LCBuKSwgblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGllKHQpIHtcbiAgICAgICAgaWYgKHRlKHQpKSByZXR1cm4gdHQodC5jb250ZW50KSwgdC5jb250ZW50O1xuICAgICAgICBpZiAoXCJTQ1JJUFRcIiA9PT0gdC50YWdOYW1lKSByZXR1cm4gZWUodC50ZXh0Q29udGVudCk7XG4gICAgICAgIGZvciAodmFyIGUsIGkgPSBuZSh0KSwgbiA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTsgZSA9IGkuZmlyc3RDaGlsZDspIG4uYXBwZW5kQ2hpbGQoZSk7XG4gICAgICAgIHJldHVybiB0dChuKSwgblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5lKHQpIHtcbiAgICAgICAgaWYgKCF0LnF1ZXJ5U2VsZWN0b3JBbGwpIHJldHVybiB0LmNsb25lTm9kZSgpO1xuICAgICAgICB2YXIgZSwgaSwgbiwgciA9IHQuY2xvbmVOb2RlKCEwKTtcbiAgICAgICAgaWYgKFNyKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHI7XG4gICAgICAgICAgICBpZiAodGUodCkgJiYgKHQgPSB0LmNvbnRlbnQsIHMgPSByLmNvbnRlbnQpLCBpID0gdC5xdWVyeVNlbGVjdG9yQWxsKFwidGVtcGxhdGVcIiksIGkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobiA9IHMucXVlcnlTZWxlY3RvckFsbChcInRlbXBsYXRlXCIpLCBlID0gbi5sZW5ndGg7IGUtLTspIG5bZV0ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmUoaVtlXSksIG5bZV0pXG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZyKVxuICAgICAgICAgICAgaWYgKFwiVEVYVEFSRUFcIiA9PT0gdC50YWdOYW1lKSByLnZhbHVlID0gdC52YWx1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPSB0LnF1ZXJ5U2VsZWN0b3JBbGwoXCJ0ZXh0YXJlYVwiKSwgaS5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKG4gPSByLnF1ZXJ5U2VsZWN0b3JBbGwoXCJ0ZXh0YXJlYVwiKSwgZSA9IG4ubGVuZ3RoOyBlLS07KSBuW2VdLnZhbHVlID0gaVtlXS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHJcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZSh0LCBlLCBpKSB7XG4gICAgICAgIHZhciBuLCByO1xuICAgICAgICByZXR1cm4gdCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQgPyAodHQodCksIGUgPyBuZSh0KSA6IHQpIDogKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgPyBpIHx8IFwiI1wiICE9PSB0LmNoYXJBdCgwKSA/IHIgPSBlZSh0LCBpKSA6IChyID0gTnIuZ2V0KHQpLCByIHx8IChuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodC5zbGljZSgxKSksIG4gJiYgKHIgPSBpZShuKSwgTnIucHV0KHQsIHIpKSkpIDogdC5ub2RlVHlwZSAmJiAociA9IGllKHQpKSwgciAmJiBlID8gbmUocikgOiByKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlKHQsIGUsIGksIG4sIHIsIHMpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdLCB0aGlzLmNoaWxkRnJhZ3MgPSBbXSwgdGhpcy52bSA9IGUsIHRoaXMuc2NvcGUgPSByLCB0aGlzLmluc2VydGVkID0gITEsIHRoaXMucGFyZW50RnJhZyA9IHMsIHMgJiYgcy5jaGlsZEZyYWdzLnB1c2godGhpcyksIHRoaXMudW5saW5rID0gdChlLCBpLCBuLCByLCB0aGlzKTtcbiAgICAgICAgdmFyIG8gPSB0aGlzLnNpbmdsZSA9IDEgPT09IGkuY2hpbGROb2Rlcy5sZW5ndGggJiYgIWkuY2hpbGROb2Rlc1swXS5fX3Z1ZV9hbmNob3I7XG4gICAgICAgIG8gPyAodGhpcy5ub2RlID0gaS5jaGlsZE5vZGVzWzBdLCB0aGlzLmJlZm9yZSA9IG9lLCB0aGlzLnJlbW92ZSA9IGFlKSA6ICh0aGlzLm5vZGUgPSBudChcImZyYWdtZW50LXN0YXJ0XCIpLCB0aGlzLmVuZCA9IG50KFwiZnJhZ21lbnQtZW5kXCIpLCB0aGlzLmZyYWcgPSBpLCBxKHRoaXMubm9kZSwgaSksIGkuYXBwZW5kQ2hpbGQodGhpcy5lbmQpLCB0aGlzLmJlZm9yZSA9IGhlLCB0aGlzLnJlbW92ZSA9IGxlKSwgdGhpcy5ub2RlLl9fdmZyYWdfXyA9IHRoaXNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZSh0LCBlKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0ZWQgPSAhMDtcbiAgICAgICAgdmFyIGkgPSBlICE9PSAhMSA/IFAgOiB6O1xuICAgICAgICBpKHRoaXMubm9kZSwgdCwgdGhpcy52bSksIFcodGhpcy5ub2RlKSAmJiB0aGlzLmNhbGxIb29rKGNlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFlKCkge1xuICAgICAgICB0aGlzLmluc2VydGVkID0gITE7XG4gICAgICAgIHZhciB0ID0gVyh0aGlzLm5vZGUpLFxuICAgICAgICAgICAgZSA9IHRoaXM7XG4gICAgICAgIGUuY2FsbEhvb2sodWUpLCBSKHRoaXMubm9kZSwgdGhpcy52bSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0ICYmIGUuY2FsbEhvb2soZmUpLCBlLmRlc3Ryb3koKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhlKHQsIGUpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRlZCA9ICEwO1xuICAgICAgICB2YXIgaSA9IHRoaXMudm0sXG4gICAgICAgICAgICBuID0gZSAhPT0gITEgPyBQIDogejtcbiAgICAgICAgc3QodGhpcy5ub2RlLCB0aGlzLmVuZCwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbihlLCB0LCBpKVxuICAgICAgICB9KSwgVyh0aGlzLm5vZGUpICYmIHRoaXMuY2FsbEhvb2soY2UpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGUoKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0ZWQgPSAhMTtcbiAgICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICAgICAgZSA9IFcodGhpcy5ub2RlKTtcbiAgICAgICAgdC5jYWxsSG9vayh1ZSksIG90KHRoaXMubm9kZSwgdGhpcy5lbmQsIHRoaXMudm0sIHRoaXMuZnJhZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBlICYmIHQuY2FsbEhvb2soZmUpLCB0LmRlc3Ryb3koKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNlKHQpIHtcbiAgICAgICAgdC5faXNBdHRhY2hlZCB8fCB0Ll9jYWxsSG9vayhcImF0dGFjaGVkXCIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdWUodCkge1xuICAgICAgICB0LiRkZXN0cm95KCExLCAhMClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmZSh0KSB7XG4gICAgICAgIHQuX2lzQXR0YWNoZWQgJiYgdC5fY2FsbEhvb2soXCJkZXRhY2hlZFwiKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlKHQsIGUpIHtcbiAgICAgICAgdGhpcy52bSA9IHQ7XG4gICAgICAgIHZhciBpLCBuID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZTtcbiAgICAgICAgbiB8fCBpdChlKSA/IGkgPSByZShlLCAhMCkgOiAoaSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgaS5hcHBlbmRDaGlsZChlKSksIHRoaXMudGVtcGxhdGUgPSBpO1xuICAgICAgICB2YXIgciwgcyA9IHQuY29uc3RydWN0b3IuY2lkO1xuICAgICAgICBpZiAocyA+IDApIHtcbiAgICAgICAgICAgIHZhciBvID0gcyArIChuID8gZSA6IGUub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIHIgPSBQci5nZXQobyksIHIgfHwgKHIgPSBBZShpLCB0LiRvcHRpb25zLCAhMCksIFByLnB1dChvLCByKSlcbiAgICAgICAgfSBlbHNlIHIgPSBBZShpLCB0LiRvcHRpb25zLCAhMCk7XG4gICAgICAgIHRoaXMubGlua2VyID0gclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlKHQsIGUsIGkpIHtcbiAgICAgICAgdmFyIG4gPSB0Lm5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgZm9yICh0ID0gbi5fX3ZmcmFnX187ICEodCAmJiB0LmZvcklkID09PSBpICYmIHQuaW5zZXJ0ZWQgfHwgbiA9PT0gZSk7KSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gPSBuLnByZXZpb3VzU2libGluZywgIW4pIHJldHVybjtcbiAgICAgICAgICAgICAgICB0ID0gbi5fX3ZmcmFnX19cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2ZSh0KSB7XG4gICAgICAgIHZhciBlID0gdC5ub2RlO1xuICAgICAgICBpZiAodC5lbmQpXG4gICAgICAgICAgICBmb3IgKDsgIWUuX192dWVfXyAmJiBlICE9PSB0LmVuZCAmJiBlLm5leHRTaWJsaW5nOykgZSA9IGUubmV4dFNpYmxpbmc7XG4gICAgICAgIHJldHVybiBlLl9fdnVlX19cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZSh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAtMSwgaSA9IG5ldyBBcnJheSh0KTsgKytlIDwgdDspIGlbZV0gPSBlO1xuICAgICAgICByZXR1cm4gaVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlKHQpIHtcbiAgICAgICAgTXIucHVzaCh0KSwgenIgfHwgKHpyID0gITAsIERpKF9lKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZSgpIHtcbiAgICAgICAgZm9yICh2YXIgdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQsIGUgPSAwOyBlIDwgTXIubGVuZ3RoOyBlKyspIE1yW2VdKCk7XG4gICAgICAgIHJldHVybiBNciA9IFtdLCB6ciA9ICExLCB0XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmUodCwgZSwgaSwgbikge1xuICAgICAgICB0aGlzLmlkID0gZSwgdGhpcy5lbCA9IHQsIHRoaXMuZW50ZXJDbGFzcyA9IGUgKyBcIi1lbnRlclwiLCB0aGlzLmxlYXZlQ2xhc3MgPSBlICsgXCItbGVhdmVcIiwgdGhpcy5ob29rcyA9IGksIHRoaXMudm0gPSBuLCB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gdGhpcy5vcCA9IHRoaXMuY2IgPSBudWxsLCB0aGlzLmp1c3RFbnRlcmVkID0gITEsIHRoaXMuZW50ZXJlZCA9IHRoaXMubGVmdCA9ICExLCB0aGlzLnR5cGVDYWNoZSA9IHt9O1xuICAgICAgICB2YXIgciA9IHRoaXM7XG4gICAgICAgIFtcImVudGVyTmV4dFRpY2tcIiwgXCJlbnRlckRvbmVcIiwgXCJsZWF2ZU5leHRUaWNrXCIsIFwibGVhdmVEb25lXCJdLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgclt0XSA9IHAoclt0XSwgcilcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB5ZSh0KSB7XG4gICAgICAgIHJldHVybiAhKHQub2Zmc2V0V2lkdGggfHwgdC5vZmZzZXRIZWlnaHQgfHwgdC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDZSh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSB7fSwgaSA9IHQudHJpbSgpLnNwbGl0KC9cXHMrLyksIG4gPSBpLmxlbmd0aDsgbi0tOykgZVtpW25dXSA9ICEwO1xuICAgICAgICByZXR1cm4gZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuICRpKHQpID8gdC5pbmRleE9mKGUpID4gLTEgOiBpKHQsIGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGUodCwgZSkge1xuICAgICAgICBmb3IgKHZhciBpLCByLCBzLCBvLCBhLCBoLCBjLCBmID0gW10sIHAgPSBPYmplY3Qua2V5cyhlKSwgZCA9IHAubGVuZ3RoOyBkLS07KSByID0gcFtkXSwgaSA9IGVbcl0gfHwgaXMsIGEgPSBsKHIpLCBucy50ZXN0KGEpICYmIChjID0ge1xuICAgICAgICAgICAgbmFtZTogcixcbiAgICAgICAgICAgIHBhdGg6IGEsXG4gICAgICAgICAgICBvcHRpb25zOiBpLFxuICAgICAgICAgICAgbW9kZTogZXMuT05FX1dBWSxcbiAgICAgICAgICAgIHJhdzogbnVsbFxuICAgICAgICB9LCBzID0gdShyKSwgbnVsbCA9PT0gKG8gPSBWKHQsIHMpKSAmJiAobnVsbCAhPT0gKG8gPSBWKHQsIHMgKyBcIi5zeW5jXCIpKSA/IGMubW9kZSA9IGVzLlRXT19XQVkgOiBudWxsICE9PSAobyA9IFYodCwgcyArIFwiLm9uY2VcIikpICYmIChjLm1vZGUgPSBlcy5PTkVfVElNRSkpLCBudWxsICE9PSBvID8gKGMucmF3ID0gbywgaCA9IEEobyksIG8gPSBoLmV4cHJlc3Npb24sIGMuZmlsdGVycyA9IGguZmlsdGVycywgbihvKSA/IGMub3B0aW1pemVkTGl0ZXJhbCA9ICEwIDogYy5keW5hbWljID0gITAsIGMucGFyZW50UGF0aCA9IG8pIDogbnVsbCAhPT0gKG8gPSBCKHQsIHMpKSA/IGMucmF3ID0gbyA6IGkucmVxdWlyZWQsIGYucHVzaChjKSk7XG4gICAgICAgIHJldHVybiBrZShmKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtlKHQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUsIGkpIHtcbiAgICAgICAgICAgIGUuX3Byb3BzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBuLCByLCBzLCBsLCBjLCB1ID0gdC5sZW5ndGg7IHUtLTspXG4gICAgICAgICAgICAgICAgaWYgKG4gPSB0W3VdLCBjID0gbi5yYXcsIHIgPSBuLnBhdGgsIHMgPSBuLm9wdGlvbnMsIGUuX3Byb3BzW3JdID0gbiwgbnVsbCA9PT0gYykgbHQoZSwgbiwgeGUoZSwgcykpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG4uZHluYW1pYykgZS5fY29udGV4dCAmJiAobi5tb2RlID09PSBlcy5PTkVfVElNRSA/IChsID0gKGkgfHwgZS5fY29udGV4dCkuJGdldChuLnBhcmVudFBhdGgpLCBsdChlLCBuLCBsKSkgOiBlLl9iaW5kRGlyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInByb3BcIixcbiAgICAgICAgICAgICAgICBkZWY6IEtyLFxuICAgICAgICAgICAgICAgIHByb3A6IG5cbiAgICAgICAgICAgIH0sIG51bGwsIG51bGwsIGkpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG4ub3B0aW1pemVkTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gaChjKTtcbiAgICAgICAgICAgICAgICBsID0gZiA9PT0gYyA/IGEobyhjKSkgOiBmLCBsdChlLCBuLCBsKVxuICAgICAgICAgICAgfSBlbHNlIGwgPSBzLnR5cGUgPT09IEJvb2xlYW4gJiYgXCJcIiA9PT0gYyA/ICEwIDogYywgbHQoZSwgbiwgbClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHhlKHQsIGUpIHtcbiAgICAgICAgaWYgKCFpKGUsIFwiZGVmYXVsdFwiKSkgcmV0dXJuIGUudHlwZSA9PT0gQm9vbGVhbiA/ICExIDogdm9pZCAwO1xuICAgICAgICB2YXIgbiA9IGVbXCJkZWZhdWx0XCJdO1xuICAgICAgICByZXR1cm4gbShuKSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBuICYmIGUudHlwZSAhPT0gRnVuY3Rpb24gPyBuLmNhbGwodCkgOiBuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQWUodCwgZSwgaSkge1xuICAgICAgICB2YXIgbiA9IGkgfHwgIWUuX2FzQ29tcG9uZW50ID8gRmUodCwgZSkgOiBudWxsLFxuICAgICAgICAgICAgciA9IG4gJiYgbi50ZXJtaW5hbCB8fCBcIlNDUklQVFwiID09PSB0LnRhZ05hbWUgfHwgIXQuaGFzQ2hpbGROb2RlcygpID8gbnVsbCA6IFdlKHQuY2hpbGROb2RlcywgZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0LCBlLCBpLCBzLCBvKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGQoZS5jaGlsZE5vZGVzKSxcbiAgICAgICAgICAgICAgICBoID0gT2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG4gJiYgbih0LCBlLCBpLCBzLCBvKSwgciAmJiByKHQsIGEsIGksIHMsIG8pXG4gICAgICAgICAgICAgICAgfSwgdCk7XG4gICAgICAgICAgICByZXR1cm4gVGUodCwgaClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIE9lKHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSBlLl9kaXJlY3RpdmVzLmxlbmd0aDtcbiAgICAgICAgdCgpO1xuICAgICAgICB2YXIgbiA9IGUuX2RpcmVjdGl2ZXMuc2xpY2UoaSk7XG4gICAgICAgIG4uc29ydChOZSk7XG4gICAgICAgIGZvciAodmFyIHIgPSAwLCBzID0gbi5sZW5ndGg7IHMgPiByOyByKyspIG5bcl0uX2JpbmQoKTtcbiAgICAgICAgcmV0dXJuIG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBOZSh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0ID0gdC5kZXNjcmlwdG9yLmRlZi5wcmlvcml0eSB8fCBjcywgZSA9IGUuZGVzY3JpcHRvci5kZWYucHJpb3JpdHkgfHwgY3MsIHQgPiBlID8gLTEgOiB0ID09PSBlID8gMCA6IDFcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBUZSh0LCBlLCBpLCBuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICBqZSh0LCBlLCByKSwgaSAmJiBuICYmIGplKGksIG4pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqZSh0LCBlLCBpKSB7XG4gICAgICAgIGZvciAodmFyIG4gPSBlLmxlbmd0aDsgbi0tOykgZVtuXS5fdGVhcmRvd24oKSwgaSB8fCB0Ll9kaXJlY3RpdmVzLiRyZW1vdmUoZVtuXSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBFZSh0LCBlLCBpLCBuKSB7XG4gICAgICAgIHZhciByID0gJGUoZSwgaSksXG4gICAgICAgICAgICBzID0gT2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcih0LCBuKVxuICAgICAgICAgICAgfSwgdCk7XG4gICAgICAgIHJldHVybiBUZSh0LCBzKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFNlKHQsIGUsIGkpIHtcbiAgICAgICAgdmFyIG4sIHIsIHMgPSBlLl9jb250YWluZXJBdHRycyxcbiAgICAgICAgICAgIG8gPSBlLl9yZXBsYWNlckF0dHJzO1xuICAgICAgICByZXR1cm4gMTEgIT09IHQubm9kZVR5cGUgJiYgKGUuX2FzQ29tcG9uZW50ID8gKHMgJiYgaSAmJiAobiA9IHFlKHMsIGkpKSwgbyAmJiAociA9IHFlKG8sIGUpKSkgOiByID0gcWUodC5hdHRyaWJ1dGVzLCBlKSksXG4gICAgICAgICAgICBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMsIG8gPSB0Ll9jb250ZXh0O1xuICAgICAgICAgICAgICAgIG8gJiYgbiAmJiAocyA9IE9lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBuKG8sIGUsIG51bGwsIGkpXG4gICAgICAgICAgICAgICAgfSwgbykpO1xuICAgICAgICAgICAgICAgIHZhciBhID0gT2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgJiYgcih0LCBlKVxuICAgICAgICAgICAgICAgIH0sIHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBUZSh0LCBhLCBvLCBzKVxuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEZlKHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSB0Lm5vZGVUeXBlO1xuICAgICAgICByZXR1cm4gMSA9PT0gaSAmJiBcIlNDUklQVFwiICE9PSB0LnRhZ05hbWUgPyBEZSh0LCBlKSA6IDMgPT09IGkgJiYgdC5kYXRhLnRyaW0oKSA/IFBlKHQsIGUpIDogbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIERlKHQsIGUpIHtcbiAgICAgICAgaWYgKFwiVEVYVEFSRUFcIiA9PT0gdC50YWdOYW1lKSB7XG4gICAgICAgICAgICB2YXIgaSA9IFQodC52YWx1ZSk7XG4gICAgICAgICAgICBpICYmICh0LnNldEF0dHJpYnV0ZShcIjp2YWx1ZVwiLCBqKGkpKSwgdC52YWx1ZSA9IFwiXCIpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4sIHIgPSB0Lmhhc0F0dHJpYnV0ZXMoKTtcbiAgICAgICAgcmV0dXJuIHIgJiYgKG4gPSB6ZSh0LCBlKSksIG4gfHwgKG4gPSBWZSh0LCBlKSksIG4gfHwgKG4gPSBNZSh0LCBlKSksICFuICYmIHIgJiYgKG4gPSBxZSh0LmF0dHJpYnV0ZXMsIGUpKSwgblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBlKHQsIGUpIHtcbiAgICAgICAgaWYgKHQuX3NraXApIHJldHVybiBSZTtcbiAgICAgICAgdmFyIGkgPSBUKHQud2hvbGVUZXh0KTtcbiAgICAgICAgaWYgKCFpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgbiA9IHQubmV4dFNpYmxpbmc7IG4gJiYgMyA9PT0gbi5ub2RlVHlwZTspIG4uX3NraXAgPSAhMCwgbiA9IG4ubmV4dFNpYmxpbmc7XG4gICAgICAgIGZvciAodmFyIHIsIHMsIG8gPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIGEgPSAwLCBoID0gaS5sZW5ndGg7IGggPiBhOyBhKyspIHMgPSBpW2FdLCByID0gcy50YWcgPyBIZShzLCBlKSA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHMudmFsdWUpLCBvLmFwcGVuZENoaWxkKHIpO1xuICAgICAgICByZXR1cm4gTGUoaSwgbywgZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSZSh0LCBlKSB7XG4gICAgICAgIFUoZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBIZSh0LCBlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGkoZSkge1xuICAgICAgICAgICAgaWYgKCF0LmRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IEEodC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdC5kZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBlLFxuICAgICAgICAgICAgICAgICAgICBkZWY6IFZyW2VdLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBpLmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcnM6IGkuZmlsdGVyc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbjtcbiAgICAgICAgcmV0dXJuIHQub25lVGltZSA/IG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0LnZhbHVlKSA6IHQuaHRtbCA/IChuID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcInYtaHRtbFwiKSwgaShcImh0bWxcIikpIDogKG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIiBcIiksIGkoXCJ0ZXh0XCIpKSwgblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIExlKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIG4sIHIsIHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG8sIGEsIGgsIGwgPSBlLmNsb25lTm9kZSghMCksIGMgPSBkKGwuY2hpbGROb2RlcyksIHUgPSAwLCBmID0gdC5sZW5ndGg7IGYgPiB1OyB1KyspIG8gPSB0W3VdLCBhID0gby52YWx1ZSwgby50YWcgJiYgKGggPSBjW3VdLCBvLm9uZVRpbWUgPyAoYSA9IChzIHx8IGkpLiRldmFsKGEpLCBvLmh0bWwgPyBKKGgsIHJlKGEsICEwKSkgOiBoLmRhdGEgPSBhKSA6IGkuX2JpbmREaXIoby5kZXNjcmlwdG9yLCBoLCByLCBzKSk7XG4gICAgICAgICAgICBKKG4sIGwpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXZSh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIGksIG4sIHIsIHMgPSBbXSwgbyA9IDAsIGEgPSB0Lmxlbmd0aDsgYSA+IG87IG8rKykgciA9IHRbb10sIGkgPSBGZShyLCBlKSwgbiA9IGkgJiYgaS50ZXJtaW5hbCB8fCBcIlNDUklQVFwiID09PSByLnRhZ05hbWUgfHwgIXIuaGFzQ2hpbGROb2RlcygpID8gbnVsbCA6IFdlKHIuY2hpbGROb2RlcywgZSksIHMucHVzaChpLCBuKTtcbiAgICAgICAgcmV0dXJuIHMubGVuZ3RoID8gQmUocykgOiBudWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQmUodCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSwgaSwgbiwgciwgcykge1xuICAgICAgICAgICAgZm9yICh2YXIgbywgYSwgaCwgbCA9IDAsIGMgPSAwLCB1ID0gdC5sZW5ndGg7IHUgPiBsOyBjKyspIHtcbiAgICAgICAgICAgICAgICBvID0gaVtjXSwgYSA9IHRbbCsrXSwgaCA9IHRbbCsrXTtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGQoby5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICBhICYmIGEoZSwgbywgbiwgciwgcyksIGggJiYgaChlLCBmLCBuLCByLCBzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVmUodCwgZSkge1xuICAgICAgICB2YXIgaSA9IHQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIWNuLnRlc3QoaSkpIHtcbiAgICAgICAgICAgIFwic2xvdFwiID09PSBpICYmIE0odCwgXCJuYW1lXCIpICYmIChpID0gXCJfbmFtZWRTbG90XCIpO1xuICAgICAgICAgICAgdmFyIG4gPSBfdChlLCBcImVsZW1lbnREaXJlY3RpdmVzXCIsIGkpO1xuICAgICAgICAgICAgcmV0dXJuIG4gPyBVZSh0LCBpLCBcIlwiLCBlLCBuKSA6IHZvaWQgMFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTWUodCwgZSkge1xuICAgICAgICB2YXIgaSA9IGF0KHQsIGUpO1xuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgdmFyIG4gPSBydCh0KSxcbiAgICAgICAgICAgICAgICByID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICAgICAgICByZWY6IG4sXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGkuaWQsXG4gICAgICAgICAgICAgICAgICAgIGRlZjogdHMuY29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpdGVyYWw6ICFpLmR5bmFtaWNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcyA9IGZ1bmN0aW9uKHQsIGUsIGksIHMsIG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbiAmJiB4dCgocyB8fCB0KS4kcmVmcywgbiwgbnVsbCksIHQuX2JpbmREaXIociwgZSwgaSwgcywgbylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHMudGVybWluYWwgPSAhMCwgc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemUodCwgZSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gQih0LCBcInYtcHJlXCIpKSByZXR1cm4gSWU7XG4gICAgICAgIGlmICh0Lmhhc0F0dHJpYnV0ZShcInYtZWxzZVwiKSkge1xuICAgICAgICAgICAgdmFyIGkgPSB0LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoaSAmJiBpLmhhc0F0dHJpYnV0ZShcInYtaWZcIikpIHJldHVybiBJZVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIG4sIHIsIHMgPSAwLCBvID0gbHMubGVuZ3RoOyBvID4gczsgcysrKVxuICAgICAgICAgICAgaWYgKHIgPSBsc1tzXSwgbiA9IHQuZ2V0QXR0cmlidXRlKFwidi1cIiArIHIpKSByZXR1cm4gVWUodCwgciwgbiwgZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJZSgpIHt9XG5cbiAgICBmdW5jdGlvbiBVZSh0LCBlLCBpLCBuLCByKSB7XG4gICAgICAgIHZhciBzID0gQShpKSxcbiAgICAgICAgICAgIG8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgZmlsdGVyczogcy5maWx0ZXJzLFxuICAgICAgICAgICAgICAgIHJhdzogaSxcbiAgICAgICAgICAgICAgICBkZWY6IHIgfHwgVnJbZV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIChcImZvclwiID09PSBlIHx8IFwicm91dGVyLXZpZXdcIiA9PT0gZSkgJiYgKG8ucmVmID0gcnQodCkpO1xuICAgICAgICB2YXIgYSA9IGZ1bmN0aW9uKHQsIGUsIGksIG4sIHIpIHtcbiAgICAgICAgICAgIG8ucmVmICYmIHh0KChuIHx8IHQpLiRyZWZzLCBvLnJlZiwgbnVsbCksIHQuX2JpbmREaXIobywgZSwgaSwgbiwgcilcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGEudGVybWluYWwgPSAhMCwgYVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHFlKHQsIGUpIHtcbiAgICAgICAgZnVuY3Rpb24gaSh0LCBlLCBpKSB7XG4gICAgICAgICAgICB2YXIgbiA9IEEocyk7XG4gICAgICAgICAgICBkLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IHQsXG4gICAgICAgICAgICAgICAgYXR0cjogbyxcbiAgICAgICAgICAgICAgICByYXc6IGEsXG4gICAgICAgICAgICAgICAgZGVmOiBlLFxuICAgICAgICAgICAgICAgIGFyZzogbCxcbiAgICAgICAgICAgICAgICBtb2RpZmllcnM6IGMsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbi5leHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGZpbHRlcnM6IG4uZmlsdGVycyxcbiAgICAgICAgICAgICAgICBpbnRlcnA6IGlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgbiwgciwgcywgbywgYSwgaCwgbCwgYywgdSwgZiwgcCA9IHQubGVuZ3RoLCBkID0gW107IHAtLTspXG4gICAgICAgICAgICBpZiAobiA9IHRbcF0sIHIgPSBvID0gbi5uYW1lLCBzID0gYSA9IG4udmFsdWUsIGYgPSBUKHMpLCBsID0gbnVsbCwgYyA9IEplKHIpLCByID0gci5yZXBsYWNlKGFzLCBcIlwiKSwgZikgcyA9IGooZiksIFwiY2xhc3NcIiA9PT0gciA/IGkoXCJjbGFzc1wiLCB0c1tcImNsYXNzXCJdLCAhMCkgOiAobCA9IHIsIGkoXCJiaW5kXCIsIFZyLmJpbmQsICEwKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChocy50ZXN0KHIpKSBjLmxpdGVyYWwgPSAhcnMudGVzdChyKSwgaShcInRyYW5zaXRpb25cIiwgdHMudHJhbnNpdGlvbik7XG4gICAgICAgIGVsc2UgaWYgKHNzLnRlc3QocikpIGwgPSByLnJlcGxhY2Uoc3MsIFwiXCIpLCBpKFwib25cIiwgVnIub24pO1xuICAgICAgICBlbHNlIGlmIChycy50ZXN0KHIpKSBoID0gci5yZXBsYWNlKHJzLCBcIlwiKSwgXCJzdHlsZVwiID09PSBoIHx8IFwiY2xhc3NcIiA9PT0gaCA/IGkoaCwgdHNbaF0pIDogKGwgPSBoLCBpKFwiYmluZFwiLCBWci5iaW5kKSk7XG4gICAgICAgIGVsc2UgaWYgKDAgPT09IHIuaW5kZXhPZihcInYtXCIpKSB7XG4gICAgICAgICAgICBpZiAobCA9IChsID0gci5tYXRjaChvcykpICYmIGxbMV0sIGwgJiYgKHIgPSByLnJlcGxhY2Uob3MsIFwiXCIpKSwgaCA9IHIuc2xpY2UoMiksIFwiZWxzZVwiID09PSBoKSBjb250aW51ZTtcbiAgICAgICAgICAgIHUgPSBfdChlLCBcImRpcmVjdGl2ZXNcIiwgaCksIHUgJiYgaShoLCB1KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkLmxlbmd0aCA/IFFlKGQpIDogdm9pZCAwXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSmUodCkge1xuICAgICAgICB2YXIgZSA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBpID0gdC5tYXRjaChhcyk7XG4gICAgICAgIGlmIChpKVxuICAgICAgICAgICAgZm9yICh2YXIgbiA9IGkubGVuZ3RoOyBuLS07KSBlW2lbbl0uc2xpY2UoMSldID0gITA7XG4gICAgICAgIHJldHVybiBlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUWUodCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSwgaSwgbiwgciwgcykge1xuICAgICAgICAgICAgZm9yICh2YXIgbyA9IHQubGVuZ3RoOyBvLS07KSBlLl9iaW5kRGlyKHRbb10sIGksIG4sIHIsIHMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBHZSh0LCBlKSB7XG4gICAgICAgIHJldHVybiBlICYmIChlLl9jb250YWluZXJBdHRycyA9IEtlKHQpKSwgaXQodCkgJiYgKHQgPSByZSh0KSksIGUgJiYgKGUuX2FzQ29tcG9uZW50ICYmICFlLnRlbXBsYXRlICYmIChlLnRlbXBsYXRlID0gXCI8c2xvdD48L3Nsb3Q+XCIpLCBlLnRlbXBsYXRlICYmIChlLl9jb250ZW50ID0gWSh0KSwgdCA9IFplKHQsIGUpKSksIHQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50ICYmIChxKG50KFwidi1zdGFydFwiLCAhMCksIHQpLCB0LmFwcGVuZENoaWxkKG50KFwidi1lbmRcIiwgITApKSksIHRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBaZSh0LCBlKSB7XG4gICAgICAgIHZhciBpID0gZS50ZW1wbGF0ZSxcbiAgICAgICAgICAgIG4gPSByZShpLCAhMCk7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICB2YXIgciA9IG4uZmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBzID0gci50YWdOYW1lICYmIHIudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGUucmVwbGFjZSA/ICh0ID09PSBkb2N1bWVudC5ib2R5LCBuLmNoaWxkTm9kZXMubGVuZ3RoID4gMSB8fCAxICE9PSByLm5vZGVUeXBlIHx8IFwiY29tcG9uZW50XCIgPT09IHMgfHwgX3QoZSwgXCJjb21wb25lbnRzXCIsIHMpIHx8IE0ociwgXCJpc1wiKSB8fCBfdChlLCBcImVsZW1lbnREaXJlY3RpdmVzXCIsIHMpIHx8IHIuaGFzQXR0cmlidXRlKFwidi1mb3JcIikgfHwgci5oYXNBdHRyaWJ1dGUoXCJ2LWlmXCIpID8gbiA6IChlLl9yZXBsYWNlckF0dHJzID0gS2UociksIFhlKHQsIHIpLCByKSkgOiAodC5hcHBlbmRDaGlsZChuKSwgdClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEtlKHQpIHtcbiAgICAgICAgcmV0dXJuIDEgPT09IHQubm9kZVR5cGUgJiYgdC5oYXNBdHRyaWJ1dGVzKCkgPyBkKHQuYXR0cmlidXRlcykgOiB2b2lkIDBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBYZSh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIGksIG4sIHIgPSB0LmF0dHJpYnV0ZXMsIHMgPSByLmxlbmd0aDsgcy0tOykgaSA9IHJbc10ubmFtZSwgbiA9IHJbc10udmFsdWUsIGUuaGFzQXR0cmlidXRlKGkpIHx8IHVzLnRlc3QoaSkgPyBcImNsYXNzXCIgPT09IGkgJiYgbi5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgSyhlLCB0KVxuICAgICAgICB9KSA6IGUuc2V0QXR0cmlidXRlKGksIG4pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWWUoZSkge1xuICAgICAgICBmdW5jdGlvbiBuKCkge31cblxuICAgICAgICBmdW5jdGlvbiBzKHQsIGUpIHtcbiAgICAgICAgICAgIHZhciBpID0gbmV3IFV0KGUsIHQsIG51bGwsIHtcbiAgICAgICAgICAgICAgICBsYXp5OiAhMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkuZGlydHkgJiYgaS5ldmFsdWF0ZSgpLCB5dC50YXJnZXQgJiYgaS5kZXBlbmQoKSwgaS52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSwgXCIkZGF0YVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdCAhPT0gdGhpcy5fZGF0YSAmJiB0aGlzLl9zZXREYXRhKHQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBlLnByb3RvdHlwZS5faW5pdFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0UHJvcHMoKSwgdGhpcy5faW5pdE1ldGEoKSwgdGhpcy5faW5pdE1ldGhvZHMoKSwgdGhpcy5faW5pdERhdGEoKSwgdGhpcy5faW5pdENvbXB1dGVkKClcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuX2luaXRQcm9wcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLiRvcHRpb25zLFxuICAgICAgICAgICAgICAgIGUgPSB0LmVsLFxuICAgICAgICAgICAgICAgIGkgPSB0LnByb3BzO1xuICAgICAgICAgICAgZSA9IHQuZWwgPSBMKGUpLCB0aGlzLl9wcm9wc1VubGlua0ZuID0gZSAmJiAxID09PSBlLm5vZGVUeXBlICYmIGkgPyBFZSh0aGlzLCBlLCBpLCB0aGlzLl9zY29wZSkgOiBudWxsXG4gICAgICAgIH0sIGUucHJvdG90eXBlLl9pbml0RGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLl9kYXRhLFxuICAgICAgICAgICAgICAgIG4gPSB0aGlzLiRvcHRpb25zLmRhdGEsXG4gICAgICAgICAgICAgICAgciA9IG4gJiYgbigpO1xuICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhID0gcjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzIGluIGUpIG51bGwgPT09IHRoaXMuX3Byb3BzW3NdLnJhdyAmJiBpKHIsIHMpIHx8IHQociwgcywgZVtzXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvLCBhLCBoID0gdGhpcy5fZGF0YSxcbiAgICAgICAgICAgICAgICBsID0gT2JqZWN0LmtleXMoaCk7XG4gICAgICAgICAgICBmb3IgKG8gPSBsLmxlbmd0aDsgby0tOykgYSA9IGxbb10sIHRoaXMuX3Byb3h5KGEpO1xuICAgICAgICAgICAga3QoaCwgdGhpcylcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuX3NldERhdGEgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICB0ID0gdCB8fCB7fTtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5fZGF0YTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSB0O1xuICAgICAgICAgICAgdmFyIG4sIHIsIHM7XG4gICAgICAgICAgICBmb3IgKG4gPSBPYmplY3Qua2V5cyhlKSwgcyA9IG4ubGVuZ3RoOyBzLS07KSByID0gbltzXSwgciBpbiB0IHx8IHRoaXMuX3VucHJveHkocik7XG4gICAgICAgICAgICBmb3IgKG4gPSBPYmplY3Qua2V5cyh0KSwgcyA9IG4ubGVuZ3RoOyBzLS07KSByID0gbltzXSwgaSh0aGlzLCByKSB8fCB0aGlzLl9wcm94eShyKTtcbiAgICAgICAgICAgIGUuX19vYl9fLnJlbW92ZVZtKHRoaXMpLCBrdCh0LCB0aGlzKSwgdGhpcy5fZGlnZXN0KClcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuX3Byb3h5ID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgaWYgKCFyKHQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuX2RhdGFbdF1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLl9kYXRhW3RdID0gaVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZS5wcm90b3R5cGUuX3VucHJveHkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByKHQpIHx8IGRlbGV0ZSB0aGlzW3RdXG4gICAgICAgIH0sIGUucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAwLCBlID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoOyBlID4gdDsgdCsrKSB0aGlzLl93YXRjaGVyc1t0XS51cGRhdGUoITApXG4gICAgICAgIH0sIGUucHJvdG90eXBlLl9pbml0Q29tcHV0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy4kb3B0aW9ucy5jb21wdXRlZDtcbiAgICAgICAgICAgIGlmICh0KVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGUgaW4gdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRbZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICByID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaSA/IChyLmdldCA9IHMoaSwgdGhpcyksIHIuc2V0ID0gbikgOiAoci5nZXQgPSBpLmdldCA/IGkuY2FjaGUgIT09ICExID8gcyhpLmdldCwgdGhpcykgOiBwKGkuZ2V0LCB0aGlzKSA6IG4sIHIuc2V0ID0gaS5zZXQgPyBwKGkuc2V0LCB0aGlzKSA6IG4pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgZSwgcilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0sIGUucHJvdG90eXBlLl9pbml0TWV0aG9kcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLiRvcHRpb25zLm1ldGhvZHM7XG4gICAgICAgICAgICBpZiAodClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlIGluIHQpIHRoaXNbZV0gPSBwKHRbZV0sIHRoaXMpXG4gICAgICAgIH0sIGUucHJvdG90eXBlLl9pbml0TWV0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLiRvcHRpb25zLl9tZXRhO1xuICAgICAgICAgICAgaWYgKHQpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZSBpbiB0KSB4dCh0aGlzLCBlLCB0W2VdKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGkodCkge1xuICAgICAgICBmdW5jdGlvbiBlKHQsIGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGksIG4sIHIgPSBlLmF0dHJpYnV0ZXMsIHMgPSAwLCBvID0gci5sZW5ndGg7IG8gPiBzOyBzKyspIGkgPSByW3NdLm5hbWUsIHBzLnRlc3QoaSkgJiYgKGkgPSBpLnJlcGxhY2UocHMsIFwiXCIpLCBuID0gKHQuX3Njb3BlIHx8IHQuX2NvbnRleHQpLiRldmFsKHJbc10udmFsdWUsICEwKSwgdC4kb24oaS5yZXBsYWNlKHBzKSwgbikpXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpKHQsIGUsIGkpIHtcbiAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIsIHMsIG8sIGE7XG4gICAgICAgICAgICAgICAgZm9yIChzIGluIGkpXG4gICAgICAgICAgICAgICAgICAgIGlmIChyID0gaVtzXSwgJGkocikpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG8gPSAwLCBhID0gci5sZW5ndGg7IGEgPiBvOyBvKyspIG4odCwgZSwgcywgcltvXSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugbih0LCBlLCBzLCByKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbih0LCBlLCBpLCByLCBzKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHR5cGVvZiByO1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gbykgdFtlXShpLCByLCBzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IG8pIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHQuJG9wdGlvbnMubWV0aG9kcyxcbiAgICAgICAgICAgICAgICAgICAgaCA9IGEgJiYgYVtyXTtcbiAgICAgICAgICAgICAgICBoICYmIHRbZV0oaSwgaCwgcylcbiAgICAgICAgICAgIH0gZWxzZSByICYmIFwib2JqZWN0XCIgPT09IG8gJiYgbih0LCBlLCBpLCByLmhhbmRsZXIsIHIpXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByKCkge1xuICAgICAgICAgICAgdGhpcy5faXNBdHRhY2hlZCB8fCAodGhpcy5faXNBdHRhY2hlZCA9ICEwLCB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKHMpKVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcyh0KSB7XG4gICAgICAgICAgICAhdC5faXNBdHRhY2hlZCAmJiBXKHQuJGVsKSAmJiB0Ll9jYWxsSG9vayhcImF0dGFjaGVkXCIpXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgICAgICAgdGhpcy5faXNBdHRhY2hlZCAmJiAodGhpcy5faXNBdHRhY2hlZCA9ICExLCB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGEpKVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYSh0KSB7XG4gICAgICAgICAgICB0Ll9pc0F0dGFjaGVkICYmICFXKHQuJGVsKSAmJiB0Ll9jYWxsSG9vayhcImRldGFjaGVkXCIpXG4gICAgICAgIH1cbiAgICAgICAgdC5wcm90b3R5cGUuX2luaXRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy4kb3B0aW9ucztcbiAgICAgICAgICAgIHQuX2FzQ29tcG9uZW50ICYmIGUodGhpcywgdC5lbCksIGkodGhpcywgXCIkb25cIiwgdC5ldmVudHMpLCBpKHRoaXMsIFwiJHdhdGNoXCIsIHQud2F0Y2gpXG4gICAgICAgIH0sIHQucHJvdG90eXBlLl9pbml0RE9NSG9va3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJG9uKFwiaG9vazphdHRhY2hlZFwiLCByKSwgdGhpcy4kb24oXCJob29rOmRldGFjaGVkXCIsIG8pXG4gICAgICAgIH0sIHQucHJvdG90eXBlLl9jYWxsSG9vayA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy4kb3B0aW9uc1t0XTtcbiAgICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gZS5sZW5ndGg7IG4gPiBpOyBpKyspIGVbaV0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoXCJob29rOlwiICsgdClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVpKCkge31cblxuICAgIGZ1bmN0aW9uIGlpKHQsIGUsIGksIG4sIHIsIHMpIHtcbiAgICAgICAgdGhpcy52bSA9IGUsIHRoaXMuZWwgPSBpLCB0aGlzLmRlc2NyaXB0b3IgPSB0LCB0aGlzLm5hbWUgPSB0Lm5hbWUsIHRoaXMuZXhwcmVzc2lvbiA9IHQuZXhwcmVzc2lvbiwgdGhpcy5hcmcgPSB0LmFyZywgdGhpcy5tb2RpZmllcnMgPSB0Lm1vZGlmaWVycywgdGhpcy5maWx0ZXJzID0gdC5maWx0ZXJzLCB0aGlzLmxpdGVyYWwgPSB0aGlzLm1vZGlmaWVycyAmJiB0aGlzLm1vZGlmaWVycy5saXRlcmFsLCB0aGlzLl9sb2NrZWQgPSAhMSwgdGhpcy5fYm91bmQgPSAhMSwgdGhpcy5fbGlzdGVuZXJzID0gbnVsbCwgdGhpcy5faG9zdCA9IG4sIHRoaXMuX3Njb3BlID0gciwgdGhpcy5fZnJhZyA9IHNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuaSh0KSB7XG4gICAgICAgIHQucHJvdG90eXBlLl91cGRhdGVSZWYgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuJG9wdGlvbnMuX3JlZjtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy5fY29udGV4dCkuJHJlZnM7XG4gICAgICAgICAgICAgICAgdCA/IGlbZV0gPT09IHRoaXMgJiYgKGlbZV0gPSBudWxsKSA6IGlbZV0gPSB0aGlzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHQucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLiRvcHRpb25zLFxuICAgICAgICAgICAgICAgIGkgPSB0O1xuICAgICAgICAgICAgaWYgKHQgPSBHZSh0LCBlKSwgdGhpcy5faW5pdEVsZW1lbnQodCksIDEgIT09IHQubm9kZVR5cGUgfHwgbnVsbCA9PT0gQih0LCBcInYtcHJlXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4sIHIgPSB0aGlzLl9jb250ZXh0ICYmIHRoaXMuX2NvbnRleHQuJG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHMgPSBTZSh0LCBlLCByKSxcbiAgICAgICAgICAgICAgICAgICAgbyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgZS5fbGlua2VyQ2FjaGFibGUgJiYgKG4gPSBvLmxpbmtlciwgbiB8fCAobiA9IG8ubGlua2VyID0gQWUodCwgZSkpKTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHModGhpcywgdCwgdGhpcy5fc2NvcGUpLFxuICAgICAgICAgICAgICAgICAgICBoID0gbiA/IG4odGhpcywgdCkgOiBBZSh0LCBlKSh0aGlzLCB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5saW5rRm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYSgpLCBoKCEwKVxuICAgICAgICAgICAgICAgIH0sIGUucmVwbGFjZSAmJiBKKGksIHQpLCB0aGlzLl9pc0NvbXBpbGVkID0gITAsIHRoaXMuX2NhbGxIb29rKFwiY29tcGlsZWRcIiksIHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdC5wcm90b3R5cGUuX2luaXRFbGVtZW50ID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgdCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQgPyAodGhpcy5faXNGcmFnbWVudCA9ICEwLCB0aGlzLiRlbCA9IHRoaXMuX2ZyYWdtZW50U3RhcnQgPSB0LmZpcnN0Q2hpbGQsIHRoaXMuX2ZyYWdtZW50RW5kID0gdC5sYXN0Q2hpbGQsIDMgPT09IHRoaXMuX2ZyYWdtZW50U3RhcnQubm9kZVR5cGUgJiYgKHRoaXMuX2ZyYWdtZW50U3RhcnQuZGF0YSA9IHRoaXMuX2ZyYWdtZW50RW5kLmRhdGEgPSBcIlwiKSwgdGhpcy5fZnJhZ21lbnQgPSB0KSA6IHRoaXMuJGVsID0gdCwgdGhpcy4kZWwuX192dWVfXyA9IHRoaXMsIHRoaXMuX2NhbGxIb29rKFwiYmVmb3JlQ29tcGlsZVwiKVxuICAgICAgICB9LCB0LnByb3RvdHlwZS5fYmluZERpciA9IGZ1bmN0aW9uKHQsIGUsIGksIG4sIHIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZXMucHVzaChuZXcgaWkodCwgdGhpcywgZSwgaSwgbiwgcikpXG4gICAgICAgIH0sIHQucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQpIHJldHVybiB2b2lkKGUgfHwgdGhpcy5fY2xlYW51cCgpKTtcbiAgICAgICAgICAgIHZhciBpLCBuLCByID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICFpIHx8IG4gfHwgZSB8fCByLl9jbGVhbnVwKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgdCAmJiB0aGlzLiRlbCAmJiAobiA9ICEwLCB0aGlzLiRyZW1vdmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbiA9ICExLCBzKClcbiAgICAgICAgICAgIH0pKSwgdGhpcy5fY2FsbEhvb2soXCJiZWZvcmVEZXN0cm95XCIpLCB0aGlzLl9pc0JlaW5nRGVzdHJveWVkID0gITA7XG4gICAgICAgICAgICB2YXIgbywgYSA9IHRoaXMuJHBhcmVudDtcbiAgICAgICAgICAgIGZvciAoYSAmJiAhYS5faXNCZWluZ0Rlc3Ryb3llZCAmJiAoYS4kY2hpbGRyZW4uJHJlbW92ZSh0aGlzKSwgdGhpcy5fdXBkYXRlUmVmKCEwKSksIG8gPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7IG8tLTspIHRoaXMuJGNoaWxkcmVuW29dLiRkZXN0cm95KCk7XG4gICAgICAgICAgICBmb3IgKHRoaXMuX3Byb3BzVW5saW5rRm4gJiYgdGhpcy5fcHJvcHNVbmxpbmtGbigpLCB0aGlzLl91bmxpbmtGbiAmJiB0aGlzLl91bmxpbmtGbigpLCBvID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoOyBvLS07KSB0aGlzLl93YXRjaGVyc1tvXS50ZWFyZG93bigpO1xuICAgICAgICAgICAgdGhpcy4kZWwgJiYgKHRoaXMuJGVsLl9fdnVlX18gPSBudWxsKSwgaSA9ICEwLCBzKClcbiAgICAgICAgfSwgdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRGVzdHJveWVkIHx8ICh0aGlzLl9mcmFnICYmIHRoaXMuX2ZyYWcuY2hpbGRyZW4uJHJlbW92ZSh0aGlzKSwgdGhpcy5fZGF0YS5fX29iX18gJiYgdGhpcy5fZGF0YS5fX29iX18ucmVtb3ZlVm0odGhpcyksIHRoaXMuJGVsID0gdGhpcy4kcGFyZW50ID0gdGhpcy4kcm9vdCA9IHRoaXMuJGNoaWxkcmVuID0gdGhpcy5fd2F0Y2hlcnMgPSB0aGlzLl9jb250ZXh0ID0gdGhpcy5fc2NvcGUgPSB0aGlzLl9kaXJlY3RpdmVzID0gbnVsbCwgdGhpcy5faXNEZXN0cm95ZWQgPSAhMCwgdGhpcy5fY2FsbEhvb2soXCJkZXN0cm95ZWRcIiksIHRoaXMuJG9mZigpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmkodCkge1xuICAgICAgICB0LnByb3RvdHlwZS5fYXBwbHlGaWx0ZXJzID0gZnVuY3Rpb24odCwgZSwgaSwgbikge1xuICAgICAgICAgICAgdmFyIHIsIHMsIG8sIGEsIGgsIGwsIGMsIHUsIGY7XG4gICAgICAgICAgICBmb3IgKGwgPSAwLCBjID0gaS5sZW5ndGg7IGMgPiBsOyBsKyspXG4gICAgICAgICAgICAgICAgaWYgKHIgPSBpW2xdLCBzID0gX3QodGhpcy4kb3B0aW9ucywgXCJmaWx0ZXJzXCIsIHIubmFtZSksIHMgJiYgKHMgPSBuID8gcy53cml0ZSA6IHMucmVhZCB8fCBzLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvID0gbiA/IFt0LCBlXSA6IFt0XSwgaCA9IG4gPyAyIDogMSwgci5hcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh1ID0gMCwgZiA9IHIuYXJncy5sZW5ndGg7IGYgPiB1OyB1KyspIGEgPSByLmFyZ3NbdV0sIG9bdSArIGhdID0gYS5keW5hbWljID8gdGhpcy4kZ2V0KGEudmFsdWUpIDogYS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHMuYXBwbHkodGhpcywgbylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdFxuICAgICAgICB9LCB0LnByb3RvdHlwZS5fcmVzb2x2ZUNvbXBvbmVudCA9IGZ1bmN0aW9uKGUsIGkpIHtcbiAgICAgICAgICAgIHZhciBuID0gX3QodGhpcy4kb3B0aW9ucywgXCJjb21wb25lbnRzXCIsIGUpO1xuICAgICAgICAgICAgaWYgKG4pXG4gICAgICAgICAgICAgICAgaWYgKG4ub3B0aW9ucykgaShuKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuLnJlc29sdmVkKSBpKG4ucmVzb2x2ZWQpO1xuICAgICAgICAgICAgZWxzZSBpZiAobi5yZXF1ZXN0ZWQpIG4ucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGkpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbi5yZXF1ZXN0ZWQgPSAhMDtcbiAgICAgICAgICAgICAgICB2YXIgciA9IG4ucGVuZGluZ0NhbGxiYWNrcyA9IFtpXTtcbiAgICAgICAgICAgICAgICBuKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZyhlKSAmJiAoZSA9IHQuZXh0ZW5kKGUpKSwgbi5yZXNvbHZlZCA9IGU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBzID0gci5sZW5ndGg7IHMgPiBpOyBpKyspIHJbaV0oZSlcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbih0KSB7fSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNpKGkpIHtcbiAgICAgICAgZnVuY3Rpb24gbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwicmV0dXJuIGZ1bmN0aW9uIFwiICsgZih0KSArIFwiIChvcHRpb25zKSB7IHRoaXMuX2luaXQob3B0aW9ucykgfVwiKSgpXG4gICAgICAgIH1cbiAgICAgICAgaS51dGlsID0gX24sIGkuY29uZmlnID0gYW4sIGkuc2V0ID0gdCwgaVtcImRlbGV0ZVwiXSA9IGUsIGkubmV4dFRpY2sgPSBEaSwgaS5jb21waWxlciA9IGZzLCBpLkZyYWdtZW50RmFjdG9yeSA9IHBlLCBpLmludGVybmFsRGlyZWN0aXZlcyA9IHRzLCBpLnBhcnNlcnMgPSB7XG4gICAgICAgICAgICBwYXRoOiBQbixcbiAgICAgICAgICAgIHRleHQ6IHJuLFxuICAgICAgICAgICAgdGVtcGxhdGU6IERyLFxuICAgICAgICAgICAgZGlyZWN0aXZlOiBLaSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IEduXG4gICAgICAgIH0sIGkuY2lkID0gMDtcbiAgICAgICAgdmFyIHIgPSAxO1xuICAgICAgICBpLmV4dGVuZCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHQgPSB0IHx8IHt9O1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgPSAwID09PSBlLmNpZDtcbiAgICAgICAgICAgIGlmIChpICYmIHQuX0N0b3IpIHJldHVybiB0Ll9DdG9yO1xuICAgICAgICAgICAgdmFyIHMgPSB0Lm5hbWUgfHwgZS5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgbyA9IG4ocyB8fCBcIlZ1ZUNvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiBvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUpLCBvLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG8sIG8uY2lkID0gcisrLCBvLm9wdGlvbnMgPSBndChlLm9wdGlvbnMsIHQpLCBvW1wic3VwZXJcIl0gPSBlLCBvLmV4dGVuZCA9IGUuZXh0ZW5kLCBhbi5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICBvW3RdID0gZVt0XVxuICAgICAgICAgICAgfSksIHMgJiYgKG8ub3B0aW9ucy5jb21wb25lbnRzW3NdID0gbyksIGkgJiYgKHQuX0N0b3IgPSBvKSwgb1xuICAgICAgICB9LCBpLnVzZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGlmICghdC5pbnN0YWxsZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGQoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS51bnNoaWZ0KHRoaXMpLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQuaW5zdGFsbCA/IHQuaW5zdGFsbC5hcHBseSh0LCBlKSA6IHQuYXBwbHkobnVsbCwgZSksIHQuaW5zdGFsbGVkID0gITAsIHRoaXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaS5taXhpbiA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGkub3B0aW9ucyA9IGd0KGkub3B0aW9ucywgdClcbiAgICAgICAgfSwgYW4uX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpW3RdID0gZnVuY3Rpb24oZSwgbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuID8gKFwiY29tcG9uZW50XCIgPT09IHQgJiYgZyhuKSAmJiAobi5uYW1lID0gZSwgbiA9IGkuZXh0ZW5kKG4pKSwgdGhpcy5vcHRpb25zW3QgKyBcInNcIl1bZV0gPSBuLCBuKSA6IHRoaXMub3B0aW9uc1t0ICsgXCJzXCJdW2VdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2kodCkge1xuICAgICAgICBmdW5jdGlvbiBpKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHQpKVxuICAgICAgICB9XG4gICAgICAgIHQucHJvdG90eXBlLiRnZXQgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICB2YXIgaSA9IFd0KHQpO1xuICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSAmJiAhQnQodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLiRhcmd1bWVudHMgPSBkKGFyZ3VtZW50cyksIGkuZ2V0LmNhbGwobiwgbiksIG4uJGFyZ3VtZW50cyA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaS5nZXQuY2FsbCh0aGlzLCB0aGlzKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHIpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHQucHJvdG90eXBlLiRzZXQgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICB2YXIgaSA9IFd0KHQsICEwKTtcbiAgICAgICAgICAgIGkgJiYgaS5zZXQgJiYgaS5zZXQuY2FsbCh0aGlzLCB0aGlzLCBlKVxuICAgICAgICB9LCB0LnByb3RvdHlwZS4kZGVsZXRlID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgZSh0aGlzLl9kYXRhLCB0KVxuICAgICAgICB9LCB0LnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgICAgICAgICB2YXIgbiwgciA9IHRoaXM7XG4gICAgICAgICAgICBcInN0cmluZ1wiID09IHR5cGVvZiB0ICYmIChuID0gQSh0KSwgdCA9IG4uZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB2YXIgcyA9IG5ldyBVdChyLCB0LCBlLCB7XG4gICAgICAgICAgICAgICAgZGVlcDogaSAmJiBpLmRlZXAsXG4gICAgICAgICAgICAgICAgc3luYzogaSAmJiBpLnN5bmMsXG4gICAgICAgICAgICAgICAgZmlsdGVyczogbiAmJiBuLmZpbHRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGkgJiYgaS5pbW1lZGlhdGUgJiYgZS5jYWxsKHIsIHMudmFsdWUpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzLnRlYXJkb3duKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0sIHQucHJvdG90eXBlLiRldmFsID0gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgaWYgKGRzLnRlc3QodCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IEEodCksXG4gICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzLiRnZXQoaS5leHByZXNzaW9uLCBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5maWx0ZXJzID8gdGhpcy5fYXBwbHlGaWx0ZXJzKG4sIG51bGwsIGkuZmlsdGVycykgOiBuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZ2V0KHQsIGUpXG4gICAgICAgIH0sIHQucHJvdG90eXBlLiRpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHZhciBlID0gVCh0KSxcbiAgICAgICAgICAgICAgICBpID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBlID8gMSA9PT0gZS5sZW5ndGggPyBpLiRldmFsKGVbMF0udmFsdWUpICsgXCJcIiA6IGUubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdC50YWcgPyBpLiRldmFsKHQudmFsdWUpIDogdC52YWx1ZVxuICAgICAgICAgICAgfSkuam9pbihcIlwiKSA6IHRcbiAgICAgICAgfSwgdC5wcm90b3R5cGUuJGxvZyA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdCA/IEV0KHRoaXMuX2RhdGEsIHQpIDogdGhpcy5fZGF0YTtcbiAgICAgICAgICAgIGlmIChlICYmIChlID0gaShlKSksICF0KVxuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gaW4gdGhpcy4kb3B0aW9ucy5jb21wdXRlZCkgZVtuXSA9IGkodGhpc1tuXSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWkodCkge1xuICAgICAgICBmdW5jdGlvbiBlKHQsIGUsIG4sIHIsIHMsIG8pIHtcbiAgICAgICAgICAgIGUgPSBpKGUpO1xuICAgICAgICAgICAgdmFyIGEgPSAhVyhlKSxcbiAgICAgICAgICAgICAgICBoID0gciA9PT0gITEgfHwgYSA/IHMgOiBvLFxuICAgICAgICAgICAgICAgIGwgPSAhYSAmJiAhdC5faXNBdHRhY2hlZCAmJiAhVyh0LiRlbCk7XG4gICAgICAgICAgICByZXR1cm4gdC5faXNGcmFnbWVudCA/IChzdCh0Ll9mcmFnbWVudFN0YXJ0LCB0Ll9mcmFnbWVudEVuZCwgZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgIGgoaSwgZSwgdClcbiAgICAgICAgICAgIH0pLCBuICYmIG4oKSkgOiBoKHQuJGVsLCBlLCB0LCBuKSwgbCAmJiB0Ll9jYWxsSG9vayhcImF0dGFjaGVkXCIpLCB0XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiB0ID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KSA6IHRcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG4odCwgZSwgaSwgbikge1xuICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0KSwgbiAmJiBuKClcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHIodCwgZSwgaSwgbikge1xuICAgICAgICAgICAgeih0LCBlKSwgbiAmJiBuKClcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHModCwgZSwgaSkge1xuICAgICAgICAgICAgVSh0KSwgaSAmJiBpKClcbiAgICAgICAgfVxuICAgICAgICB0LnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBEaSh0LCB0aGlzKVxuICAgICAgICB9LCB0LnByb3RvdHlwZS4kYXBwZW5kVG8gPSBmdW5jdGlvbih0LCBpLCByKSB7XG4gICAgICAgICAgICByZXR1cm4gZSh0aGlzLCB0LCBpLCByLCBuLCBEKVxuICAgICAgICB9LCB0LnByb3RvdHlwZS4kcHJlcGVuZFRvID0gZnVuY3Rpb24odCwgZSwgbikge1xuICAgICAgICAgICAgcmV0dXJuIHQgPSBpKHQpLCB0Lmhhc0NoaWxkTm9kZXMoKSA/IHRoaXMuJGJlZm9yZSh0LmZpcnN0Q2hpbGQsIGUsIG4pIDogdGhpcy4kYXBwZW5kVG8odCwgZSwgbiksIHRoaXNcbiAgICAgICAgfSwgdC5wcm90b3R5cGUuJGJlZm9yZSA9IGZ1bmN0aW9uKHQsIGksIG4pIHtcbiAgICAgICAgICAgIHJldHVybiBlKHRoaXMsIHQsIGksIG4sIHIsIFApXG4gICAgICAgIH0sIHQucHJvdG90eXBlLiRhZnRlciA9IGZ1bmN0aW9uKHQsIGUsIG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0ID0gaSh0KSwgdC5uZXh0U2libGluZyA/IHRoaXMuJGJlZm9yZSh0Lm5leHRTaWJsaW5nLCBlLCBuKSA6IHRoaXMuJGFwcGVuZFRvKHQucGFyZW50Tm9kZSwgZSwgbiksIHRoaXNcbiAgICAgICAgfSwgdC5wcm90b3R5cGUuJHJlbW92ZSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kZWwucGFyZW50Tm9kZSkgcmV0dXJuIHQgJiYgdCgpO1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9pc0F0dGFjaGVkICYmIFcodGhpcy4kZWwpO1xuICAgICAgICAgICAgaSB8fCAoZSA9ICExKTtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcyxcbiAgICAgICAgICAgICAgICByID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgJiYgbi5fY2FsbEhvb2soXCJkZXRhY2hlZFwiKSwgdCAmJiB0KClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzRnJhZ21lbnQpIG90KHRoaXMuX2ZyYWdtZW50U3RhcnQsIHRoaXMuX2ZyYWdtZW50RW5kLCB0aGlzLCB0aGlzLl9mcmFnbWVudCwgcik7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IGUgPT09ICExID8gcyA6IFI7XG4gICAgICAgICAgICAgICAgbyh0aGlzLiRlbCwgdGhpcywgcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoaSh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUodCwgZSwgbikge1xuICAgICAgICAgICAgdmFyIHIgPSB0LiRwYXJlbnQ7XG4gICAgICAgICAgICBpZiAociAmJiBuICYmICFpLnRlc3QoZSkpXG4gICAgICAgICAgICAgICAgZm9yICg7IHI7KSByLl9ldmVudHNDb3VudFtlXSA9IChyLl9ldmVudHNDb3VudFtlXSB8fCAwKSArIG4sIHIgPSByLiRwYXJlbnRcbiAgICAgICAgfVxuICAgICAgICB0LnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbih0LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2V2ZW50c1t0XSB8fCAodGhpcy5fZXZlbnRzW3RdID0gW10pKS5wdXNoKGkpLCBlKHRoaXMsIHQsIDEpLCB0aGlzXG4gICAgICAgIH0sIHQucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgICAgICAgICBuLiRvZmYodCwgaSksIGUuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGkuZm4gPSBlLCB0aGlzLiRvbih0LCBpKSwgdGhpc1xuICAgICAgICB9LCB0LnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24odCwgaSkge1xuICAgICAgICAgICAgdmFyIG47XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHQgaW4gdGhpcy5fZXZlbnRzKSBuID0gdGhpcy5fZXZlbnRzW3RdLCBuICYmIGUodGhpcywgdCwgLW4ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzID0ge30sIHRoaXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuID0gdGhpcy5fZXZlbnRzW3RdLCAhbikgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGUodGhpcywgdCwgLW4ubGVuZ3RoKSwgdGhpcy5fZXZlbnRzW3RdID0gbnVsbCwgdGhpcztcbiAgICAgICAgICAgIGZvciAodmFyIHIsIHMgPSBuLmxlbmd0aDsgcy0tOylcbiAgICAgICAgICAgICAgICBpZiAociA9IG5bc10sIHIgPT09IGkgfHwgci5mbiA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBlKHRoaXMsIHQsIC0xKSwgbi5zcGxpY2UocywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSwgdC5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuX2V2ZW50c1t0XSxcbiAgICAgICAgICAgICAgICBpID0gIWU7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIGUgPSBlLmxlbmd0aCA+IDEgPyBkKGUpIDogZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gZChhcmd1bWVudHMsIDEpLCByID0gMCwgcyA9IGUubGVuZ3RoOyBzID4gcjsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gZVtyXS5hcHBseSh0aGlzLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgbyA9PT0gITAgJiYgKGkgPSAhMClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICB9LCB0LnByb3RvdHlwZS4kYnJvYWRjYXN0ID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50c0NvdW50W3RdKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMuJGNoaWxkcmVuLCBpID0gMCwgbiA9IGUubGVuZ3RoOyBuID4gaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSByLiRlbWl0LmFwcGx5KHIsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHMgJiYgci4kYnJvYWRjYXN0LmFwcGx5KHIsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdC5wcm90b3R5cGUuJGRpc3BhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gdGhpcy4kcGFyZW50OyB0Oykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdC4kZW1pdC5hcHBseSh0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHQgPSBlID8gdC4kcGFyZW50IDogbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGkgPSAvXmhvb2s6L1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSAhMCwgdGhpcy5faXNSZWFkeSA9ICEwLCB0aGlzLl9jYWxsSG9vayhcInJlYWR5XCIpXG4gICAgICAgIH1cbiAgICAgICAgdC5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ29tcGlsZWQgPyB2b2lkIDAgOiAodCA9IEwodCksIHQgfHwgKHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSwgdGhpcy5fY29tcGlsZSh0KSwgdGhpcy5faW5pdERPTUhvb2tzKCksIFcodGhpcy4kZWwpID8gKHRoaXMuX2NhbGxIb29rKFwiYXR0YWNoZWRcIiksIGUuY2FsbCh0aGlzKSkgOiB0aGlzLiRvbmNlKFwiaG9vazphdHRhY2hlZFwiLCBlKSwgdGhpcylcbiAgICAgICAgfSwgdC5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95KHQsIGUpXG4gICAgICAgIH0sIHQucHJvdG90eXBlLiRjb21waWxlID0gZnVuY3Rpb24odCwgZSwgaSwgbikge1xuICAgICAgICAgICAgcmV0dXJuIEFlKHQsIHRoaXMuJG9wdGlvbnMsICEwKSh0aGlzLCB0LCBlLCBpLCBuKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2kodCkge1xuICAgICAgICB0aGlzLl9pbml0KHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdWkodCwgZSwgaSkge1xuICAgICAgICByZXR1cm4gaSA9IGkgPyBwYXJzZUludChpLCAxMCkgOiAwLCBcIm51bWJlclwiID09IHR5cGVvZiBlID8gdC5zbGljZShpLCBpICsgZSkgOiB0XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmkodCwgZSwgaSkge1xuICAgICAgICBpZiAodCA9IHZzKHQpLCBudWxsID09IGUpIHJldHVybiB0O1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSByZXR1cm4gdC5maWx0ZXIoZSk7XG4gICAgICAgIGUgPSAoXCJcIiArIGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAodmFyIG4sIHIsIHMsIG8sIGEgPSBcImluXCIgPT09IGkgPyAzIDogMiwgaCA9IGQoYXJndW1lbnRzLCBhKS5yZWR1Y2UoZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0LmNvbmNhdChlKVxuICAgICAgICAgICAgfSwgW10pLCBsID0gW10sIGMgPSAwLCB1ID0gdC5sZW5ndGg7IHUgPiBjOyBjKyspXG4gICAgICAgICAgICBpZiAobiA9IHRbY10sIHMgPSBuICYmIG4uJHZhbHVlIHx8IG4sIG8gPSBoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoOyBvLS07KVxuICAgICAgICAgICAgICAgICAgICBpZiAociA9IGhbb10sIFwiJGtleVwiID09PSByICYmIGRpKG4uJGtleSwgZSkgfHwgZGkoRXQocywgciksIGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsLnB1c2gobik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgZGkobiwgZSkgJiYgbC5wdXNoKG4pO1xuICAgICAgICByZXR1cm4gbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBpKHQsIGUsIGkpIHtcbiAgICAgICAgaWYgKHQgPSB2cyh0KSwgIWUpIHJldHVybiB0O1xuICAgICAgICB2YXIgbiA9IGkgJiYgMCA+IGkgPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiB0LnNsaWNlKCkuc29ydChmdW5jdGlvbih0LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIka2V5XCIgIT09IGUgJiYgKG0odCkgJiYgXCIkdmFsdWVcIiBpbiB0ICYmICh0ID0gdC4kdmFsdWUpLCBtKGkpICYmIFwiJHZhbHVlXCIgaW4gaSAmJiAoaSA9IGkuJHZhbHVlKSksIHQgPSBtKHQpID8gRXQodCwgZSkgOiB0LCBpID0gbShpKSA/IEV0KGksIGUpIDogaSwgdCA9PT0gaSA/IDAgOiB0ID4gaSA/IG4gOiAtblxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpKHQsIGUpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmIChnKHQpKSB7XG4gICAgICAgICAgICB2YXIgbiA9IE9iamVjdC5rZXlzKHQpO1xuICAgICAgICAgICAgZm9yIChpID0gbi5sZW5ndGg7IGktLTspXG4gICAgICAgICAgICAgICAgaWYgKGRpKHRbbltpXV0sIGUpKSByZXR1cm4gITBcbiAgICAgICAgfSBlbHNlIGlmICgkaSh0KSkge1xuICAgICAgICAgICAgZm9yIChpID0gdC5sZW5ndGg7IGktLTspXG4gICAgICAgICAgICAgICAgaWYgKGRpKHRbaV0sIGUpKSByZXR1cm4gITBcbiAgICAgICAgfSBlbHNlIGlmIChudWxsICE9IHQpIHJldHVybiB0LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKGUpID4gLTFcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2aSh0LCBlLCBpKSB7XG4gICAgICAgIGZ1bmN0aW9uIG4odCkge1xuICAgICAgICAgICAgIWl0KHQpIHx8IHQuaGFzQXR0cmlidXRlKFwidi1pZlwiKSB8fCB0Lmhhc0F0dHJpYnV0ZShcInYtZm9yXCIpIHx8ICh0ID0gcmUodCkpLCB0ID0gbmUodCksIHIuYXBwZW5kQ2hpbGQodClcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciByID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzID0gMCwgbyA9IHQubGVuZ3RoOyBvID4gczsgcysrKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRbc107XG4gICAgICAgICAgICBpICYmICFhLl9fdl9zZWxlY3RlZCA/IG4oYSkgOiBpIHx8IGEucGFyZW50Tm9kZSAhPT0gZSB8fCAoYS5fX3Zfc2VsZWN0ZWQgPSAhMCwgbihhKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gclxuICAgIH1cbiAgICB2YXIgbWkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgICBnaSA9IC9eXFxzPyh0cnVlfGZhbHNlfFtcXGRcXC5dK3wnW14nXSonfFwiW15cIl0qXCIpXFxzPyQvLFxuICAgICAgICBfaSA9IC8tKFxcdykvZyxcbiAgICAgICAgYmkgPSAvKFthLXpcXGRdKShbQS1aXSkvZyxcbiAgICAgICAgeWkgPSAvKD86XnxbLV9cXC9dKShcXHcpL2csXG4gICAgICAgIENpID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgd2kgPSBcIltvYmplY3QgT2JqZWN0XVwiLFxuICAgICAgICAkaSA9IEFycmF5LmlzQXJyYXksXG4gICAgICAgIGtpID0gXCJfX3Byb3RvX19cIiBpbiB7fSxcbiAgICAgICAgeGkgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgXCJbb2JqZWN0IE9iamVjdF1cIiAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdyksXG4gICAgICAgIEFpID0geGkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJtc2llIDkuMFwiKSA+IDAsXG4gICAgICAgIE9pID0geGkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhbmRyb2lkXCIpID4gMCxcbiAgICAgICAgTmkgPSB2b2lkIDAsXG4gICAgICAgIFRpID0gdm9pZCAwLFxuICAgICAgICBqaSA9IHZvaWQgMCxcbiAgICAgICAgRWkgPSB2b2lkIDA7XG4gICAgaWYgKHhpICYmICFBaSkge1xuICAgICAgICB2YXIgU2kgPSB2b2lkIDAgPT09IHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgJiYgdm9pZCAwICE9PSB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kLFxuICAgICAgICAgICAgRmkgPSB2b2lkIDAgPT09IHdpbmRvdy5vbmFuaW1hdGlvbmVuZCAmJiB2b2lkIDAgIT09IHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZDtcbiAgICAgICAgTmkgPSBTaSA/IFwiV2Via2l0VHJhbnNpdGlvblwiIDogXCJ0cmFuc2l0aW9uXCIsIFRpID0gU2kgPyBcIndlYmtpdFRyYW5zaXRpb25FbmRcIiA6IFwidHJhbnNpdGlvbmVuZFwiLCBqaSA9IEZpID8gXCJXZWJraXRBbmltYXRpb25cIiA6IFwiYW5pbWF0aW9uXCIsIEVpID0gRmkgPyBcIndlYmtpdEFuaW1hdGlvbkVuZFwiIDogXCJhbmltYXRpb25lbmRcIlxuICAgIH1cbiAgICB2YXIgRGkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHQoKSB7XG4gICAgICAgICAgICAgICAgbiA9ICExO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gaS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICBpID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0Lmxlbmd0aDsgZSsrKSB0W2VdKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlLCBpID0gW10sXG4gICAgICAgICAgICAgICAgbiA9ICExO1xuICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IDEsXG4gICAgICAgICAgICAgICAgICAgIHMgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0KSxcbiAgICAgICAgICAgICAgICAgICAgbyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHIpO1xuICAgICAgICAgICAgICAgIHMub2JzZXJ2ZShvLCB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6ICEwXG4gICAgICAgICAgICAgICAgfSksIGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IChyICsgMSkgJSAyLCBvLmRhdGEgPSByXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGUgPSBzZXRUaW1lb3V0O1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHIsIHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHMgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgci5jYWxsKHMpXG4gICAgICAgICAgICAgICAgfSA6IHI7XG4gICAgICAgICAgICAgICAgaS5wdXNoKG8pLCBuIHx8IChuID0gITAsIGUodCwgMCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0oKSxcbiAgICAgICAgUGkgPSAkLnByb3RvdHlwZTtcbiAgICBQaS5wdXQgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIHZhciBpID0ge1xuICAgICAgICAgICAga2V5OiB0LFxuICAgICAgICAgICAgdmFsdWU6IGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleW1hcFt0XSA9IGksIHRoaXMudGFpbCA/ICh0aGlzLnRhaWwubmV3ZXIgPSBpLCBpLm9sZGVyID0gdGhpcy50YWlsKSA6IHRoaXMuaGVhZCA9IGksIHRoaXMudGFpbCA9IGksIHRoaXMuc2l6ZSA9PT0gdGhpcy5saW1pdCA/IHRoaXMuc2hpZnQoKSA6IHZvaWQgdGhpcy5zaXplKytcbiAgICB9LCBQaS5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuaGVhZDtcbiAgICAgICAgcmV0dXJuIHQgJiYgKHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXdlciwgdGhpcy5oZWFkLm9sZGVyID0gdm9pZCAwLCB0Lm5ld2VyID0gdC5vbGRlciA9IHZvaWQgMCwgdGhpcy5fa2V5bWFwW3Qua2V5XSA9IHZvaWQgMCksIHRcbiAgICB9LCBQaS5nZXQgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fa2V5bWFwW3RdO1xuICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBpID8gaSA9PT0gdGhpcy50YWlsID8gZSA/IGkgOiBpLnZhbHVlIDogKGkubmV3ZXIgJiYgKGkgPT09IHRoaXMuaGVhZCAmJiAodGhpcy5oZWFkID0gaS5uZXdlciksIGkubmV3ZXIub2xkZXIgPSBpLm9sZGVyKSwgaS5vbGRlciAmJiAoaS5vbGRlci5uZXdlciA9IGkubmV3ZXIpLCBpLm5ld2VyID0gdm9pZCAwLCBpLm9sZGVyID0gdGhpcy50YWlsLCB0aGlzLnRhaWwgJiYgKHRoaXMudGFpbC5uZXdlciA9IGkpLCB0aGlzLnRhaWwgPSBpLCBlID8gaSA6IGkudmFsdWUpIDogdm9pZCAwXG4gICAgfTtcbiAgICB2YXIgUmksIEhpLCBMaSwgV2ksIEJpLCBWaSwgTWksIHppLCBJaSwgVWksIHFpLCBKaSwgUWkgPSBuZXcgJCgxZTMpLFxuICAgICAgICBHaSA9IC9bXlxccydcIl0rfCdbXiddKid8XCJbXlwiXSpcIi9nLFxuICAgICAgICBaaSA9IC9eaW4kfF4tP1xcZCsvLFxuICAgICAgICBLaSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgcGFyc2VEaXJlY3RpdmU6IEFcbiAgICAgICAgfSksXG4gICAgICAgIFhpID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZyxcbiAgICAgICAgWWkgPSB2b2lkIDAsXG4gICAgICAgIHRuID0gdm9pZCAwLFxuICAgICAgICBlbiA9IHZvaWQgMCxcbiAgICAgICAgbm4gPSAvW158XVxcfFtefF0vLFxuICAgICAgICBybiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgY29tcGlsZVJlZ2V4OiBOLFxuICAgICAgICAgICAgcGFyc2VUZXh0OiBULFxuICAgICAgICAgICAgdG9rZW5zVG9FeHA6IGosXG4gICAgICAgICAgICByZW1vdmVUYWdzOiBGXG4gICAgICAgIH0pLFxuICAgICAgICBzbiA9IFtcInt7XCIsIFwifX1cIl0sXG4gICAgICAgIG9uID0gW1wie3t7XCIsIFwifX19XCJdLFxuICAgICAgICBhbiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIGRlYnVnOiAhMSxcbiAgICAgICAgICAgIHNpbGVudDogITEsXG4gICAgICAgICAgICBhc3luYzogITAsXG4gICAgICAgICAgICB3YXJuRXhwcmVzc2lvbkVycm9yczogITAsXG4gICAgICAgICAgICBjb252ZXJ0QWxsUHJvcGVydGllczogITEsXG4gICAgICAgICAgICBfZGVsaW1pdGVyc0NoYW5nZWQ6ICEwLFxuICAgICAgICAgICAgX2Fzc2V0VHlwZXM6IFtcImNvbXBvbmVudFwiLCBcImRpcmVjdGl2ZVwiLCBcImVsZW1lbnREaXJlY3RpdmVcIiwgXCJmaWx0ZXJcIiwgXCJ0cmFuc2l0aW9uXCIsIFwicGFydGlhbFwiXSxcbiAgICAgICAgICAgIF9wcm9wQmluZGluZ01vZGVzOiB7XG4gICAgICAgICAgICAgICAgT05FX1dBWTogMCxcbiAgICAgICAgICAgICAgICBUV09fV0FZOiAxLFxuICAgICAgICAgICAgICAgIE9ORV9USU1FOiAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21heFVwZGF0ZUNvdW50OiAxMDBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgZGVsaW1pdGVyczoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNuID0gdCwgTigpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zYWZlRGVsaW1pdGVyczoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uID0gdCwgTigpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBobiA9IHZvaWQgMCxcbiAgICAgICAgbG4gPSAvXnYtcmVmOi8sXG4gICAgICAgIGNuID0gL14oZGl2fHB8c3BhbnxpbWd8YXxifGl8YnJ8dWx8b2x8bGl8aDF8aDJ8aDN8aDR8aDV8aDZ8Y29kZXxwcmV8dGFibGV8dGh8dGR8dHJ8Zm9ybXxsYWJlbHxpbnB1dHxzZWxlY3R8b3B0aW9ufG5hdnxhcnRpY2xlfHNlY3Rpb258aGVhZGVyfGZvb3RlcikkLyxcbiAgICAgICAgdW4gPSAvXihzbG90fHBhcnRpYWx8Y29tcG9uZW50KSQvLFxuICAgICAgICBmbiA9IGFuLm9wdGlvbk1lcmdlU3RyYXRlZ2llcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm4uZGF0YSA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIGkgPyB0IHx8IGUgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBuID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBlID8gZS5jYWxsKGkpIDogZSxcbiAgICAgICAgICAgICAgICByID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gdC5jYWxsKGkpIDogdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIG4gPyBmdChuLCByKSA6IHJcbiAgICAgICAgfSA6IHZvaWQgMCA6IGUgPyBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgPyB0IDogdCA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ0KGUuY2FsbCh0aGlzKSwgdC5jYWxsKHRoaXMpKVxuICAgICAgICB9IDogZSA6IHRcbiAgICB9LCBmbi5lbCA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICAgICAgaWYgKGkgfHwgIWUgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGUgfHwgdDtcbiAgICAgICAgICAgIHJldHVybiBpICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IG4uY2FsbChpKSA6IG5cbiAgICAgICAgfVxuICAgIH0sIGZuLmluaXQgPSBmbi5jcmVhdGVkID0gZm4ucmVhZHkgPSBmbi5hdHRhY2hlZCA9IGZuLmRldGFjaGVkID0gZm4uYmVmb3JlQ29tcGlsZSA9IGZuLmNvbXBpbGVkID0gZm4uYmVmb3JlRGVzdHJveSA9IGZuLmRlc3Ryb3llZCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIGUgPyB0ID8gdC5jb25jYXQoZSkgOiAkaShlKSA/IGUgOiBbZV0gOiB0XG4gICAgfSwgZm4ucGFyYW1BdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7fSwgYW4uX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgICAgIGZuW3QgKyBcInNcIl0gPSBwdFxuICAgIH0pLCBmbi53YXRjaCA9IGZuLmV2ZW50cyA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgaWYgKCFlKSByZXR1cm4gdDtcbiAgICAgICAgaWYgKCF0KSByZXR1cm4gZTtcbiAgICAgICAgdmFyIGkgPSB7fTtcbiAgICAgICAgdihpLCB0KTtcbiAgICAgICAgZm9yICh2YXIgbiBpbiBlKSB7XG4gICAgICAgICAgICB2YXIgciA9IGlbbl0sXG4gICAgICAgICAgICAgICAgcyA9IGVbbl07XG4gICAgICAgICAgICByICYmICEkaShyKSAmJiAociA9IFtyXSksIGlbbl0gPSByID8gci5jb25jYXQocykgOiBbc11cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaVxuICAgIH0sIGZuLnByb3BzID0gZm4ubWV0aG9kcyA9IGZuLmNvbXB1dGVkID0gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICBpZiAoIWUpIHJldHVybiB0O1xuICAgICAgICBpZiAoIXQpIHJldHVybiBlO1xuICAgICAgICB2YXIgaSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHJldHVybiB2KGksIHQpLCB2KGksIGUpLCBpXG4gICAgfTtcbiAgICB2YXIgcG4gPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBlID8gdCA6IGVcbiAgICAgICAgfSxcbiAgICAgICAgZG4gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgICAgIHZuID0gT2JqZWN0LmNyZWF0ZShkbik7XG4gICAgW1wicHVzaFwiLCBcInBvcFwiLCBcInNoaWZ0XCIsIFwidW5zaGlmdFwiLCBcInNwbGljZVwiLCBcInNvcnRcIiwgXCJyZXZlcnNlXCJdLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgZSA9IGRuW3RdO1xuICAgICAgICBfKHZuLCB0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBuID0gbmV3IEFycmF5KGkpOyBpLS07KSBuW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIHIsIHMgPSBlLmFwcGx5KHRoaXMsIG4pLFxuICAgICAgICAgICAgICAgIG8gPSB0aGlzLl9fb2JfXztcbiAgICAgICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwdXNoXCI6XG4gICAgICAgICAgICAgICAgICAgIHIgPSBuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidW5zaGlmdFwiOlxuICAgICAgICAgICAgICAgICAgICByID0gbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNwbGljZVwiOlxuICAgICAgICAgICAgICAgICAgICByID0gbi5zbGljZSgyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHIgJiYgby5vYnNlcnZlQXJyYXkociksIG8uZGVwLm5vdGlmeSgpLCBzXG4gICAgICAgIH0pXG4gICAgfSksIF8oZG4sIFwiJHNldFwiLCBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIHJldHVybiB0ID49IHRoaXMubGVuZ3RoICYmICh0aGlzLmxlbmd0aCA9IHQgKyAxKSwgdGhpcy5zcGxpY2UodCwgMSwgZSlbMF1cbiAgICB9KSwgXyhkbiwgXCIkcmVtb3ZlXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHkodGhpcywgdCk7XG4gICAgICAgICAgICByZXR1cm4gZSA+IC0xID8gdGhpcy5zcGxpY2UoZSwgMSkgOiB2b2lkIDBcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBtbiA9IDA7XG4gICAgeXQudGFyZ2V0ID0gbnVsbCwgeXQucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2godClcbiAgICB9LCB5dC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24odCkge1xuICAgICAgICB0aGlzLnN1YnMuJHJlbW92ZSh0KVxuICAgIH0sIHl0LnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgeXQudGFyZ2V0LmFkZERlcCh0aGlzKVxuICAgIH0sIHl0LnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgdCA9IGQodGhpcy5zdWJzKSwgZSA9IDAsIGkgPSB0Lmxlbmd0aDsgaSA+IGU7IGUrKykgdFtlXS51cGRhdGUoKVxuICAgIH07XG4gICAgdmFyIGduID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModm4pO1xuICAgIEN0LnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBlID0gT2JqZWN0LmtleXModCksIGkgPSBlLmxlbmd0aDsgaS0tOykgdGhpcy5jb252ZXJ0KGVbaV0sIHRbZVtpXV0pXG4gICAgfSwgQ3QucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHQubGVuZ3RoOyBlLS07KSBrdCh0W2VdKVxuICAgIH0sIEN0LnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICB4dCh0aGlzLnZhbHVlLCB0LCBlKVxuICAgIH0sIEN0LnByb3RvdHlwZS5hZGRWbSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgKHRoaXMudm1zIHx8ICh0aGlzLnZtcyA9IFtdKSkucHVzaCh0KVxuICAgIH0sIEN0LnByb3RvdHlwZS5yZW1vdmVWbSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdGhpcy52bXMuJHJlbW92ZSh0KVxuICAgIH07XG4gICAgdmFyIF9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZTogeHQsXG4gICAgICAgICAgICBzZXQ6IHQsXG4gICAgICAgICAgICBkZWw6IGUsXG4gICAgICAgICAgICBoYXNPd246IGksXG4gICAgICAgICAgICBpc0xpdGVyYWw6IG4sXG4gICAgICAgICAgICBpc1Jlc2VydmVkOiByLFxuICAgICAgICAgICAgX3RvU3RyaW5nOiBzLFxuICAgICAgICAgICAgdG9OdW1iZXI6IG8sXG4gICAgICAgICAgICB0b0Jvb2xlYW46IGEsXG4gICAgICAgICAgICBzdHJpcFF1b3RlczogaCxcbiAgICAgICAgICAgIGNhbWVsaXplOiBsLFxuICAgICAgICAgICAgaHlwaGVuYXRlOiB1LFxuICAgICAgICAgICAgY2xhc3NpZnk6IGYsXG4gICAgICAgICAgICBiaW5kOiBwLFxuICAgICAgICAgICAgdG9BcnJheTogZCxcbiAgICAgICAgICAgIGV4dGVuZDogdixcbiAgICAgICAgICAgIGlzT2JqZWN0OiBtLFxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdDogZyxcbiAgICAgICAgICAgIGRlZjogXyxcbiAgICAgICAgICAgIGRlYm91bmNlOiBiLFxuICAgICAgICAgICAgaW5kZXhPZjogeSxcbiAgICAgICAgICAgIGNhbmNlbGxhYmxlOiBDLFxuICAgICAgICAgICAgbG9vc2VFcXVhbDogdyxcbiAgICAgICAgICAgIGlzQXJyYXk6ICRpLFxuICAgICAgICAgICAgaGFzUHJvdG86IGtpLFxuICAgICAgICAgICAgaW5Ccm93c2VyOiB4aSxcbiAgICAgICAgICAgIGlzSUU5OiBBaSxcbiAgICAgICAgICAgIGlzQW5kcm9pZDogT2ksXG4gICAgICAgICAgICBnZXQgdHJhbnNpdGlvblByb3AoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHRyYW5zaXRpb25FbmRFdmVudCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVGlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgYW5pbWF0aW9uUHJvcCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gamlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgYW5pbWF0aW9uRW5kRXZlbnQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dFRpY2s6IERpLFxuICAgICAgICAgICAgcXVlcnk6IEwsXG4gICAgICAgICAgICBpbkRvYzogVyxcbiAgICAgICAgICAgIGdldEF0dHI6IEIsXG4gICAgICAgICAgICBnZXRCaW5kQXR0cjogVixcbiAgICAgICAgICAgIGhhc0JpbmRBdHRyOiBNLFxuICAgICAgICAgICAgYmVmb3JlOiB6LFxuICAgICAgICAgICAgYWZ0ZXI6IEksXG4gICAgICAgICAgICByZW1vdmU6IFUsXG4gICAgICAgICAgICBwcmVwZW5kOiBxLFxuICAgICAgICAgICAgcmVwbGFjZTogSixcbiAgICAgICAgICAgIG9uOiBRLFxuICAgICAgICAgICAgb2ZmOiBHLFxuICAgICAgICAgICAgc2V0Q2xhc3M6IFosXG4gICAgICAgICAgICBhZGRDbGFzczogSyxcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzOiBYLFxuICAgICAgICAgICAgZXh0cmFjdENvbnRlbnQ6IFksXG4gICAgICAgICAgICB0cmltTm9kZTogdHQsXG4gICAgICAgICAgICBpc1RlbXBsYXRlOiBpdCxcbiAgICAgICAgICAgIGNyZWF0ZUFuY2hvcjogbnQsXG4gICAgICAgICAgICBmaW5kUmVmOiBydCxcbiAgICAgICAgICAgIG1hcE5vZGVSYW5nZTogc3QsXG4gICAgICAgICAgICByZW1vdmVOb2RlUmFuZ2U6IG90LFxuICAgICAgICAgICAgbWVyZ2VPcHRpb25zOiBndCxcbiAgICAgICAgICAgIHJlc29sdmVBc3NldDogX3QsXG4gICAgICAgICAgICBhc3NlcnRBc3NldDogYnQsXG4gICAgICAgICAgICBjaGVja0NvbXBvbmVudEF0dHI6IGF0LFxuICAgICAgICAgICAgaW5pdFByb3A6IGx0LFxuICAgICAgICAgICAgYXNzZXJ0UHJvcDogY3QsXG4gICAgICAgICAgICBjb2VyY2VQcm9wOiB1dCxcbiAgICAgICAgICAgIGNvbW1vblRhZ1JFOiBjbixcbiAgICAgICAgICAgIHJlc2VydmVkVGFnUkU6IHVuLFxuICAgICAgICAgICAgd2FybjogaG5cbiAgICAgICAgfSksXG4gICAgICAgIGJuID0gMCxcbiAgICAgICAgeW4gPSBuZXcgJCgxZTMpLFxuICAgICAgICBDbiA9IDAsXG4gICAgICAgIHduID0gMSxcbiAgICAgICAgJG4gPSAyLFxuICAgICAgICBrbiA9IDMsXG4gICAgICAgIHhuID0gMCxcbiAgICAgICAgQW4gPSAxLFxuICAgICAgICBPbiA9IDIsXG4gICAgICAgIE5uID0gMyxcbiAgICAgICAgVG4gPSA0LFxuICAgICAgICBqbiA9IDUsXG4gICAgICAgIEVuID0gNixcbiAgICAgICAgU24gPSA3LFxuICAgICAgICBGbiA9IDgsXG4gICAgICAgIERuID0gW107XG4gICAgRG5beG5dID0ge1xuICAgICAgICB3czogW3huXSxcbiAgICAgICAgaWRlbnQ6IFtObiwgQ25dLFxuICAgICAgICBcIltcIjogW1RuXSxcbiAgICAgICAgZW9mOiBbU25dXG4gICAgfSwgRG5bQW5dID0ge1xuICAgICAgICB3czogW0FuXSxcbiAgICAgICAgXCIuXCI6IFtPbl0sXG4gICAgICAgIFwiW1wiOiBbVG5dLFxuICAgICAgICBlb2Y6IFtTbl1cbiAgICB9LCBEbltPbl0gPSB7XG4gICAgICAgIHdzOiBbT25dLFxuICAgICAgICBpZGVudDogW05uLCBDbl1cbiAgICB9LCBEbltObl0gPSB7XG4gICAgICAgIGlkZW50OiBbTm4sIENuXSxcbiAgICAgICAgMDogW05uLCBDbl0sXG4gICAgICAgIG51bWJlcjogW05uLCBDbl0sXG4gICAgICAgIHdzOiBbQW4sIHduXSxcbiAgICAgICAgXCIuXCI6IFtPbiwgd25dLFxuICAgICAgICBcIltcIjogW1RuLCB3bl0sXG4gICAgICAgIGVvZjogW1NuLCB3bl1cbiAgICB9LCBEbltUbl0gPSB7XG4gICAgICAgIFwiJ1wiOiBbam4sIENuXSxcbiAgICAgICAgJ1wiJzogW0VuLCBDbl0sXG4gICAgICAgIFwiW1wiOiBbVG4sICRuXSxcbiAgICAgICAgXCJdXCI6IFtBbiwga25dLFxuICAgICAgICBlb2Y6IEZuLFxuICAgICAgICBcImVsc2VcIjogW1RuLCBDbl1cbiAgICB9LCBEbltqbl0gPSB7XG4gICAgICAgIFwiJ1wiOiBbVG4sIENuXSxcbiAgICAgICAgZW9mOiBGbixcbiAgICAgICAgXCJlbHNlXCI6IFtqbiwgQ25dXG4gICAgfSwgRG5bRW5dID0ge1xuICAgICAgICAnXCInOiBbVG4sIENuXSxcbiAgICAgICAgZW9mOiBGbixcbiAgICAgICAgXCJlbHNlXCI6IFtFbiwgQ25dXG4gICAgfTtcbiAgICB2YXIgUG4gPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIHBhcnNlUGF0aDoganQsXG4gICAgICAgICAgICBnZXRQYXRoOiBFdCxcbiAgICAgICAgICAgIHNldFBhdGg6IFN0XG4gICAgICAgIH0pLFxuICAgICAgICBSbiA9IG5ldyAkKDFlMyksXG4gICAgICAgIEhuID0gXCJNYXRoLERhdGUsdGhpcyx0cnVlLGZhbHNlLG51bGwsdW5kZWZpbmVkLEluZmluaXR5LE5hTixpc05hTixpc0Zpbml0ZSxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQscGFyc2VJbnQscGFyc2VGbG9hdFwiLFxuICAgICAgICBMbiA9IG5ldyBSZWdFeHAoXCJeKFwiICsgSG4ucmVwbGFjZSgvLC9nLCBcIlxcXFxifFwiKSArIFwiXFxcXGIpXCIpLFxuICAgICAgICBXbiA9IFwiYnJlYWssY2FzZSxjbGFzcyxjYXRjaCxjb25zdCxjb250aW51ZSxkZWJ1Z2dlcixkZWZhdWx0LGRlbGV0ZSxkbyxlbHNlLGV4cG9ydCxleHRlbmRzLGZpbmFsbHksZm9yLGZ1bmN0aW9uLGlmLGltcG9ydCxpbixpbnN0YW5jZW9mLGxldCxyZXR1cm4sc3VwZXIsc3dpdGNoLHRocm93LHRyeSx2YXIsd2hpbGUsd2l0aCx5aWVsZCxlbnVtLGF3YWl0LGltcGxlbWVudHMscGFja2FnZSxwcm9jdGVjdGVkLHN0YXRpYyxpbnRlcmZhY2UscHJpdmF0ZSxwdWJsaWNcIixcbiAgICAgICAgQm4gPSBuZXcgUmVnRXhwKFwiXihcIiArIFduLnJlcGxhY2UoLywvZywgXCJcXFxcYnxcIikgKyBcIlxcXFxiKVwiKSxcbiAgICAgICAgVm4gPSAvXFxzL2csXG4gICAgICAgIE1uID0gL1xcbi9nLFxuICAgICAgICB6biA9IC9bXFx7LF1cXHMqW1xcd1xcJF9dK1xccyo6fCgnKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwiKXxuZXcgfHR5cGVvZiB8dm9pZCAvZyxcbiAgICAgICAgSW4gPSAvXCIoXFxkKylcIi9nLFxuICAgICAgICBVbiA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnLio/J1xcXXxcXFtcIi4qP1wiXFxdfFxcW1xcZCtcXF18XFxbW0EtWmEtel8kXVtcXHckXSpcXF0pKiQvLFxuICAgICAgICBxbiA9IC9bXlxcdyRcXC5dKD86W0EtWmEtel8kXVtcXHckXSopL2csXG4gICAgICAgIEpuID0gL14oPzp0cnVlfGZhbHNlKSQvLFxuICAgICAgICBRbiA9IFtdLFxuICAgICAgICBHbiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgcGFyc2VFeHByZXNzaW9uOiBXdCxcbiAgICAgICAgICAgIGlzU2ltcGxlUGF0aDogQnRcbiAgICAgICAgfSksXG4gICAgICAgIFpuID0gW10sXG4gICAgICAgIEtuID0gW10sXG4gICAgICAgIFhuID0ge30sXG4gICAgICAgIFluID0ge30sXG4gICAgICAgIHRyID0gITEsXG4gICAgICAgIGVyID0gITEsXG4gICAgICAgIGlyID0gMDtcbiAgICBVdC5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgZSA9IHQuaWQ7XG4gICAgICAgIHRoaXMubmV3RGVwc1tlXSB8fCAodGhpcy5uZXdEZXBzW2VdID0gdCwgdGhpcy5kZXBzW2VdIHx8ICh0aGlzLmRlcHNbZV0gPSB0LCB0LmFkZFN1Yih0aGlzKSkpXG4gICAgfSwgVXQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJlZm9yZUdldCgpO1xuICAgICAgICB2YXIgdCwgZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHQgPSB0aGlzLmdldHRlci5jYWxsKGUsIGUpXG4gICAgICAgIH0gY2F0Y2ggKGkpIHt9XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXAgJiYgcXQodCksIHRoaXMucHJlUHJvY2VzcyAmJiAodCA9IHRoaXMucHJlUHJvY2Vzcyh0KSksIHRoaXMuZmlsdGVycyAmJiAodCA9IGUuX2FwcGx5RmlsdGVycyh0LCBudWxsLCB0aGlzLmZpbHRlcnMsICExKSksIHRoaXMucG9zdFByb2Nlc3MgJiYgKHQgPSB0aGlzLnBvc3RQcm9jZXNzKHQpKSwgdGhpcy5hZnRlckdldCgpLCB0XG4gICAgfSwgVXQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLnNjb3BlIHx8IHRoaXMudm07XG4gICAgICAgIHRoaXMuZmlsdGVycyAmJiAodCA9IGUuX2FwcGx5RmlsdGVycyh0LCB0aGlzLnZhbHVlLCB0aGlzLmZpbHRlcnMsICEwKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNldHRlci5jYWxsKGUsIGUsIHQpXG4gICAgICAgIH0gY2F0Y2ggKGkpIHt9XG4gICAgICAgIHZhciBuID0gZS4kZm9yQ29udGV4dDtcbiAgICAgICAgaWYgKG4gJiYgbi5hbGlhcyA9PT0gdGhpcy5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAobi5maWx0ZXJzKSByZXR1cm47XG4gICAgICAgICAgICBuLl93aXRoTG9jayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBlLiRrZXkgPyBuLnJhd1ZhbHVlW2UuJGtleV0gPSB0IDogbi5yYXdWYWx1ZS4kc2V0KGUuJGluZGV4LCB0KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0sIFV0LnByb3RvdHlwZS5iZWZvcmVHZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgeXQudGFyZ2V0ID0gdGhpcywgdGhpcy5uZXdEZXBzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH0sIFV0LnByb3RvdHlwZS5hZnRlckdldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB5dC50YXJnZXQgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciB0ID0gT2JqZWN0LmtleXModGhpcy5kZXBzKSwgZSA9IHQubGVuZ3RoOyBlLS07KSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRbZV07XG4gICAgICAgICAgICB0aGlzLm5ld0RlcHNbaV0gfHwgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwc1xuICAgIH0sIFV0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHRoaXMubGF6eSA/IHRoaXMuZGlydHkgPSAhMCA6IHRoaXMuc3luYyB8fCAhYW4uYXN5bmMgPyB0aGlzLnJ1bigpIDogKHRoaXMuc2hhbGxvdyA9IHRoaXMucXVldWVkID8gdCA/IHRoaXMuc2hhbGxvdyA6ICExIDogISF0LCB0aGlzLnF1ZXVlZCA9ICEwLCBJdCh0aGlzKSlcbiAgICB9LCBVdC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmdldCgpO1xuICAgICAgICAgICAgaWYgKHQgIT09IHRoaXMudmFsdWUgfHwgKG0odCkgfHwgdGhpcy5kZWVwKSAmJiAhdGhpcy5zaGFsbG93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0LCB0aGlzLnByZXZFcnJvciwgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHQsIGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZCA9IHRoaXMuc2hhbGxvdyA9ICExXG4gICAgICAgIH1cbiAgICB9LCBVdC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHQgPSB5dC50YXJnZXQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpLCB0aGlzLmRpcnR5ID0gITEsIHl0LnRhcmdldCA9IHRcbiAgICB9LCBVdC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHQgPSBPYmplY3Qua2V5cyh0aGlzLmRlcHMpLCBlID0gdC5sZW5ndGg7IGUtLTspIHRoaXMuZGVwc1t0W2VdXS5kZXBlbmQoKVxuICAgIH0sIFV0LnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQgfHwgdGhpcy52bS5fd2F0Y2hlcnMuJHJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSBPYmplY3Qua2V5cyh0aGlzLmRlcHMpLCBlID0gdC5sZW5ndGg7IGUtLTspIHRoaXMuZGVwc1t0W2VdXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9ICExLCB0aGlzLnZtID0gdGhpcy5jYiA9IHRoaXMudmFsdWUgPSBudWxsXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBuciA9IHtcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5lbDtcbiAgICAgICAgICAgICAgICB0aGlzLnZtLiRvbmNlKFwiaG9vazpjb21waWxlZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5yZW1vdmVBdHRyaWJ1dGUoXCJ2LWNsb2FrXCIpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcnIgPSB7XG4gICAgICAgICAgICBiaW5kOiBmdW5jdGlvbigpIHt9XG4gICAgICAgIH0sXG4gICAgICAgIHNyID0ge1xuICAgICAgICAgICAgcHJpb3JpdHk6IDE1MDAsXG4gICAgICAgICAgICBiaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmlkID0gbCh0aGlzLmFyZyksXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRlbHM7XG4gICAgICAgICAgICAgICAgICAgIGkoZSwgdCkgPyBlW3RdID0gdGhpcy5lbCA6IHh0KGUsIHQsIHRoaXMuZWwpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuYmluZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJGVscztcbiAgICAgICAgICAgICAgICB0W3RoaXMuaWRdID09PSB0aGlzLmVsICYmICh0W3RoaXMuaWRdID0gbnVsbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3IgPSBbXCItd2Via2l0LVwiLCBcIi1tb3otXCIsIFwiLW1zLVwiXSxcbiAgICAgICAgYXIgPSBbXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiXSxcbiAgICAgICAgaHIgPSAvIWltcG9ydGFudDs/JC8sXG4gICAgICAgIGxyID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgY3IgPSBudWxsLFxuICAgICAgICB1ciA9IHtcbiAgICAgICAgICAgIGRlZXA6ICEwLFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCA/IHRoaXMuZWwuc3R5bGUuY3NzVGV4dCA9IHQgOiAkaSh0KSA/IHRoaXMuaGFuZGxlT2JqZWN0KHQucmVkdWNlKHYsIHt9KSkgOiB0aGlzLmhhbmRsZU9iamVjdCh0IHx8IHt9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZU9iamVjdDogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHZhciBlLCBpLCBuID0gdGhpcy5jYWNoZSB8fCAodGhpcy5jYWNoZSA9IHt9KTtcbiAgICAgICAgICAgICAgICBmb3IgKGUgaW4gbikgZSBpbiB0IHx8ICh0aGlzLmhhbmRsZVNpbmdsZShlLCBudWxsKSwgZGVsZXRlIG5bZV0pO1xuICAgICAgICAgICAgICAgIGZvciAoZSBpbiB0KSBpID0gdFtlXSwgaSAhPT0gbltlXSAmJiAobltlXSA9IGksIHRoaXMuaGFuZGxlU2luZ2xlKGUsIGkpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZVNpbmdsZTogZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgICAgIGlmICh0ID0gSnQodCkpXG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IGUgJiYgKGUgKz0gXCJcIiksIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gaHIudGVzdChlKSA/IFwiaW1wb3J0YW50XCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSAmJiAoZSA9IGUucmVwbGFjZShociwgXCJcIikudHJpbSgpKSwgdGhpcy5lbC5zdHlsZS5zZXRQcm9wZXJ0eSh0LCBlLCBpKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5lbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSh0KVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmciA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgICBwciA9IC9eeGxpbms6LyxcbiAgICAgICAgZHIgPSAvXnYtfF46fF5AfF4oaXN8dHJhbnNpdGlvbnx0cmFuc2l0aW9uLW1vZGV8ZGVib3VuY2V8dHJhY2stYnl8c3RhZ2dlcnxlbnRlci1zdGFnZ2VyfGxlYXZlLXN0YWdnZXIpJC8sXG4gICAgICAgIHZyID0gL14odmFsdWV8Y2hlY2tlZHxzZWxlY3RlZHxtdXRlZCkkLyxcbiAgICAgICAgbXIgPSB7XG4gICAgICAgICAgICB2YWx1ZTogXCJfdmFsdWVcIixcbiAgICAgICAgICAgIFwidHJ1ZS12YWx1ZVwiOiBcIl90cnVlVmFsdWVcIixcbiAgICAgICAgICAgIFwiZmFsc2UtdmFsdWVcIjogXCJfZmFsc2VWYWx1ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGdyID0ge1xuICAgICAgICAgICAgcHJpb3JpdHk6IDg1MCxcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5hcmcsXG4gICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgICAgICAgICAgICAgdCB8fCAodGhpcy5kZWVwID0gITApLCB0aGlzLmRlc2NyaXB0b3IuaW50ZXJwICYmIChkci50ZXN0KHQpIHx8IFwibmFtZVwiID09PSB0ICYmIChcIlBBUlRJQUxcIiA9PT0gZSB8fCBcIlNMT1RcIiA9PT0gZSkpICYmICh0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSh0KSwgdGhpcy5pbnZhbGlkID0gITApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmFyZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmcgPyB0aGlzLmhhbmRsZVNpbmdsZShlLCB0KSA6IHRoaXMuaGFuZGxlT2JqZWN0KHQgfHwge30pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZU9iamVjdDogdXIuaGFuZGxlT2JqZWN0LFxuICAgICAgICAgICAgaGFuZGxlU2luZ2xlOiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICAgICAgIXRoaXMuZGVzY3JpcHRvci5pbnRlcnAgJiYgdnIudGVzdCh0KSAmJiB0IGluIHRoaXMuZWwgJiYgKHRoaXMuZWxbdF0gPSBcInZhbHVlXCIgPT09IHQgJiYgbnVsbCA9PSBlID8gXCJcIiA6IGUpO1xuICAgICAgICAgICAgICAgIHZhciBpID0gbXJbdF07XG4gICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbFtpXSA9IGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5lbC5fX3ZfbW9kZWw7XG4gICAgICAgICAgICAgICAgICAgIG4gJiYgbi5saXN0ZW5lcigpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlXCIgPT09IHQgJiYgXCJURVhUQVJFQVwiID09PSB0aGlzLmVsLnRhZ05hbWUgPyB2b2lkIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKHQpIDogdm9pZChudWxsICE9IGUgJiYgZSAhPT0gITEgPyBwci50ZXN0KHQpID8gdGhpcy5lbC5zZXRBdHRyaWJ1dGVOUyhmciwgdCwgZSkgOiB0aGlzLmVsLnNldEF0dHJpYnV0ZSh0LCBlKSA6IHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKHQpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfciA9IHtcbiAgICAgICAgICAgIGVzYzogMjcsXG4gICAgICAgICAgICB0YWI6IDksXG4gICAgICAgICAgICBlbnRlcjogMTMsXG4gICAgICAgICAgICBzcGFjZTogMzIsXG4gICAgICAgICAgICBcImRlbGV0ZVwiOiA0NixcbiAgICAgICAgICAgIHVwOiAzOCxcbiAgICAgICAgICAgIGxlZnQ6IDM3LFxuICAgICAgICAgICAgcmlnaHQ6IDM5LFxuICAgICAgICAgICAgZG93bjogNDBcbiAgICAgICAgfSxcbiAgICAgICAgYnIgPSB7XG4gICAgICAgICAgICBhY2NlcHRTdGF0ZW1lbnQ6ICEwLFxuICAgICAgICAgICAgcHJpb3JpdHk6IDcwMCxcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChcIklGUkFNRVwiID09PSB0aGlzLmVsLnRhZ05hbWUgJiYgXCJsb2FkXCIgIT09IHRoaXMuYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZnJhbWVCaW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBRKHQuZWwuY29udGVudFdpbmRvdywgdC5hcmcsIHQuaGFuZGxlcilcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5vbihcImxvYWRcIiwgdGhpcy5pZnJhbWVCaW5kKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXNjcmlwdG9yLnJhdyB8fCAodCA9IGZ1bmN0aW9uKCkge30pLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMuc3RvcCAmJiAodCA9IFp0KHQpKSwgdGhpcy5tb2RpZmllcnMucHJldmVudCAmJiAodCA9IEt0KHQpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBPYmplY3Qua2V5cyh0aGlzLm1vZGlmaWVycykuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0b3BcIiAhPT0gdCAmJiBcInByZXZlbnRcIiAhPT0gdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZS5sZW5ndGggJiYgKHQgPSBHdCh0LCBlKSksIHRoaXMucmVzZXQoKSwgdGhpcy5oYW5kbGVyID0gdCwgdGhpcy5pZnJhbWVCaW5kID8gdGhpcy5pZnJhbWVCaW5kKCkgOiBRKHRoaXMuZWwsIHRoaXMuYXJnLCB0aGlzLmhhbmRsZXIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuaWZyYW1lQmluZCA/IHRoaXMuZWwuY29udGVudFdpbmRvdyA6IHRoaXMuZWw7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVyICYmIEcodCwgdGhpcy5hcmcsIHRoaXMuaGFuZGxlcilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5ciA9IHtcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gaS5jaGVja2VkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCAmJiBpLmhhc093blByb3BlcnR5KFwiX3RydWVWYWx1ZVwiKSA/IGkuX3RydWVWYWx1ZSA6ICF0ICYmIGkuaGFzT3duUHJvcGVydHkoXCJfZmFsc2VWYWx1ZVwiKSA/IGkuX2ZhbHNlVmFsdWUgOiB0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXMuZWw7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaS5oYXNPd25Qcm9wZXJ0eShcIl92YWx1ZVwiKSA/IGkuX3ZhbHVlIDogZS5wYXJhbXMubnVtYmVyID8gbyhpLnZhbHVlKSA6IGkudmFsdWVcbiAgICAgICAgICAgICAgICB9LCB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS5fd2F0Y2hlci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRpKG4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuY2hlY2tlZCA/IHkobiwgcikgPCAwICYmIG4ucHVzaChyKSA6IG4uJHJlbW92ZShyKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZS5zZXQodCgpKVxuICAgICAgICAgICAgICAgIH0sIHRoaXMub24oXCJjaGFuZ2VcIiwgdGhpcy5saXN0ZW5lciksIGkuaGFzQXR0cmlidXRlKFwiY2hlY2tlZFwiKSAmJiAodGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5lbDtcbiAgICAgICAgICAgICAgICAkaSh0KSA/IGUuY2hlY2tlZCA9IHkodCwgdGhpcy5nZXRWYWx1ZSgpKSA+IC0xIDogZS5oYXNPd25Qcm9wZXJ0eShcIl90cnVlVmFsdWVcIikgPyBlLmNoZWNrZWQgPSB3KHQsIGUuX3RydWVWYWx1ZSkgOiBlLmNoZWNrZWQgPSAhIXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgQ3IgPSB7XG4gICAgICAgICAgICBiaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmVsO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5fd2F0Y2hlciAmJiB0LnVwZGF0ZSh0Ll93YXRjaGVyLmdldCgpKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLm11bHRpcGxlID0gZS5oYXNBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gWHQoZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIG4gPSB0LnBhcmFtcy5udW1iZXIgPyAkaShuKSA/IG4ubWFwKG8pIDogbyhuKSA6IG4sIHQuc2V0KG4pXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5vbihcImNoYW5nZVwiLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IFh0KGUsIGksICEwKTtcbiAgICAgICAgICAgICAgICAoaSAmJiBuLmxlbmd0aCB8fCAhaSAmJiBudWxsICE9PSBuKSAmJiAodGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyKSwgdGhpcy52bS4kb24oXCJob29rOmF0dGFjaGVkXCIsIHRoaXMuZm9yY2VVcGRhdGUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmVsO1xuICAgICAgICAgICAgICAgIGUuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGksIG4sIHIgPSB0aGlzLm11bHRpcGxlICYmICRpKHQpLCBzID0gZS5vcHRpb25zLCBvID0gcy5sZW5ndGg7IG8tLTspIGkgPSBzW29dLCBuID0gaS5oYXNPd25Qcm9wZXJ0eShcIl92YWx1ZVwiKSA/IGkuX3ZhbHVlIDogaS52YWx1ZSwgaS5zZWxlY3RlZCA9IHIgPyBZdCh0LCBuKSA+IC0xIDogdyh0LCBuKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuYmluZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52bS4kb2ZmKFwiaG9vazphdHRhY2hlZFwiLCB0aGlzLmZvcmNlVXBkYXRlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3ciA9IHtcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuZWw7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5oYXNPd25Qcm9wZXJ0eShcIl92YWx1ZVwiKSkgcmV0dXJuIGUuX3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0LnBhcmFtcy5udW1iZXIgJiYgKGkgPSBvKGkpKSwgaVxuICAgICAgICAgICAgICAgIH0sIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5zZXQodC5nZXRWYWx1ZSgpKVxuICAgICAgICAgICAgICAgIH0sIHRoaXMub24oXCJjaGFuZ2VcIiwgdGhpcy5saXN0ZW5lciksIGUuaGFzQXR0cmlidXRlKFwiY2hlY2tlZFwiKSAmJiAodGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuY2hlY2tlZCA9IHcodCwgdGhpcy5nZXRWYWx1ZSgpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAkciA9IHtcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuZWwsXG4gICAgICAgICAgICAgICAgICAgIGkgPSBcInJhbmdlXCIgPT09IGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbiA9IHRoaXMucGFyYW1zLmxhenksXG4gICAgICAgICAgICAgICAgICAgIHIgPSB0aGlzLnBhcmFtcy5udW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHMgPSB0aGlzLnBhcmFtcy5kZWJvdW5jZSxcbiAgICAgICAgICAgICAgICAgICAgYSA9ICExO1xuICAgICAgICAgICAgICAgIE9pIHx8IGkgfHwgKHRoaXMub24oXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhID0gITBcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy5vbihcImNvbXBvc2l0aW9uZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhID0gITEsIG4gfHwgdC5saXN0ZW5lcigpXG4gICAgICAgICAgICAgICAgfSkpLCB0aGlzLmZvY3VzZWQgPSAhMSwgaSB8fCAodGhpcy5vbihcImZvY3VzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0LmZvY3VzZWQgPSAhMFxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLm9uKFwiYmx1clwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5mb2N1c2VkID0gITEsICghdC5fZnJhZyB8fCB0Ll9mcmFnLmluc2VydGVkKSAmJiB0LnJhd0xpc3RlbmVyKClcbiAgICAgICAgICAgICAgICB9KSksIHRoaXMubGlzdGVuZXIgPSB0aGlzLnJhd0xpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYSAmJiB0Ll9ib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSByIHx8IGkgPyBvKGUudmFsdWUpIDogZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuc2V0KG4pLCBEaShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Ll9ib3VuZCAmJiAhdC5mb2N1c2VkICYmIHQudXBkYXRlKHQuX3dhdGNoZXIudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgcyAmJiAodGhpcy5saXN0ZW5lciA9IGIodGhpcy5saXN0ZW5lciwgcykpLCB0aGlzLmhhc2pRdWVyeSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgalF1ZXJ5LCB0aGlzLmhhc2pRdWVyeSA/IChqUXVlcnkoZSkub24oXCJjaGFuZ2VcIiwgdGhpcy5saXN0ZW5lciksIG4gfHwgalF1ZXJ5KGUpLm9uKFwiaW5wdXRcIiwgdGhpcy5saXN0ZW5lcikpIDogKHRoaXMub24oXCJjaGFuZ2VcIiwgdGhpcy5saXN0ZW5lciksIG4gfHwgdGhpcy5vbihcImlucHV0XCIsIHRoaXMubGlzdGVuZXIpKSwgIW4gJiYgQWkgJiYgKHRoaXMub24oXCJjdXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIERpKHQubGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgfSksIHRoaXMub24oXCJrZXl1cFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICg0NiA9PT0gZS5rZXlDb2RlIHx8IDggPT09IGUua2V5Q29kZSkgJiYgdC5saXN0ZW5lcigpXG4gICAgICAgICAgICAgICAgfSkpLCAoZS5oYXNBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSB8fCBcIlRFWFRBUkVBXCIgPT09IGUudGFnTmFtZSAmJiBlLnZhbHVlLnRyaW0oKSkgJiYgKHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnZhbHVlID0gcyh0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuYmluZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmVsO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzalF1ZXJ5ICYmIChqUXVlcnkodCkub2ZmKFwiY2hhbmdlXCIsIHRoaXMubGlzdGVuZXIpLCBqUXVlcnkodCkub2ZmKFwiaW5wdXRcIiwgdGhpcy5saXN0ZW5lcikpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGtyID0ge1xuICAgICAgICAgICAgdGV4dDogJHIsXG4gICAgICAgICAgICByYWRpbzogd3IsXG4gICAgICAgICAgICBzZWxlY3Q6IENyLFxuICAgICAgICAgICAgY2hlY2tib3g6IHlyXG4gICAgICAgIH0sXG4gICAgICAgIHhyID0ge1xuICAgICAgICAgICAgcHJpb3JpdHk6IDgwMCxcbiAgICAgICAgICAgIHR3b1dheTogITAsXG4gICAgICAgICAgICBoYW5kbGVyczoga3IsXG4gICAgICAgICAgICBwYXJhbXM6IFtcImxhenlcIiwgXCJudW1iZXJcIiwgXCJkZWJvdW5jZVwiXSxcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tGaWx0ZXJzKCksIHRoaXMuaGFzUmVhZCAmJiAhdGhpcy5oYXNXcml0ZTtcbiAgICAgICAgICAgICAgICB2YXIgdCwgZSA9IHRoaXMuZWwsXG4gICAgICAgICAgICAgICAgICAgIGkgPSBlLnRhZ05hbWU7XG4gICAgICAgICAgICAgICAgaWYgKFwiSU5QVVRcIiA9PT0gaSkgdCA9IGtyW2UudHlwZV0gfHwga3IudGV4dDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcIlNFTEVDVFwiID09PSBpKSB0ID0ga3Iuc2VsZWN0O1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJURVhUQVJFQVwiICE9PSBpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHQgPSBrci50ZXh0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUuX192X21vZGVsID0gdGhpcywgdC5iaW5kLmNhbGwodGhpcyksIHRoaXMudXBkYXRlID0gdC51cGRhdGUsIHRoaXMuX3VuYmluZCA9IHQudW5iaW5kXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hlY2tGaWx0ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuZmlsdGVycztcbiAgICAgICAgICAgICAgICBpZiAodClcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IHQubGVuZ3RoOyBlLS07KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IF90KHRoaXMudm0uJG9wdGlvbnMsIFwiZmlsdGVyc1wiLCB0W2VdLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaSB8fCBpLnJlYWQpICYmICh0aGlzLmhhc1JlYWQgPSAhMCksIGkud3JpdGUgJiYgKHRoaXMuaGFzV3JpdGUgPSAhMClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuYmluZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5fX3ZfbW9kZWwgPSBudWxsLCB0aGlzLl91bmJpbmQgJiYgdGhpcy5fdW5iaW5kKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgQXIgPSB7XG4gICAgICAgICAgICBiaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHQgJiYgbnVsbCAhPT0gQih0LCBcInYtZWxzZVwiKSAmJiAodGhpcy5lbHNlRWwgPSB0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHkodGhpcy5lbCwgdCksIHRoaXMuZWxzZUVsICYmIHRoaXMuYXBwbHkodGhpcy5lbHNlRWwsICF0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGx5OiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5zdHlsZS5kaXNwbGF5ID0gZSA/IFwiXCIgOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBXKHQpID8gSCh0LCBlID8gMSA6IC0xLCBpLCB0aGlzLnZtKSA6IGkoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBPciA9IG5ldyAkKDFlMyksXG4gICAgICAgIE5yID0gbmV3ICQoMWUzKSxcbiAgICAgICAgVHIgPSB7XG4gICAgICAgICAgICBlZmF1bHQ6IFswLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIGxlZ2VuZDogWzEsIFwiPGZpZWxkc2V0PlwiLCBcIjwvZmllbGRzZXQ+XCJdLFxuICAgICAgICAgICAgdHI6IFsyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiXSxcbiAgICAgICAgICAgIGNvbDogWzIsIFwiPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCJdXG4gICAgICAgIH07XG4gICAgVHIudGQgPSBUci50aCA9IFszLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiXSwgVHIub3B0aW9uID0gVHIub3B0Z3JvdXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPicsIFwiPC9zZWxlY3Q+XCJdLCBUci50aGVhZCA9IFRyLnRib2R5ID0gVHIuY29sZ3JvdXAgPSBUci5jYXB0aW9uID0gVHIudGZvb3QgPSBbMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIl0sIFRyLmcgPSBUci5kZWZzID0gVHIuc3ltYm9sID0gVHIudXNlID0gVHIuaW1hZ2UgPSBUci50ZXh0ID0gVHIuY2lyY2xlID0gVHIuZWxsaXBzZSA9IFRyLmxpbmUgPSBUci5wYXRoID0gVHIucG9seWdvbiA9IFRyLnBvbHlsaW5lID0gVHIucmVjdCA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeG1sbnM6ZXY9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHNcInZlcnNpb249XCIxLjFcIj4nLCBcIjwvc3ZnPlwiXTtcbiAgICB2YXIganIgPSAvPChbXFx3Ol0rKS8sXG4gICAgICAgIEVyID0gLyYjP1xcdys/Oy8sXG4gICAgICAgIFNyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoeGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQuaW5uZXJIVE1MID0gXCI8dGVtcGxhdGU+MTwvdGVtcGxhdGU+XCIsICF0LmNsb25lTm9kZSghMCkuZmlyc3RDaGlsZC5pbm5lckhUTUxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhMVxuICAgICAgICB9KCksXG4gICAgICAgIEZyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoeGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdC5wbGFjZWhvbGRlciA9IFwidFwiLCBcInRcIiA9PT0gdC5jbG9uZU5vZGUoITApLnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gITFcbiAgICAgICAgfSgpLFxuICAgICAgICBEciA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgY2xvbmVOb2RlOiBuZSxcbiAgICAgICAgICAgIHBhcnNlVGVtcGxhdGU6IHJlXG4gICAgICAgIH0pO1xuICAgIHNlLnByb3RvdHlwZS5jYWxsSG9vayA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIGUsIGk7XG4gICAgICAgIGZvciAoZSA9IDAsIGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA+IGU7IGUrKykgdCh0aGlzLmNoaWxkcmVuW2VdKTtcbiAgICAgICAgZm9yIChlID0gMCwgaSA9IHRoaXMuY2hpbGRGcmFncy5sZW5ndGg7IGkgPiBlOyBlKyspIHRoaXMuY2hpbGRGcmFnc1tlXS5jYWxsSG9vayh0KVxuICAgIH0sIHNlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucGFyZW50RnJhZyAmJiB0aGlzLnBhcmVudEZyYWcuY2hpbGRGcmFncy4kcmVtb3ZlKHRoaXMpLCB0aGlzLnVubGluaygpXG4gICAgfTtcbiAgICB2YXIgUHIgPSBuZXcgJCg1ZTMpO1xuICAgIHBlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgICAgIHZhciBuID0gbmUodGhpcy50ZW1wbGF0ZSk7XG4gICAgICAgIHJldHVybiBuZXcgc2UodGhpcy5saW5rZXIsIHRoaXMudm0sIG4sIHQsIGUsIGkpXG4gICAgfTtcbiAgICB2YXIgUnIgPSB7XG4gICAgICAgICAgICBwcmlvcml0eTogMmUzLFxuICAgICAgICAgICAgYmluZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmVsO1xuICAgICAgICAgICAgICAgIGlmICh0Ll9fdnVlX18pIHRoaXMuaW52YWxpZCA9ICEwO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBlICYmIG51bGwgIT09IEIoZSwgXCJ2LWVsc2VcIikgJiYgKFUoZSksIHRoaXMuZWxzZUZhY3RvcnkgPSBuZXcgcGUodGhpcy52bSwgZSkpLCB0aGlzLmFuY2hvciA9IG50KFwidi1pZlwiKSwgSih0LCB0aGlzLmFuY2hvciksIHRoaXMuZmFjdG9yeSA9IG5ldyBwZSh0aGlzLnZtLCB0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludmFsaWQgfHwgKHQgPyB0aGlzLmZyYWcgfHwgdGhpcy5pbnNlcnQoKSA6IHRoaXMucmVtb3ZlKCkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5zZXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsc2VGcmFnICYmICh0aGlzLmVsc2VGcmFnLnJlbW92ZSgpLCB0aGlzLmVsc2VGcmFnID0gbnVsbCksIHRoaXMuZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUodGhpcy5faG9zdCwgdGhpcy5fc2NvcGUsIHRoaXMuX2ZyYWcpLCB0aGlzLmZyYWcuYmVmb3JlKHRoaXMuYW5jaG9yKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnICYmICh0aGlzLmZyYWcucmVtb3ZlKCksIHRoaXMuZnJhZyA9IG51bGwpLCB0aGlzLmVsc2VGYWN0b3J5ICYmICF0aGlzLmVsc2VGcmFnICYmICh0aGlzLmVsc2VGcmFnID0gdGhpcy5lbHNlRmFjdG9yeS5jcmVhdGUodGhpcy5faG9zdCwgdGhpcy5fc2NvcGUsIHRoaXMuX2ZyYWcpLCB0aGlzLmVsc2VGcmFnLmJlZm9yZSh0aGlzLmFuY2hvcikpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5iaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWcgJiYgdGhpcy5mcmFnLmRlc3Ryb3koKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBIciA9IDAsXG4gICAgICAgIExyID0ge1xuICAgICAgICAgICAgcHJpb3JpdHk6IDJlMyxcbiAgICAgICAgICAgIHBhcmFtczogW1widHJhY2stYnlcIiwgXCJzdGFnZ2VyXCIsIFwiZW50ZXItc3RhZ2dlclwiLCBcImxlYXZlLXN0YWdnZXJcIl0sXG4gICAgICAgICAgICBiaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuZXhwcmVzc2lvbi5tYXRjaCgvKC4qKSBpbiAoLiopLyk7XG4gICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0WzFdLm1hdGNoKC9cXCgoLiopLCguKilcXCkvKTtcbiAgICAgICAgICAgICAgICAgICAgZSA/ICh0aGlzLml0ZXJhdG9yID0gZVsxXS50cmltKCksIHRoaXMuYWxpYXMgPSBlWzJdLnRyaW0oKSkgOiB0aGlzLmFsaWFzID0gdFsxXS50cmltKCksIHRoaXMuZXhwcmVzc2lvbiA9IHRbMl1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZCA9IFwiX192LWZvcl9fXCIgKyArK0hyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMuZWwudGFnTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvbiA9IChcIk9QVElPTlwiID09PSBpIHx8IFwiT1BUR1JPVVBcIiA9PT0gaSkgJiYgXCJTRUxFQ1RcIiA9PT0gdGhpcy5lbC5wYXJlbnROb2RlLnRhZ05hbWUsIHRoaXMuc3RhcnQgPSBudChcInYtZm9yLXN0YXJ0XCIpLCB0aGlzLmVuZCA9IG50KFwidi1mb3ItZW5kXCIpLCBKKHRoaXMuZWwsIHRoaXMuZW5kKSwgeih0aGlzLnN0YXJ0LCB0aGlzLmVuZCksIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpLCB0aGlzLmZhY3RvcnkgPSBuZXcgcGUodGhpcy52bSwgdGhpcy5lbClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWZmKHQpLCB0aGlzLnVwZGF0ZVJlZigpLCB0aGlzLnVwZGF0ZU1vZGVsKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaWZmOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUsIG4sIHIsIHMsIG8sIGEsIGggPSB0WzBdLFxuICAgICAgICAgICAgICAgICAgICBsID0gdGhpcy5mcm9tT2JqZWN0ID0gbShoKSAmJiBpKGgsIFwiJGtleVwiKSAmJiBpKGgsIFwiJHZhbHVlXCIpLFxuICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5wYXJhbXMudHJhY2tCeSxcbiAgICAgICAgICAgICAgICAgICAgdSA9IHRoaXMuZnJhZ3MsXG4gICAgICAgICAgICAgICAgICAgIGYgPSB0aGlzLmZyYWdzID0gbmV3IEFycmF5KHQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuYWxpYXMsXG4gICAgICAgICAgICAgICAgICAgIGQgPSB0aGlzLml0ZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZyA9IHRoaXMuZW5kLFxuICAgICAgICAgICAgICAgICAgICBfID0gVyh2KSxcbiAgICAgICAgICAgICAgICAgICAgYiA9ICF1O1xuICAgICAgICAgICAgICAgIGZvciAoZSA9IDAsIG4gPSB0Lmxlbmd0aDsgbiA+IGU7IGUrKykgaCA9IHRbZV0sIHMgPSBsID8gaC4ka2V5IDogbnVsbCwgbyA9IGwgPyBoLiR2YWx1ZSA6IGgsIGEgPSAhbShvKSwgciA9ICFiICYmIHRoaXMuZ2V0Q2FjaGVkRnJhZyhvLCBlLCBzKSwgciA/IChyLnJldXNlZCA9ICEwLCByLnNjb3BlLiRpbmRleCA9IGUsIHMgJiYgKHIuc2NvcGUuJGtleSA9IHMpLCBkICYmIChyLnNjb3BlW2RdID0gbnVsbCAhPT0gcyA/IHMgOiBlKSwgKGMgfHwgbCB8fCBhKSAmJiAoci5zY29wZVtwXSA9IG8pKSA6IChyID0gdGhpcy5jcmVhdGUobywgcCwgZSwgcyksIHIuZnJlc2ggPSAhYiksIGZbZV0gPSByLCBiICYmIHIuYmVmb3JlKGcpO1xuICAgICAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBDID0gdS5sZW5ndGggLSBmLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChlID0gMCwgbiA9IHUubGVuZ3RoOyBuID4gZTsgZSsrKSByID0gdVtlXSwgci5yZXVzZWQgfHwgKHRoaXMuZGVsZXRlQ2FjaGVkRnJhZyhyKSwgdGhpcy5yZW1vdmUociwgeSsrLCBDLCBfKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3LCAkLCBrLCB4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChlID0gMCwgbiA9IGYubGVuZ3RoOyBuID4gZTsgZSsrKSByID0gZltlXSwgdyA9IGZbZSAtIDFdLCAkID0gdyA/IHcuc3RhZ2dlckNiID8gdy5zdGFnZ2VyQW5jaG9yIDogdy5lbmQgfHwgdy5ub2RlIDogdiwgci5yZXVzZWQgJiYgIXIuc3RhZ2dlckNiID8gKGsgPSBkZShyLCB2LCB0aGlzLmlkKSwgayA9PT0gdyB8fCBrICYmIGRlKGssIHYsIHRoaXMuaWQpID09PSB3IHx8IHRoaXMubW92ZShyLCAkKSkgOiB0aGlzLmluc2VydChyLCB4KyssICQsIF8pLCByLnJldXNlZCA9IHIuZnJlc2ggPSAhMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uKHQsIGUsIGksIG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuX2hvc3QsXG4gICAgICAgICAgICAgICAgICAgIHMgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtLFxuICAgICAgICAgICAgICAgICAgICBvID0gT2JqZWN0LmNyZWF0ZShzKTtcbiAgICAgICAgICAgICAgICBvLiRyZWZzID0gT2JqZWN0LmNyZWF0ZShzLiRyZWZzKSwgby4kZWxzID0gT2JqZWN0LmNyZWF0ZShzLiRlbHMpLCBvLiRwYXJlbnQgPSBzLCBvLiRmb3JDb250ZXh0ID0gdGhpcywgeHQobywgZSwgdCksIHh0KG8sIFwiJGluZGV4XCIsIGkpLCBuID8geHQobywgXCIka2V5XCIsIG4pIDogby4ka2V5ICYmIF8obywgXCIka2V5XCIsIG51bGwpLCB0aGlzLml0ZXJhdG9yICYmIHh0KG8sIHRoaXMuaXRlcmF0b3IsIG51bGwgIT09IG4gPyBuIDogaSk7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKHIsIG8sIHRoaXMuX2ZyYWcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmZvcklkID0gdGhpcy5pZCwgdGhpcy5jYWNoZUZyYWcodCwgYSwgaSwgbiksIGFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVSZWY6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5kZXNjcmlwdG9yLnJlZjtcbiAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSwgaSA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kcmVmcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcm9tT2JqZWN0ID8gKGUgPSB7fSwgdGhpcy5mcmFncy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVbdC5zY29wZS4ka2V5XSA9IHZlKHQpXG4gICAgICAgICAgICAgICAgICAgIH0pKSA6IGUgPSB0aGlzLmZyYWdzLm1hcCh2ZSksIGlbdF0gPSBlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZU1vZGVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuc3RhcnQucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0ICYmIHQuX192X21vZGVsO1xuICAgICAgICAgICAgICAgICAgICBlICYmIGUuZm9yY2VVcGRhdGUoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uKHQsIGUsIGksIG4pIHtcbiAgICAgICAgICAgICAgICB0LnN0YWdnZXJDYiAmJiAodC5zdGFnZ2VyQ2IuY2FuY2VsKCksIHQuc3RhZ2dlckNiID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmdldFN0YWdnZXIodCwgZSwgbnVsbCwgXCJlbnRlclwiKTtcbiAgICAgICAgICAgICAgICBpZiAobiAmJiByKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gdC5zdGFnZ2VyQW5jaG9yO1xuICAgICAgICAgICAgICAgICAgICBzIHx8IChzID0gdC5zdGFnZ2VyQW5jaG9yID0gbnQoXCJzdGFnZ2VyLWFuY2hvclwiKSwgcy5fX3ZmcmFnX18gPSB0KSwgSShzLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0LnN0YWdnZXJDYiA9IEMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnN0YWdnZXJDYiA9IG51bGwsIHQuYmVmb3JlKHMpLCBVKHMpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KG8sIHIpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHQuYmVmb3JlKGkubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbih0LCBlLCBpLCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHQuc3RhZ2dlckNiKSByZXR1cm4gdC5zdGFnZ2VyQ2IuY2FuY2VsKCksIHZvaWQodC5zdGFnZ2VyQ2IgPSBudWxsKTtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuZ2V0U3RhZ2dlcih0LCBlLCBpLCBcImxlYXZlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChuICYmIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB0LnN0YWdnZXJDYiA9IEMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnN0YWdnZXJDYiA9IG51bGwsIHQucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocywgcilcbiAgICAgICAgICAgICAgICB9IGVsc2UgdC5yZW1vdmUoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdmU6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgICAgICB0LmJlZm9yZShlLm5leHRTaWJsaW5nLCAhMSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWNoZUZyYWc6IGZ1bmN0aW9uKHQsIGUsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcywgbyA9IHRoaXMucGFyYW1zLnRyYWNrQnksXG4gICAgICAgICAgICAgICAgICAgIGEgPSB0aGlzLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBoID0gIW0odCk7XG4gICAgICAgICAgICAgICAgciB8fCBvIHx8IGggPyAocyA9IG8gPyBcIiRpbmRleFwiID09PSBvID8gbiA6IHRbb10gOiByIHx8IHQsIGFbc10gfHwgKGFbc10gPSBlKSkgOiAocyA9IHRoaXMuaWQsIGkodCwgcykgPyBudWxsID09PSB0W3NdICYmICh0W3NdID0gZSkgOiBfKHQsIHMsIGUpKSwgZS5yYXcgPSB0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q2FjaGVkRnJhZzogZnVuY3Rpb24odCwgZSwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBuLCByID0gdGhpcy5wYXJhbXMudHJhY2tCeSxcbiAgICAgICAgICAgICAgICAgICAgcyA9ICFtKHQpO1xuICAgICAgICAgICAgICAgIGlmIChpIHx8IHIgfHwgcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHIgPyBcIiRpbmRleFwiID09PSByID8gZSA6IHRbcl0gOiBpIHx8IHQ7XG4gICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzLmNhY2hlW29dXG4gICAgICAgICAgICAgICAgfSBlbHNlIG4gPSB0W3RoaXMuaWRdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuICYmIChuLnJldXNlZCB8fCBuLmZyZXNoKSwgblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlbGV0ZUNhY2hlZEZyYWc6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHQucmF3LFxuICAgICAgICAgICAgICAgICAgICBuID0gdGhpcy5wYXJhbXMudHJhY2tCeSxcbiAgICAgICAgICAgICAgICAgICAgciA9IHQuc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgIHMgPSByLiRpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbyA9IGkociwgXCIka2V5XCIpICYmIHIuJGtleSxcbiAgICAgICAgICAgICAgICAgICAgYSA9ICFtKGUpO1xuICAgICAgICAgICAgICAgIGlmIChuIHx8IG8gfHwgYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IG4gPyBcIiRpbmRleFwiID09PSBuID8gcyA6IGVbbl0gOiBvIHx8IGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVbaF0gPSBudWxsXG4gICAgICAgICAgICAgICAgfSBlbHNlIGVbdGhpcy5pZF0gPSBudWxsLCB0LnJhdyA9IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRTdGFnZ2VyOiBmdW5jdGlvbih0LCBlLCBpLCBuKSB7XG4gICAgICAgICAgICAgICAgbiArPSBcIlN0YWdnZXJcIjtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHQubm9kZS5fX3ZfdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgIHMgPSByICYmIHIuaG9va3MsXG4gICAgICAgICAgICAgICAgICAgIG8gPSBzICYmIChzW25dIHx8IHMuc3RhZ2dlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG8gPyBvLmNhbGwodCwgZSwgaSkgOiBlICogcGFyc2VJbnQodGhpcy5wYXJhbXNbbl0gfHwgdGhpcy5wYXJhbXMuc3RhZ2dlciwgMTApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ByZVByb2Nlc3M6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yYXdWYWx1ZSA9IHQsIHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcG9zdFByb2Nlc3M6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoJGkodCkpIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIGlmIChnKHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUsIGkgPSBPYmplY3Qua2V5cyh0KSwgbiA9IGkubGVuZ3RoLCByID0gbmV3IEFycmF5KG4pOyBuLS07KSBlID0gaVtuXSwgcltuXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRrZXk6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAkdmFsdWU6IHRbZV1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgJiYgKHQgPSBtZSh0KSksIHQgfHwgW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc2NyaXB0b3IucmVmICYmICgodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHJlZnNbdGhpcy5kZXNjcmlwdG9yLnJlZl0gPSBudWxsKSwgdGhpcy5mcmFncylcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCwgZSA9IHRoaXMuZnJhZ3MubGVuZ3RoOyBlLS07KSB0ID0gdGhpcy5mcmFnc1tlXSwgdGhpcy5kZWxldGVDYWNoZWRGcmFnKHQpLCB0LmRlc3Ryb3koKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBXciA9IHtcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIDggPT09IHRoaXMuZWwubm9kZVR5cGUgJiYgKHRoaXMubm9kZXMgPSBbXSwgdGhpcy5hbmNob3IgPSBudChcInYtaHRtbFwiKSwgSih0aGlzLmVsLCB0aGlzLmFuY2hvcikpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdCA9IHModCksIHRoaXMubm9kZXMgPyB0aGlzLnN3YXAodCkgOiB0aGlzLmVsLmlubmVySFRNTCA9IHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzd2FwOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMubm9kZXMubGVuZ3RoOyBlLS07KSBVKHRoaXMubm9kZXNbZV0pO1xuICAgICAgICAgICAgICAgIHZhciBpID0gcmUodCwgITAsICEwKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzID0gZChpLmNoaWxkTm9kZXMpLCB6KGksIHRoaXMuYW5jaG9yKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBCciA9IHtcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0ciA9IDMgPT09IHRoaXMuZWwubm9kZVR5cGUgPyBcImRhdGFcIiA6IFwidGV4dENvbnRlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxbdGhpcy5hdHRyXSA9IHModClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgVnIgPSB7XG4gICAgICAgICAgICB0ZXh0OiBCcixcbiAgICAgICAgICAgIGh0bWw6IFdyLFxuICAgICAgICAgICAgXCJmb3JcIjogTHIsXG4gICAgICAgICAgICBcImlmXCI6IFJyLFxuICAgICAgICAgICAgc2hvdzogQXIsXG4gICAgICAgICAgICBtb2RlbDogeHIsXG4gICAgICAgICAgICBvbjogYnIsXG4gICAgICAgICAgICBiaW5kOiBncixcbiAgICAgICAgICAgIGVsOiBzcixcbiAgICAgICAgICAgIHJlZjogcnIsXG4gICAgICAgICAgICBjbG9hazogbnJcbiAgICAgICAgfSxcbiAgICAgICAgTXIgPSBbXSxcbiAgICAgICAgenIgPSAhMSxcbiAgICAgICAgSXIgPSAxLFxuICAgICAgICBVciA9IDIsXG4gICAgICAgIHFyID0gTmkgKyBcIkR1cmF0aW9uXCIsXG4gICAgICAgIEpyID0gamkgKyBcIkR1cmF0aW9uXCIsXG4gICAgICAgIFFyID0gYmUucHJvdG90eXBlO1xuICAgIFFyLmVudGVyID0gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICB0aGlzLmNhbmNlbFBlbmRpbmcoKSwgdGhpcy5jYWxsSG9vayhcImJlZm9yZUVudGVyXCIpLCB0aGlzLmNiID0gZSwgSyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpLCB0KCksIHRoaXMuZW50ZXJlZCA9ICExLCB0aGlzLmNhbGxIb29rV2l0aENiKFwiZW50ZXJcIiksIHRoaXMuZW50ZXJlZCB8fCAodGhpcy5jYW5jZWwgPSB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MuZW50ZXJDYW5jZWxsZWQsIGdlKHRoaXMuZW50ZXJOZXh0VGljaykpXG4gICAgfSwgUXIuZW50ZXJOZXh0VGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmp1c3RFbnRlcmVkID0gITA7XG4gICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHQuanVzdEVudGVyZWQgPSAhMVxuICAgICAgICB9LCAxNyk7XG4gICAgICAgIHZhciBlID0gdGhpcy5lbnRlckRvbmUsXG4gICAgICAgICAgICBpID0gdGhpcy5nZXRDc3NUcmFuc2l0aW9uVHlwZSh0aGlzLmVudGVyQ2xhc3MpO1xuICAgICAgICB0aGlzLnBlbmRpbmdKc0NiID8gaSA9PT0gSXIgJiYgWCh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpIDogaSA9PT0gSXIgPyAoWCh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpLCB0aGlzLnNldHVwQ3NzQ2IoVGksIGUpKSA6IGkgPT09IFVyID8gdGhpcy5zZXR1cENzc0NiKEVpLCBlKSA6IGUoKVxuICAgIH0sIFFyLmVudGVyRG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVudGVyZWQgPSAhMCwgdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbCwgWCh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpLCB0aGlzLmNhbGxIb29rKFwiYWZ0ZXJFbnRlclwiKSwgdGhpcy5jYiAmJiB0aGlzLmNiKClcbiAgICB9LCBRci5sZWF2ZSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxQZW5kaW5nKCksIHRoaXMuY2FsbEhvb2soXCJiZWZvcmVMZWF2ZVwiKSwgdGhpcy5vcCA9IHQsIHRoaXMuY2IgPSBlLCBLKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcyksIHRoaXMubGVmdCA9ICExLCB0aGlzLmNhbGxIb29rV2l0aENiKFwibGVhdmVcIiksIHRoaXMubGVmdCB8fCAodGhpcy5jYW5jZWwgPSB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MubGVhdmVDYW5jZWxsZWQsIHRoaXMub3AgJiYgIXRoaXMucGVuZGluZ0pzQ2IgJiYgKHRoaXMuanVzdEVudGVyZWQgPyB0aGlzLmxlYXZlRG9uZSgpIDogZ2UodGhpcy5sZWF2ZU5leHRUaWNrKSkpXG4gICAgfSwgUXIubGVhdmVOZXh0VGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuZ2V0Q3NzVHJhbnNpdGlvblR5cGUodGhpcy5sZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdCA9PT0gSXIgPyBUaSA6IEVpO1xuICAgICAgICAgICAgdGhpcy5zZXR1cENzc0NiKGUsIHRoaXMubGVhdmVEb25lKVxuICAgICAgICB9IGVsc2UgdGhpcy5sZWF2ZURvbmUoKVxuICAgIH0sIFFyLmxlYXZlRG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxlZnQgPSAhMCwgdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbCwgdGhpcy5vcCgpLCBYKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcyksIHRoaXMuY2FsbEhvb2soXCJhZnRlckxlYXZlXCIpLCB0aGlzLmNiICYmIHRoaXMuY2IoKSwgdGhpcy5vcCA9IG51bGxcbiAgICB9LCBRci5jYW5jZWxQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3AgPSB0aGlzLmNiID0gbnVsbDtcbiAgICAgICAgdmFyIHQgPSAhMTtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ3NzQ2IgJiYgKHQgPSAhMCwgRyh0aGlzLmVsLCB0aGlzLnBlbmRpbmdDc3NFdmVudCwgdGhpcy5wZW5kaW5nQ3NzQ2IpLCB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gbnVsbCksIHRoaXMucGVuZGluZ0pzQ2IgJiYgKHQgPSAhMCwgdGhpcy5wZW5kaW5nSnNDYi5jYW5jZWwoKSwgdGhpcy5wZW5kaW5nSnNDYiA9IG51bGwpLCB0ICYmIChYKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyksIFgodGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKSksIHRoaXMuY2FuY2VsICYmICh0aGlzLmNhbmNlbC5jYWxsKHRoaXMudm0sIHRoaXMuZWwpLCB0aGlzLmNhbmNlbCA9IG51bGwpXG4gICAgfSwgUXIuY2FsbEhvb2sgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0XSAmJiB0aGlzLmhvb2tzW3RdLmNhbGwodGhpcy52bSwgdGhpcy5lbClcbiAgICB9LCBRci5jYWxsSG9va1dpdGhDYiA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3NbdF07XG4gICAgICAgIGUgJiYgKGUubGVuZ3RoID4gMSAmJiAodGhpcy5wZW5kaW5nSnNDYiA9IEModGhpc1t0ICsgXCJEb25lXCJdKSksIGUuY2FsbCh0aGlzLnZtLCB0aGlzLmVsLCB0aGlzLnBlbmRpbmdKc0NiKSlcbiAgICB9LCBRci5nZXRDc3NUcmFuc2l0aW9uVHlwZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCEoIVRpIHx8IGRvY3VtZW50LmhpZGRlbiB8fCB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MuY3NzID09PSAhMSB8fCB5ZSh0aGlzLmVsKSkpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy50eXBlQ2FjaGVbdF07XG4gICAgICAgICAgICBpZiAoZSkgcmV0dXJuIGU7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuZWwuc3R5bGUsXG4gICAgICAgICAgICAgICAgbiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpLFxuICAgICAgICAgICAgICAgIHIgPSBpW3FyXSB8fCBuW3FyXTtcbiAgICAgICAgICAgIGlmIChyICYmIFwiMHNcIiAhPT0gcikgZSA9IElyO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBpW0pyXSB8fCBuW0pyXTtcbiAgICAgICAgICAgICAgICBzICYmIFwiMHNcIiAhPT0gcyAmJiAoZSA9IFVyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGUgJiYgKHRoaXMudHlwZUNhY2hlW3RdID0gZSksIGVcbiAgICAgICAgfVxuICAgIH0sIFFyLnNldHVwQ3NzQ2IgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID0gdDtcbiAgICAgICAgdmFyIGkgPSB0aGlzLFxuICAgICAgICAgICAgbiA9IHRoaXMuZWwsXG4gICAgICAgICAgICByID0gdGhpcy5wZW5kaW5nQ3NzQ2IgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgcy50YXJnZXQgPT09IG4gJiYgKEcobiwgdCwgciksIGkucGVuZGluZ0Nzc0V2ZW50ID0gaS5wZW5kaW5nQ3NzQ2IgPSBudWxsLCAhaS5wZW5kaW5nSnNDYiAmJiBlICYmIGUoKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIFEobiwgdCwgcilcbiAgICB9O1xuICAgIHZhciBHciA9IHtcbiAgICAgICAgICAgIHByaW9yaXR5OiAxMTAwLFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmVsLFxuICAgICAgICAgICAgICAgICAgICBuID0gX3QodGhpcy52bS4kb3B0aW9ucywgXCJ0cmFuc2l0aW9uc1wiLCB0KTtcbiAgICAgICAgICAgICAgICB0ID0gdCB8fCBcInZcIiwgaS5fX3ZfdHJhbnMgPSBuZXcgYmUoaSwgdCwgbiwgdGhpcy5lbC5fX3Z1ZV9fIHx8IHRoaXMudm0pLCBlICYmIFgoaSwgZSArIFwiLXRyYW5zaXRpb25cIiksIEsoaSwgdCArIFwiLXRyYW5zaXRpb25cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgWnIgPSBhbi5fcHJvcEJpbmRpbmdNb2RlcyxcbiAgICAgICAgS3IgPSB7XG4gICAgICAgICAgICBiaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMudm0sXG4gICAgICAgICAgICAgICAgICAgIGUgPSB0Ll9jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy5kZXNjcmlwdG9yLnByb3AsXG4gICAgICAgICAgICAgICAgICAgIG4gPSBpLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHIgPSBpLnBhcmVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHMgPSBpLm1vZGUgPT09IFpyLlRXT19XQVksXG4gICAgICAgICAgICAgICAgICAgIG8gPSB0aGlzLnBhcmVudFdhdGNoZXIgPSBuZXcgVXQoZSwgciwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHV0KGksIGUpLCBjdChpLCBlKSAmJiAodFtuXSA9IGUpXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3b1dheTogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcnM6IGkuZmlsdGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiB0aGlzLl9zY29wZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobHQodCwgaSwgby52YWx1ZSksIHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0LiRvbmNlKFwiaG9vazpjcmVhdGVkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5jaGlsZFdhdGNoZXIgPSBuZXcgVXQodCwgbiwgZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uc2V0KHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luYzogITBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuYmluZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRXYXRjaGVyLnRlYXJkb3duKCksIHRoaXMuY2hpbGRXYXRjaGVyICYmIHRoaXMuY2hpbGRXYXRjaGVyLnRlYXJkb3duKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgWHIgPSB7XG4gICAgICAgICAgICBwcmlvcml0eTogMTUwMCxcbiAgICAgICAgICAgIHBhcmFtczogW1wia2VlcC1hbGl2ZVwiLCBcInRyYW5zaXRpb24tbW9kZVwiLCBcImlubGluZS10ZW1wbGF0ZVwiXSxcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuX192dWVfXyB8fCAodGhpcy5rZWVwQWxpdmUgPSB0aGlzLnBhcmFtcy5rZWVwQWxpdmUsIHRoaXMua2VlcEFsaXZlICYmICh0aGlzLmNhY2hlID0ge30pLCB0aGlzLnBhcmFtcy5pbmxpbmVUZW1wbGF0ZSAmJiAodGhpcy5pbmxpbmVUZW1wbGF0ZSA9IFkodGhpcy5lbCwgITApKSwgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSB0aGlzLkNvbXBvbmVudCA9IG51bGwsIHRoaXMucGVuZGluZ1JlbW92YWxzID0gMCwgdGhpcy5wZW5kaW5nUmVtb3ZhbENiID0gbnVsbCwgdGhpcy5hbmNob3IgPSBudChcInYtY29tcG9uZW50XCIpLCBKKHRoaXMuZWwsIHRoaXMuYW5jaG9yKSwgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoXCJpc1wiKSwgdGhpcy5kZXNjcmlwdG9yLnJlZiAmJiB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShcInYtcmVmOlwiICsgdSh0aGlzLmRlc2NyaXB0b3IucmVmKSksIHRoaXMubGl0ZXJhbCAmJiB0aGlzLnNldENvbXBvbmVudCh0aGlzLmV4cHJlc3Npb24pKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGl0ZXJhbCB8fCB0aGlzLnNldENvbXBvbmVudCh0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldENvbXBvbmVudDogZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmludmFsaWRhdGVQZW5kaW5nKCksIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVDb21wb25lbnQodCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLm1vdW50Q29tcG9uZW50KGUpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMudW5idWlsZCghMCksIHRoaXMucmVtb3ZlKHRoaXMuY2hpbGRWTSwgZSksIHRoaXMuY2hpbGRWTSA9IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNvbHZlQ29tcG9uZW50OiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiID0gQyhmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgICAgIGkuQ29tcG9uZW50TmFtZSA9IG4ub3B0aW9ucy5uYW1lIHx8IHQsIGkuQ29tcG9uZW50ID0gbiwgZSgpXG4gICAgICAgICAgICAgICAgfSksIHRoaXMudm0uX3Jlc29sdmVDb21wb25lbnQodCwgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuYnVpbGQoITApO1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXMuQ29tcG9uZW50Lm9wdGlvbnMuYWN0aXZhdGUsXG4gICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzLmdldENhY2hlZCgpLFxuICAgICAgICAgICAgICAgICAgICByID0gdGhpcy5idWlsZCgpO1xuICAgICAgICAgICAgICAgIGkgJiYgIW4gPyAodGhpcy53YWl0aW5nRm9yID0gciwgaS5jYWxsKHIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBlLndhaXRpbmdGb3IgPT09IHIgJiYgKGUud2FpdGluZ0ZvciA9IG51bGwsIGUudHJhbnNpdGlvbihyLCB0KSlcbiAgICAgICAgICAgICAgICB9KSkgOiAobiAmJiByLl91cGRhdGVSZWYoKSwgdGhpcy50cmFuc2l0aW9uKHIsIHQpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGludmFsaWRhdGVQZW5kaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiAmJiAodGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IuY2FuY2VsKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiID0gbnVsbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5nZXRDYWNoZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZSkgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5Db21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWw6IG5lKHRoaXMuZWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMuaW5saW5lVGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMuX2hvc3QgfHwgdGhpcy52bSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5rZXJDYWNoYWJsZTogIXRoaXMuaW5saW5lVGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmOiB0aGlzLmRlc2NyaXB0b3IucmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2FzQ29tcG9uZW50OiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pc1JvdXRlclZpZXc6IHRoaXMuX2lzUm91dGVyVmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OiB0aGlzLnZtLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njb3BlOiB0aGlzLl9zY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mcmFnOiB0aGlzLl9mcmFnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHQgJiYgdihpLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBuZXcgdGhpcy5Db21wb25lbnQoaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmtlZXBBbGl2ZSAmJiAodGhpcy5jYWNoZVt0aGlzLkNvbXBvbmVudC5jaWRdID0gbiksIG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q2FjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5rZWVwQWxpdmUgJiYgdGhpcy5jYWNoZVt0aGlzLkNvbXBvbmVudC5jaWRdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5idWlsZDogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2FpdGluZ0ZvciAmJiAodGhpcy53YWl0aW5nRm9yLiRkZXN0cm95KCksIHRoaXMud2FpdGluZ0ZvciA9IG51bGwpO1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5jaGlsZFZNO1xuICAgICAgICAgICAgICAgIHJldHVybiAhZSB8fCB0aGlzLmtlZXBBbGl2ZSA/IHZvaWQoZSAmJiBlLl91cGRhdGVSZWYoITApKSA6IHZvaWQgZS4kZGVzdHJveSghMSwgdClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMua2VlcEFsaXZlO1xuICAgICAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxzKyssIHRoaXMucGVuZGluZ1JlbW92YWxDYiA9IGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdC4kcmVtb3ZlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbi5wZW5kaW5nUmVtb3ZhbHMtLSwgaSB8fCB0Ll9jbGVhbnVwKCksICFuLnBlbmRpbmdSZW1vdmFscyAmJiBuLnBlbmRpbmdSZW1vdmFsQ2IgJiYgKG4ucGVuZGluZ1JlbW92YWxDYigpLCBuLnBlbmRpbmdSZW1vdmFsQ2IgPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSBlICYmIGUoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzLmNoaWxkVk07XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmNoaWxkVk0gPSB0LCBpLnBhcmFtcy50cmFuc2l0aW9uTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW4tb3V0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0LiRiZWZvcmUoaS5hbmNob3IsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkucmVtb3ZlKG4sIGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3V0LWluXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpLnJlbW92ZShuLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LiRiZWZvcmUoaS5hbmNob3IsIGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaS5yZW1vdmUobiksIHQuJGJlZm9yZShpLmFuY2hvciwgZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5iaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnZhbGlkYXRlUGVuZGluZygpLCB0aGlzLnVuYnVpbGQoKSwgdGhpcy5jYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMuY2FjaGUpIHRoaXMuY2FjaGVbdF0uJGRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZSA9IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFlyID0ge1xuICAgICAgICAgICAgZGVlcDogITAsXG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB0ICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgPyB0aGlzLmhhbmRsZU9iamVjdChDZSh0KSkgOiBnKHQpID8gdGhpcy5oYW5kbGVPYmplY3QodCkgOiAkaSh0KSA/IHRoaXMuaGFuZGxlQXJyYXkodCkgOiB0aGlzLmNsZWFudXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZU9iamVjdDogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cCh0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gdGhpcy5wcmV2S2V5cyA9IE9iamVjdC5rZXlzKHQpLCBpID0gMCwgbiA9IGUubGVuZ3RoOyBuID4gaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgdFtyXSA/IEsodGhpcy5lbCwgcikgOiBYKHRoaXMuZWwsIHIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZUFycmF5OiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwKHQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSAwLCBpID0gdC5sZW5ndGg7IGkgPiBlOyBlKyspIHRbZV0gJiYgSyh0aGlzLmVsLCB0W2VdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZLZXlzID0gdC5zbGljZSgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYW51cDogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXZLZXlzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gdGhpcy5wcmV2S2V5cy5sZW5ndGg7IGUtLTspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy5wcmV2S2V5c1tlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICFpIHx8IHQgJiYgd2UodCwgaSkgfHwgWCh0aGlzLmVsLCBpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRzID0ge1xuICAgICAgICAgICAgc3R5bGU6IHVyLFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBZcixcbiAgICAgICAgICAgIGNvbXBvbmVudDogWHIsXG4gICAgICAgICAgICBwcm9wOiBLcixcbiAgICAgICAgICAgIHRyYW5zaXRpb246IEdyXG4gICAgICAgIH0sXG4gICAgICAgIGVzID0gYW4uX3Byb3BCaW5kaW5nTW9kZXMsXG4gICAgICAgIGlzID0ge30sXG4gICAgICAgIG5zID0gL15bJF9hLXpBLVpdK1tcXHckXSokLyxcbiAgICAgICAgcnMgPSAvXnYtYmluZDp8XjovLFxuICAgICAgICBzcyA9IC9edi1vbjp8XkAvLFxuICAgICAgICBvcyA9IC86KC4qKSQvLFxuICAgICAgICBhcyA9IC9cXC5bXlxcLl0rL2csXG4gICAgICAgIGhzID0gL14odi1iaW5kOnw6KT90cmFuc2l0aW9uJC8sXG4gICAgICAgIGxzID0gW1wiZm9yXCIsIFwiaWZcIl0sXG4gICAgICAgIGNzID0gMWUzO1xuICAgIEllLnRlcm1pbmFsID0gITA7XG4gICAgdmFyIHVzID0gL1teXFx3XFwtOlxcLl0vLFxuICAgICAgICBmcyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgY29tcGlsZTogQWUsXG4gICAgICAgICAgICBjb21waWxlQW5kTGlua1Byb3BzOiBFZSxcbiAgICAgICAgICAgIGNvbXBpbGVSb290OiBTZSxcbiAgICAgICAgICAgIHRyYW5zY2x1ZGU6IEdlXG4gICAgICAgIH0pLFxuICAgICAgICBwcyA9IC9edi1vbjp8XkAvO1xuICAgIGlpLnByb3RvdHlwZS5fYmluZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGUgPSB0aGlzLmRlc2NyaXB0b3I7XG4gICAgICAgIGlmICgoXCJjbG9ha1wiICE9PSB0IHx8IHRoaXMudm0uX2lzQ29tcGlsZWQpICYmIHRoaXMuZWwgJiYgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHZhciBpID0gZS5hdHRyIHx8IFwidi1cIiArIHQ7XG4gICAgICAgICAgICBcImNsYXNzXCIgIT09IGkgPyB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShpKSA6IFoodGhpcy5lbCwgRih0aGlzLmVsLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpKS50cmltKCkucmVwbGFjZSgvXFxzKy9nLCBcIiBcIikpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSBlLmRlZjtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IHRoaXMudXBkYXRlID0gbiA6IHYodGhpcywgbiksIHRoaXMuX3NldHVwUGFyYW1zKCksIHRoaXMuYmluZCAmJiB0aGlzLmJpbmQoKSwgdGhpcy5fYm91bmQgPSAhMCwgdGhpcy5saXRlcmFsKSB0aGlzLnVwZGF0ZSAmJiB0aGlzLnVwZGF0ZShlLnJhdyk7XG4gICAgICAgIGVsc2UgaWYgKCh0aGlzLmV4cHJlc3Npb24gfHwgdGhpcy5tb2RpZmllcnMpICYmICh0aGlzLnVwZGF0ZSB8fCB0aGlzLnR3b1dheSkgJiYgIXRoaXMuX2NoZWNrU3RhdGVtZW50KCkpIHtcbiAgICAgICAgICAgIHZhciByID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMudXBkYXRlID8gdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgICAgIHIuX2xvY2tlZCB8fCByLnVwZGF0ZSh0LCBlKVxuICAgICAgICAgICAgfSA6IHRoaXMuX3VwZGF0ZSA9IGVpO1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9wcmVQcm9jZXNzID8gcCh0aGlzLl9wcmVQcm9jZXNzLCB0aGlzKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgbyA9IHRoaXMuX3Bvc3RQcm9jZXNzID8gcCh0aGlzLl9wb3N0UHJvY2VzcywgdGhpcykgOiBudWxsLFxuICAgICAgICAgICAgICAgIGEgPSB0aGlzLl93YXRjaGVyID0gbmV3IFV0KHRoaXMudm0sIHRoaXMuZXhwcmVzc2lvbiwgdGhpcy5fdXBkYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcnM6IHRoaXMuZmlsdGVycyxcbiAgICAgICAgICAgICAgICAgICAgdHdvV2F5OiB0aGlzLnR3b1dheSxcbiAgICAgICAgICAgICAgICAgICAgZGVlcDogdGhpcy5kZWVwLFxuICAgICAgICAgICAgICAgICAgICBwcmVQcm9jZXNzOiBzLFxuICAgICAgICAgICAgICAgICAgICBwb3N0UHJvY2VzczogbyxcbiAgICAgICAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuX3Njb3BlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQmluZCA/IHRoaXMuYWZ0ZXJCaW5kKCkgOiB0aGlzLnVwZGF0ZSAmJiB0aGlzLnVwZGF0ZShhLnZhbHVlKVxuICAgICAgICB9XG4gICAgfSwgaWkucHJvdG90eXBlLl9zZXR1cFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy5wYXJhbXM7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKHZhciBlLCBpLCBuLCByID0gdC5sZW5ndGg7IHItLTspIGUgPSB0W3JdLCBuID0gbChlKSwgaSA9IFYodGhpcy5lbCwgZSksIG51bGwgIT0gaSA/IHRoaXMuX3NldHVwUGFyYW1XYXRjaGVyKG4sIGkpIDogKGkgPSBCKHRoaXMuZWwsIGUpLCBudWxsICE9IGkgJiYgKHRoaXMucGFyYW1zW25dID0gXCJcIiA9PT0gaSA/ICEwIDogaSkpXG4gICAgICAgIH1cbiAgICB9LCBpaS5wcm90b3R5cGUuX3NldHVwUGFyYW1XYXRjaGVyID0gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMsXG4gICAgICAgICAgICBuID0gITEsXG4gICAgICAgICAgICByID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiR3YXRjaChlLCBmdW5jdGlvbihlLCByKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkucGFyYW1zW3RdID0gZSwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGkucGFyYW1XYXRjaGVycyAmJiBpLnBhcmFtV2F0Y2hlcnNbdF07XG4gICAgICAgICAgICAgICAgICAgIHMgJiYgcy5jYWxsKGksIGUsIHIpXG4gICAgICAgICAgICAgICAgfSBlbHNlIG4gPSAhMFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGltbWVkaWF0ZTogITBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAodGhpcy5fcGFyYW1VbndhdGNoRm5zIHx8ICh0aGlzLl9wYXJhbVVud2F0Y2hGbnMgPSBbXSkpLnB1c2gocilcbiAgICB9LCBpaS5wcm90b3R5cGUuX2NoZWNrU3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5leHByZXNzaW9uO1xuICAgICAgICBpZiAodCAmJiB0aGlzLmFjY2VwdFN0YXRlbWVudCAmJiAhQnQodCkpIHtcbiAgICAgICAgICAgIHZhciBlID0gV3QodCkuZ2V0LFxuICAgICAgICAgICAgICAgIGkgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtLFxuICAgICAgICAgICAgICAgIG4gPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIGkuJGV2ZW50ID0gdCwgZS5jYWxsKGksIGkpLCBpLiRldmVudCA9IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycyAmJiAobiA9IGkuX2FwcGx5RmlsdGVycyhuLCBudWxsLCB0aGlzLmZpbHRlcnMpKSwgdGhpcy51cGRhdGUobiksICEwXG4gICAgICAgIH1cbiAgICB9LCBpaS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odCkge1xuICAgICAgICB0aGlzLnR3b1dheSAmJiB0aGlzLl93aXRoTG9jayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX3dhdGNoZXIuc2V0KHQpXG4gICAgICAgIH0pXG4gICAgfSwgaWkucHJvdG90eXBlLl93aXRoTG9jayA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICBlLl9sb2NrZWQgPSAhMCwgdC5jYWxsKGUpLCBEaShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGUuX2xvY2tlZCA9ICExXG4gICAgICAgIH0pXG4gICAgfSwgaWkucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICBRKHRoaXMuZWwsIHQsIGUpLCAodGhpcy5fbGlzdGVuZXJzIHx8ICh0aGlzLl9saXN0ZW5lcnMgPSBbXSkpLnB1c2goW3QsIGVdKVxuICAgIH0sIGlpLnByb3RvdHlwZS5fdGVhcmRvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZCA9ICExLCB0aGlzLnVuYmluZCAmJiB0aGlzLnVuYmluZCgpLCB0aGlzLl93YXRjaGVyICYmIHRoaXMuX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICAgICAgICAgIHZhciB0LCBlID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICAgICAgZm9yICh0ID0gZS5sZW5ndGg7IHQtLTspIEcodGhpcy5lbCwgZVt0XVswXSwgZVt0XVsxXSk7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuX3BhcmFtVW53YXRjaEZucztcbiAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgIGZvciAodCA9IGkubGVuZ3RoOyB0LS07KSBpW3RdKCk7XG4gICAgICAgICAgICB0aGlzLnZtID0gdGhpcy5lbCA9IHRoaXMuX3dhdGNoZXIgPSB0aGlzLl9saXN0ZW5lcnMgPSBudWxsXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBkcyA9IC9bXnxdXFx8W158XS87XG4gICAgQXQoY2kpLCBZZShjaSksIHRpKGNpKSwgbmkoY2kpLCByaShjaSksIHNpKGNpKSwgb2koY2kpLCBhaShjaSksIGhpKGNpKSwgbGkoY2kpO1xuICAgIHZhciB2cyA9IExyLl9wb3N0UHJvY2VzcyxcbiAgICAgICAgbXMgPSAvKFxcZHszfSkoPz1cXGQpL2csXG4gICAgICAgIGdzID0ge1xuICAgICAgICAgICAgb3JkZXJCeTogcGksXG4gICAgICAgICAgICBmaWx0ZXJCeTogZmksXG4gICAgICAgICAgICBsaW1pdEJ5OiB1aSxcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICByZWFkOiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiB0ID8gdCA6IEpTT04uc3RyaW5naWZ5KHQsIG51bGwsIE51bWJlcihlKSB8fCAyKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHQpXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FwaXRhbGl6ZTogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0IHx8IDAgPT09IHQgPyAodCA9IHQudG9TdHJpbmcoKSwgdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHQuc2xpY2UoMSkpIDogXCJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwcGVyY2FzZTogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0IHx8IDAgPT09IHQgPyB0LnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSA6IFwiXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdCB8fCAwID09PSB0ID8gdC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgOiBcIlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VycmVuY3k6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodCA9IHBhcnNlRmxvYXQodCksICFpc0Zpbml0ZSh0KSB8fCAhdCAmJiAwICE9PSB0KSByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICBlID0gbnVsbCAhPSBlID8gZSA6IFwiJFwiO1xuICAgICAgICAgICAgICAgIHZhciBpID0gTWF0aC5hYnModCkudG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgICAgbiA9IGkuc2xpY2UoMCwgLTMpLFxuICAgICAgICAgICAgICAgICAgICByID0gbi5sZW5ndGggJSAzLFxuICAgICAgICAgICAgICAgICAgICBzID0gciA+IDAgPyBuLnNsaWNlKDAsIHIpICsgKG4ubGVuZ3RoID4gMyA/IFwiLFwiIDogXCJcIikgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBvID0gaS5zbGljZSgtMyksXG4gICAgICAgICAgICAgICAgICAgIGEgPSAwID4gdCA/IFwiLVwiIDogXCJcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZSArIGEgKyBzICsgbi5zbGljZShyKS5yZXBsYWNlKG1zLCBcIiQxLFwiKSArIG9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwbHVyYWxpemU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGQoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5sZW5ndGggPiAxID8gZVt0ICUgMTAgLSAxXSB8fCBlW2UubGVuZ3RoIC0gMV0gOiBlWzBdICsgKDEgPT09IHQgPyBcIlwiIDogXCJzXCIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVib3VuY2U6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdCA/IChlIHx8IChlID0gMzAwKSwgYih0LCBlKSkgOiB2b2lkIDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3MgPSB7XG4gICAgICAgICAgICBwcmlvcml0eTogMTc1MCxcbiAgICAgICAgICAgIHBhcmFtczogW1wibmFtZVwiXSxcbiAgICAgICAgICAgIHBhcmFtV2F0Y2hlcnM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIFJyLnJlbW92ZS5jYWxsKHRoaXMpLCB0ICYmIHRoaXMuaW5zZXJ0KHQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5jaG9yID0gbnQoXCJ2LXBhcnRpYWxcIiksIEoodGhpcy5lbCwgdGhpcy5hbmNob3IpLCB0aGlzLmluc2VydCh0aGlzLnBhcmFtcy5uYW1lKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc2VydDogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gX3QodGhpcy52bS4kb3B0aW9ucywgXCJwYXJ0aWFsc1wiLCB0KTtcbiAgICAgICAgICAgICAgICBlICYmICh0aGlzLmZhY3RvcnkgPSBuZXcgcGUodGhpcy52bSwgZSksIFJyLmluc2VydC5jYWxsKHRoaXMpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuYmluZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnICYmIHRoaXMuZnJhZy5kZXN0cm95KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYnMgPSB7XG4gICAgICAgICAgICBwcmlvcml0eTogMTc1MCxcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy52bSxcbiAgICAgICAgICAgICAgICAgICAgZSA9IHQuJG9wdGlvbnMuX2NvbnRlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKCFlKSByZXR1cm4gdm9pZCB0aGlzLmZhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0Ll9jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBuID0gdGhpcy5wYXJhbXMgJiYgdGhpcy5wYXJhbXMubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9ICdbc2xvdD1cIicgKyBuICsgJ1wiXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gZS5xdWVyeVNlbGVjdG9yQWxsKHIpO1xuICAgICAgICAgICAgICAgICAgICBzLmxlbmd0aCA/IHRoaXMudHJ5Q29tcGlsZSh2aShzLCBlKSwgaSwgdCkgOiB0aGlzLmZhbGxiYWNrKClcbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy50cnlDb21waWxlKHZpKGUuY2hpbGROb2RlcywgZSwgITApLCBpLCB0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyeUNvbXBpbGU6IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICAgICAgICAgICAgICB0Lmhhc0NoaWxkTm9kZXMoKSA/IHRoaXMuY29tcGlsZSh0LCBlLCBpKSA6IHRoaXMuZmFsbGJhY2soKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodCAmJiBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gaSA/IGkuX3Njb3BlIDogdGhpcy5fc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5saW5rID0gZS4kY29tcGlsZSh0LCBpLCBuLCB0aGlzLl9mcmFnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ID8gSih0aGlzLmVsLCB0KSA6IFUodGhpcy5lbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21waWxlKFkodGhpcy5lbCwgITApLCB0aGlzLnZtKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuYmluZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmxpbmsgJiYgdGhpcy51bmxpbmsoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5cyA9IHYodih7fSwgYnMpLCB7XG4gICAgICAgICAgICBwcmlvcml0eTogYnMucHJpb3JpdHkgKyAxLFxuICAgICAgICAgICAgcGFyYW1zOiBbXCJuYW1lXCJdXG4gICAgICAgIH0pLFxuICAgICAgICBDcyA9IHtcbiAgICAgICAgICAgIHNsb3Q6IGJzLFxuICAgICAgICAgICAgX25hbWVkU2xvdDogeXMsXG4gICAgICAgICAgICBwYXJ0aWFsOiBfc1xuICAgICAgICB9O1xuICAgIHJldHVybiBjaS52ZXJzaW9uID0gXCIxLjAuMTJcIiwgY2kub3B0aW9ucyA9IHtcbiAgICAgICAgZGlyZWN0aXZlczogVnIsXG4gICAgICAgIGVsZW1lbnREaXJlY3RpdmVzOiBDcyxcbiAgICAgICAgZmlsdGVyczogZ3MsXG4gICAgICAgIHRyYW5zaXRpb25zOiB7fSxcbiAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgIHBhcnRpYWxzOiB7fSxcbiAgICAgICAgcmVwbGFjZTogITBcbiAgICB9LCBjaVxufSk7XG4iXSwiZmlsZSI6InZ1ZS5taW4uanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
