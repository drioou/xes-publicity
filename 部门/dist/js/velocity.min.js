! function(e) {
    function t(e) {
        var t = e.length,
            a = r.type(e);
        return "function" === a || r.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === a || 0 === t || "number" == typeof t && t > 0 && t - 1 in e
    }
    if (!e.jQuery) {
        var r = function(e, t) {
            return new r.fn.init(e, t)
        };
        r.isWindow = function(e) {
            return null != e && e == e.window
        }, r.type = function(e) {
            return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[i.call(e)] || "object" : typeof e
        }, r.isArray = Array.isArray || function(e) {
            return "array" === r.type(e)
        }, r.isPlainObject = function(e) {
            var t;
            if (!e || "object" !== r.type(e) || e.nodeType || r.isWindow(e)) return !1;
            try {
                if (e.constructor && !o.call(e, "constructor") && !o.call(e.constructor.prototype, "isPrototypeOf")) return !1
            } catch (a) {
                return !1
            }
            for (t in e);
            return void 0 === t || o.call(e, t)
        }, r.each = function(e, r, a) {
            var n, o = 0,
                i = e.length,
                s = t(e);
            if (a) {
                if (s)
                    for (; i > o && (n = r.apply(e[o], a), n !== !1); o++);
                else
                    for (o in e)
                        if (n = r.apply(e[o], a), n === !1) break
            } else if (s)
                for (; i > o && (n = r.call(e[o], o, e[o]), n !== !1); o++);
            else
                for (o in e)
                    if (n = r.call(e[o], o, e[o]), n === !1) break; return e
        }, r.data = function(e, t, n) {
            if (void 0 === n) {
                var o = e[r.expando],
                    i = o && a[o];
                if (void 0 === t) return i;
                if (i && t in i) return i[t]
            } else if (void 0 !== t) {
                var o = e[r.expando] || (e[r.expando] = ++r.uuid);
                return a[o] = a[o] || {}, a[o][t] = n, n
            }
        }, r.removeData = function(e, t) {
            var n = e[r.expando],
                o = n && a[n];
            o && r.each(t, function(e, t) {
                delete o[t]
            })
        }, r.extend = function() {
            var e, t, a, n, o, i, s = arguments[0] || {},
                l = 1,
                u = arguments.length,
                c = !1;
            for ("boolean" == typeof s && (c = s, s = arguments[l] || {}, l++), "object" != typeof s && "function" !== r.type(s) && (s = {}), l === u && (s = this, l--); u > l; l++)
                if (null != (o = arguments[l]))
                    for (n in o) e = s[n], a = o[n], s !== a && (c && a && (r.isPlainObject(a) || (t = r.isArray(a))) ? (t ? (t = !1, i = e && r.isArray(e) ? e : []) : i = e && r.isPlainObject(e) ? e : {}, s[n] = r.extend(c, i, a)) : void 0 !== a && (s[n] = a));
            return s
        }, r.queue = function(e, a, n) {
            function o(e, r) {
                var a = r || [];
                return null != e && (t(Object(e)) ? ! function(e, t) {
                    for (var r = +t.length, a = 0, n = e.length; r > a;) e[n++] = t[a++];
                    if (r !== r)
                        for (; void 0 !== t[a];) e[n++] = t[a++];
                    return e.length = n, e
                }(a, "string" == typeof e ? [e] : e) : [].push.call(a, e)), a
            }
            if (e) {
                a = (a || "fx") + "queue";
                var i = r.data(e, a);
                return n ? (!i || r.isArray(n) ? i = r.data(e, a, o(n)) : i.push(n), i) : i || []
            }
        }, r.dequeue = function(e, t) {
            r.each(e.nodeType ? [e] : e, function(e, a) {
                t = t || "fx";
                var n = r.queue(a, t),
                    o = n.shift();
                "inprogress" === o && (o = n.shift()), o && ("fx" === t && n.unshift("inprogress"), o.call(a, function() {
                    r.dequeue(a, t)
                }))
            })
        }, r.fn = r.prototype = {
            init: function(e) {
                if (e.nodeType) return this[0] = e, this;
                throw new Error("Not a DOM node.")
            },
            offset: function() {
                var t = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : {
                    top: 0,
                    left: 0
                };
                return {
                    top: t.top + (e.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0),
                    left: t.left + (e.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || 0)
                }
            },
            position: function() {
                function e() {
                    for (var e = this.offsetParent || document; e && "html" === !e.nodeType.toLowerCase && "static" === e.style.position;) e = e.offsetParent;
                    return e || document
                }
                var t = this[0],
                    e = e.apply(t),
                    a = this.offset(),
                    n = /^(?:body|html)$/i.test(e.nodeName) ? {
                        top: 0,
                        left: 0
                    } : r(e).offset();
                return a.top -= parseFloat(t.style.marginTop) || 0, a.left -= parseFloat(t.style.marginLeft) || 0, e.style && (n.top += parseFloat(e.style.borderTopWidth) || 0, n.left += parseFloat(e.style.borderLeftWidth) || 0), {
                    top: a.top - n.top,
                    left: a.left - n.left
                }
            }
        };
        var a = {};
        r.expando = "velocity" + (new Date).getTime(), r.uuid = 0;
        for (var n = {}, o = n.hasOwnProperty, i = n.toString, s = "Boolean Number String Function Array Date RegExp Object Error".split(" "), l = 0; l < s.length; l++) n["[object " + s[l] + "]"] = s[l].toLowerCase();
        r.fn.init.prototype = r.fn, e.Velocity = {
            Utilities: r
        }
    }
}(window),
function(e) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : e()
}(function() {
    return function(e, t, r, a) {
        function n(e) {
            for (var t = -1, r = e ? e.length : 0, a = []; ++t < r;) {
                var n = e[t];
                n && a.push(n)
            }
            return a
        }

        function o(e) {
            return m.isWrapped(e) ? e = [].slice.call(e) : m.isNode(e) && (e = [e]), e
        }

        function i(e) {
            var t = f.data(e, "velocity");
            return null === t ? a : t
        }

        function s(e) {
            return function(t) {
                return Math.round(t * e) * (1 / e)
            }
        }

        function l(e, r, a, n) {
            function o(e, t) {
                return 1 - 3 * t + 3 * e
            }

            function i(e, t) {
                return 3 * t - 6 * e
            }

            function s(e) {
                return 3 * e
            }

            function l(e, t, r) {
                return ((o(t, r) * e + i(t, r)) * e + s(t)) * e
            }

            function u(e, t, r) {
                return 3 * o(t, r) * e * e + 2 * i(t, r) * e + s(t)
            }

            function c(t, r) {
                for (var n = 0; m > n; ++n) {
                    var o = u(r, e, a);
                    if (0 === o) return r;
                    var i = l(r, e, a) - t;
                    r -= i / o
                }
                return r
            }

            function p() {
                for (var t = 0; b > t; ++t) w[t] = l(t * x, e, a)
            }

            function f(t, r, n) {
                var o, i, s = 0;
                do i = r + (n - r) / 2, o = l(i, e, a) - t, o > 0 ? n = i : r = i; while (Math.abs(o) > h && ++s < v);
                return i
            }

            function d(t) {
                for (var r = 0, n = 1, o = b - 1; n != o && w[n] <= t; ++n) r += x;
                --n;
                var i = (t - w[n]) / (w[n + 1] - w[n]),
                    s = r + i * x,
                    l = u(s, e, a);
                return l >= y ? c(t, s) : 0 == l ? s : f(t, r, r + x)
            }

            function g() {
                V = !0, (e != r || a != n) && p()
            }
            var m = 4,
                y = .001,
                h = 1e-7,
                v = 10,
                b = 11,
                x = 1 / (b - 1),
                S = "Float32Array" in t;
            if (4 !== arguments.length) return !1;
            for (var P = 0; 4 > P; ++P)
                if ("number" != typeof arguments[P] || isNaN(arguments[P]) || !isFinite(arguments[P])) return !1;
            e = Math.min(e, 1), a = Math.min(a, 1), e = Math.max(e, 0), a = Math.max(a, 0);
            var w = S ? new Float32Array(b) : new Array(b),
                V = !1,
                C = function(t) {
                    return V || g(), e === r && a === n ? t : 0 === t ? 0 : 1 === t ? 1 : l(d(t), r, n)
                };
            C.getControlPoints = function() {
                return [{
                    x: e,
                    y: r
                }, {
                    x: a,
                    y: n
                }]
            };
            var T = "generateBezier(" + [e, r, a, n] + ")";
            return C.toString = function() {
                return T
            }, C
        }

        function u(e, t) {
            var r = e;
            return m.isString(e) ? b.Easings[e] || (r = !1) : r = m.isArray(e) && 1 === e.length ? s.apply(null, e) : m.isArray(e) && 2 === e.length ? x.apply(null, e.concat([t])) : m.isArray(e) && 4 === e.length ? l.apply(null, e) : !1, r === !1 && (r = b.Easings[b.defaults.easing] ? b.defaults.easing : v), r
        }

        function c(e) {
            if (e) {
                var t = (new Date).getTime(),
                    r = b.State.calls.length;
                r > 1e4 && (b.State.calls = n(b.State.calls));
                for (var o = 0; r > o; o++)
                    if (b.State.calls[o]) {
                        var s = b.State.calls[o],
                            l = s[0],
                            u = s[2],
                            d = s[3],
                            g = !!d,
                            y = null;
                        d || (d = b.State.calls[o][3] = t - 16);
                        for (var h = Math.min((t - d) / u.duration, 1), v = 0, x = l.length; x > v; v++) {
                            var P = l[v],
                                V = P.element;
                            if (i(V)) {
                                var C = !1;
                                if (u.display !== a && null !== u.display && "none" !== u.display) {
                                    if ("flex" === u.display) {
                                        var T = ["-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex"];
                                        f.each(T, function(e, t) {
                                            S.setPropertyValue(V, "display", t)
                                        })
                                    }
                                    S.setPropertyValue(V, "display", u.display)
                                }
                                u.visibility !== a && "hidden" !== u.visibility && S.setPropertyValue(V, "visibility", u.visibility);
                                for (var k in P)
                                    if ("element" !== k) {
                                        var A, F = P[k],
                                            E = m.isString(F.easing) ? b.Easings[F.easing] : F.easing;
                                        if (1 === h) A = F.endValue;
                                        else {
                                            var j = F.endValue - F.startValue;
                                            if (A = F.startValue + j * E(h, u, j), !g && A === F.currentValue) continue
                                        }
                                        if (F.currentValue = A, "tween" === k) y = A;
                                        else {
                                            if (S.Hooks.registered[k]) {
                                                var H = S.Hooks.getRoot(k),
                                                    N = i(V).rootPropertyValueCache[H];
                                                N && (F.rootPropertyValue = N)
                                            }
                                            var L = S.setPropertyValue(V, k, F.currentValue + (0 === parseFloat(A) ? "" : F.unitType), F.rootPropertyValue, F.scrollData);
                                            S.Hooks.registered[k] && (i(V).rootPropertyValueCache[H] = S.Normalizations.registered[H] ? S.Normalizations.registered[H]("extract", null, L[1]) : L[1]), "transform" === L[0] && (C = !0)
                                        }
                                    }
                                u.mobileHA && i(V).transformCache.translate3d === a && (i(V).transformCache.translate3d = "(0px, 0px, 0px)", C = !0), C && S.flushTransformCache(V)
                            }
                        }
                        u.display !== a && "none" !== u.display && (b.State.calls[o][2].display = !1), u.visibility !== a && "hidden" !== u.visibility && (b.State.calls[o][2].visibility = !1), u.progress && u.progress.call(s[1], s[1], h, Math.max(0, d + u.duration - t), d, y), 1 === h && p(o)
                    }
            }
            b.State.isTicking && w(c)
        }

        function p(e, t) {
            if (!b.State.calls[e]) return !1;
            for (var r = b.State.calls[e][0], n = b.State.calls[e][1], o = b.State.calls[e][2], s = b.State.calls[e][4], l = !1, u = 0, c = r.length; c > u; u++) {
                var p = r[u].element;
                if (t || o.loop || ("none" === o.display && S.setPropertyValue(p, "display", o.display), "hidden" === o.visibility && S.setPropertyValue(p, "visibility", o.visibility)), o.loop !== !0 && (f.queue(p)[1] === a || !/\.velocityQueueEntryFlag/i.test(f.queue(p)[1])) && i(p)) {
                    i(p).isAnimating = !1, i(p).rootPropertyValueCache = {};
                    var d = !1;
                    f.each(S.Lists.transforms3D, function(e, t) {
                        var r = /^scale/.test(t) ? 1 : 0,
                            n = i(p).transformCache[t];
                        i(p).transformCache[t] !== a && new RegExp("^\\(" + r + "[^.]").test(n) && (d = !0, delete i(p).transformCache[t])
                    }), o.mobileHA && (d = !0, delete i(p).transformCache.translate3d), d && S.flushTransformCache(p), S.Values.removeClass(p, "velocity-animating")
                }
                if (!t && o.complete && !o.loop && u === c - 1) try {
                    o.complete.call(n, n)
                } catch (g) {
                    setTimeout(function() {
                        throw g
                    }, 1)
                }
                s && o.loop !== !0 && s(n), i(p) && o.loop === !0 && !t && (f.each(i(p).tweensContainer, function(e, t) {
                    /^rotate/.test(e) && 360 === parseFloat(t.endValue) && (t.endValue = 0, t.startValue = 360), /^backgroundPosition/.test(e) && 100 === parseFloat(t.endValue) && "%" === t.unitType && (t.endValue = 0, t.startValue = 100)
                }), b(p, "reverse", {
                    loop: !0,
                    delay: o.delay
                })), o.queue !== !1 && f.dequeue(p, o.queue)
            }
            b.State.calls[e] = !1;
            for (var m = 0, y = b.State.calls.length; y > m; m++)
                if (b.State.calls[m] !== !1) {
                    l = !0;
                    break
                }
            l === !1 && (b.State.isTicking = !1, delete b.State.calls, b.State.calls = [])
        }
        var f, d = function() {
                if (r.documentMode) return r.documentMode;
                for (var e = 7; e > 4; e--) {
                    var t = r.createElement("div");
                    if (t.innerHTML = "<!--[if IE " + e + "]><span></span><![endif]-->", t.getElementsByTagName("span").length) return t = null, e
                }
                return a
            }(),
            g = function() {
                var e = 0;
                return t.webkitRequestAnimationFrame || t.mozRequestAnimationFrame || function(t) {
                    var r, a = (new Date).getTime();
                    return r = Math.max(0, 16 - (a - e)), e = a + r, setTimeout(function() {
                        t(a + r)
                    }, r)
                }
            }(),
            m = {
                isString: function(e) {
                    return "string" == typeof e
                },
                isArray: Array.isArray || function(e) {
                    return "[object Array]" === Object.prototype.toString.call(e)
                },
                isFunction: function(e) {
                    return "[object Function]" === Object.prototype.toString.call(e)
                },
                isNode: function(e) {
                    return e && e.nodeType
                },
                isNodeList: function(e) {
                    return "object" == typeof e && /^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(e)) && e.length !== a && (0 === e.length || "object" == typeof e[0] && e[0].nodeType > 0)
                },
                isWrapped: function(e) {
                    return e && (e.jquery || t.Zepto && t.Zepto.zepto.isZ(e))
                },
                isSVG: function(e) {
                    return t.SVGElement && e instanceof t.SVGElement
                },
                isEmptyObject: function(e) {
                    for (var t in e) return !1;
                    return !0
                }
            },
            y = !1;
        if (e.fn && e.fn.jquery ? (f = e, y = !0) : f = t.Velocity.Utilities, 8 >= d && !y) throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");
        if (7 >= d) return void(jQuery.fn.velocity = jQuery.fn.animate);
        var h = 400,
            v = "swing",
            b = {
                State: {
                    isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                    isAndroid: /Android/i.test(navigator.userAgent),
                    isGingerbread: /Android 2\.3\.[3-7]/i.test(navigator.userAgent),
                    isChrome: t.chrome,
                    isFirefox: /Firefox/i.test(navigator.userAgent),
                    prefixElement: r.createElement("div"),
                    prefixMatches: {},
                    scrollAnchor: null,
                    scrollPropertyLeft: null,
                    scrollPropertyTop: null,
                    isTicking: !1,
                    calls: []
                },
                CSS: {},
                Utilities: f,
                Redirects: {},
                Easings: {},
                Promise: t.Promise,
                defaults: {
                    queue: "",
                    duration: h,
                    easing: v,
                    begin: a,
                    complete: a,
                    progress: a,
                    display: a,
                    visibility: a,
                    loop: !1,
                    delay: !1,
                    mobileHA: !0,
                    _cacheValues: !0
                },
                init: function(e) {
                    f.data(e, "velocity", {
                        isSVG: m.isSVG(e),
                        isAnimating: !1,
                        computedStyle: null,
                        tweensContainer: null,
                        rootPropertyValueCache: {},
                        transformCache: {}
                    })
                },
                hook: null,
                mock: !1,
                version: {
                    major: 1,
                    minor: 2,
                    patch: 2
                },
                debug: !1
            };
        t.pageYOffset !== a ? (b.State.scrollAnchor = t, b.State.scrollPropertyLeft = "pageXOffset", b.State.scrollPropertyTop = "pageYOffset") : (b.State.scrollAnchor = r.documentElement || r.body.parentNode || r.body, b.State.scrollPropertyLeft = "scrollLeft", b.State.scrollPropertyTop = "scrollTop");
        var x = function() {
            function e(e) {
                return -e.tension * e.x - e.friction * e.v
            }

            function t(t, r, a) {
                var n = {
                    x: t.x + a.dx * r,
                    v: t.v + a.dv * r,
                    tension: t.tension,
                    friction: t.friction
                };
                return {
                    dx: n.v,
                    dv: e(n)
                }
            }

            function r(r, a) {
                var n = {
                        dx: r.v,
                        dv: e(r)
                    },
                    o = t(r, .5 * a, n),
                    i = t(r, .5 * a, o),
                    s = t(r, a, i),
                    l = 1 / 6 * (n.dx + 2 * (o.dx + i.dx) + s.dx),
                    u = 1 / 6 * (n.dv + 2 * (o.dv + i.dv) + s.dv);
                return r.x = r.x + l * a, r.v = r.v + u * a, r
            }
            return function a(e, t, n) {
                var o, i, s, l = {
                        x: -1,
                        v: 0,
                        tension: null,
                        friction: null
                    },
                    u = [0],
                    c = 0,
                    p = 1e-4,
                    f = .016;
                for (e = parseFloat(e) || 500, t = parseFloat(t) || 20, n = n || null, l.tension = e, l.friction = t, o = null !== n, o ? (c = a(e, t), i = c / n * f) : i = f; s = r(s || l, i), u.push(1 + s.x), c += 16, Math.abs(s.x) > p && Math.abs(s.v) > p;);
                return o ? function(e) {
                    return u[e * (u.length - 1) | 0]
                } : c
            }
        }();
        b.Easings = {
            linear: function(e) {
                return e
            },
            swing: function(e) {
                return .5 - Math.cos(e * Math.PI) / 2
            },
            spring: function(e) {
                return 1 - Math.cos(4.5 * e * Math.PI) * Math.exp(6 * -e)
            }
        }, f.each([
            ["ease", [.25, .1, .25, 1]],
            ["ease-in", [.42, 0, 1, 1]],
            ["ease-out", [0, 0, .58, 1]],
            ["ease-in-out", [.42, 0, .58, 1]],
            ["easeInSine", [.47, 0, .745, .715]],
            ["easeOutSine", [.39, .575, .565, 1]],
            ["easeInOutSine", [.445, .05, .55, .95]],
            ["easeInQuad", [.55, .085, .68, .53]],
            ["easeOutQuad", [.25, .46, .45, .94]],
            ["easeInOutQuad", [.455, .03, .515, .955]],
            ["easeInCubic", [.55, .055, .675, .19]],
            ["easeOutCubic", [.215, .61, .355, 1]],
            ["easeInOutCubic", [.645, .045, .355, 1]],
            ["easeInQuart", [.895, .03, .685, .22]],
            ["easeOutQuart", [.165, .84, .44, 1]],
            ["easeInOutQuart", [.77, 0, .175, 1]],
            ["easeInQuint", [.755, .05, .855, .06]],
            ["easeOutQuint", [.23, 1, .32, 1]],
            ["easeInOutQuint", [.86, 0, .07, 1]],
            ["easeInExpo", [.95, .05, .795, .035]],
            ["easeOutExpo", [.19, 1, .22, 1]],
            ["easeInOutExpo", [1, 0, 0, 1]],
            ["easeInCirc", [.6, .04, .98, .335]],
            ["easeOutCirc", [.075, .82, .165, 1]],
            ["easeInOutCirc", [.785, .135, .15, .86]]
        ], function(e, t) {
            b.Easings[t[0]] = l.apply(null, t[1])
        });
        var S = b.CSS = {
            RegEx: {
                isHex: /^#([A-f\d]{3}){1,2}$/i,
                valueUnwrap: /^[A-z]+\((.*)\)$/i,
                wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,
                valueSplit: /([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/gi
            },
            Lists: {
                colors: ["fill", "stroke", "stopColor", "color", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "outlineColor"],
                transformsBase: ["translateX", "translateY", "scale", "scaleX", "scaleY", "skewX", "skewY", "rotateZ"],
                transforms3D: ["transformPerspective", "translateZ", "scaleZ", "rotateX", "rotateY"]
            },
            Hooks: {
                templates: {
                    textShadow: ["Color X Y Blur", "black 0px 0px 0px"],
                    boxShadow: ["Color X Y Blur Spread", "black 0px 0px 0px 0px"],
                    clip: ["Top Right Bottom Left", "0px 0px 0px 0px"],
                    backgroundPosition: ["X Y", "0% 0%"],
                    transformOrigin: ["X Y Z", "50% 50% 0px"],
                    perspectiveOrigin: ["X Y", "50% 50%"]
                },
                registered: {},
                register: function() {
                    for (var e = 0; e < S.Lists.colors.length; e++) {
                        var t = "color" === S.Lists.colors[e] ? "0 0 0 1" : "255 255 255 1";
                        S.Hooks.templates[S.Lists.colors[e]] = ["Red Green Blue Alpha", t]
                    }
                    var r, a, n;
                    if (d)
                        for (r in S.Hooks.templates) {
                            a = S.Hooks.templates[r], n = a[0].split(" ");
                            var o = a[1].match(S.RegEx.valueSplit);
                            "Color" === n[0] && (n.push(n.shift()), o.push(o.shift()), S.Hooks.templates[r] = [n.join(" "), o.join(" ")])
                        }
                    for (r in S.Hooks.templates) {
                        a = S.Hooks.templates[r], n = a[0].split(" ");
                        for (var e in n) {
                            var i = r + n[e],
                                s = e;
                            S.Hooks.registered[i] = [r, s]
                        }
                    }
                },
                getRoot: function(e) {
                    var t = S.Hooks.registered[e];
                    return t ? t[0] : e
                },
                cleanRootPropertyValue: function(e, t) {
                    return S.RegEx.valueUnwrap.test(t) && (t = t.match(S.RegEx.valueUnwrap)[1]), S.Values.isCSSNullValue(t) && (t = S.Hooks.templates[e][1]), t
                },
                extractValue: function(e, t) {
                    var r = S.Hooks.registered[e];
                    if (r) {
                        var a = r[0],
                            n = r[1];
                        return t = S.Hooks.cleanRootPropertyValue(a, t), t.toString().match(S.RegEx.valueSplit)[n]
                    }
                    return t
                },
                injectValue: function(e, t, r) {
                    var a = S.Hooks.registered[e];
                    if (a) {
                        var n, o, i = a[0],
                            s = a[1];
                        return r = S.Hooks.cleanRootPropertyValue(i, r), n = r.toString().match(S.RegEx.valueSplit), n[s] = t, o = n.join(" ")
                    }
                    return r
                }
            },
            Normalizations: {
                registered: {
                    clip: function(e, t, r) {
                        switch (e) {
                            case "name":
                                return "clip";
                            case "extract":
                                var a;
                                return S.RegEx.wrappedValueAlreadyExtracted.test(r) ? a = r : (a = r.toString().match(S.RegEx.valueUnwrap), a = a ? a[1].replace(/,(\s+)?/g, " ") : r), a;
                            case "inject":
                                return "rect(" + r + ")"
                        }
                    },
                    blur: function(e, t, r) {
                        switch (e) {
                            case "name":
                                return b.State.isFirefox ? "filter" : "-webkit-filter";
                            case "extract":
                                var a = parseFloat(r);
                                if (!a && 0 !== a) {
                                    var n = r.toString().match(/blur\(([0-9]+[A-z]+)\)/i);
                                    a = n ? n[1] : 0
                                }
                                return a;
                            case "inject":
                                return parseFloat(r) ? "blur(" + r + ")" : "none"
                        }
                    },
                    opacity: function(e, t, r) {
                        if (8 >= d) switch (e) {
                            case "name":
                                return "filter";
                            case "extract":
                                var a = r.toString().match(/alpha\(opacity=(.*)\)/i);
                                return r = a ? a[1] / 100 : 1;
                            case "inject":
                                return t.style.zoom = 1, parseFloat(r) >= 1 ? "" : "alpha(opacity=" + parseInt(100 * parseFloat(r), 10) + ")"
                        } else switch (e) {
                            case "name":
                                return "opacity";
                            case "extract":
                                return r;
                            case "inject":
                                return r
                        }
                    }
                },
                register: function() {
                    9 >= d || b.State.isGingerbread || (S.Lists.transformsBase = S.Lists.transformsBase.concat(S.Lists.transforms3D));
                    for (var e = 0; e < S.Lists.transformsBase.length; e++) ! function() {
                        var t = S.Lists.transformsBase[e];
                        S.Normalizations.registered[t] = function(e, r, n) {
                            switch (e) {
                                case "name":
                                    return "transform";
                                case "extract":
                                    return i(r) === a || i(r).transformCache[t] === a ? /^scale/i.test(t) ? 1 : 0 : i(r).transformCache[t].replace(/[()]/g, "");
                                case "inject":
                                    var o = !1;
                                    switch (t.substr(0, t.length - 1)) {
                                        case "translate":
                                            o = !/(%|px|em|rem|vw|vh|\d)$/i.test(n);
                                            break;
                                        case "scal":
                                        case "scale":
                                            b.State.isAndroid && i(r).transformCache[t] === a && 1 > n && (n = 1), o = !/(\d)$/i.test(n);
                                            break;
                                        case "skew":
                                            o = !/(deg|\d)$/i.test(n);
                                            break;
                                        case "rotate":
                                            o = !/(deg|\d)$/i.test(n)
                                    }
                                    return o || (i(r).transformCache[t] = "(" + n + ")"), i(r).transformCache[t]
                            }
                        }
                    }();
                    for (var e = 0; e < S.Lists.colors.length; e++) ! function() {
                        var t = S.Lists.colors[e];
                        S.Normalizations.registered[t] = function(e, r, n) {
                            switch (e) {
                                case "name":
                                    return t;
                                case "extract":
                                    var o;
                                    if (S.RegEx.wrappedValueAlreadyExtracted.test(n)) o = n;
                                    else {
                                        var i, s = {
                                            black: "rgb(0, 0, 0)",
                                            blue: "rgb(0, 0, 255)",
                                            gray: "rgb(128, 128, 128)",
                                            green: "rgb(0, 128, 0)",
                                            red: "rgb(255, 0, 0)",
                                            white: "rgb(255, 255, 255)"
                                        };
                                        /^[A-z]+$/i.test(n) ? i = s[n] !== a ? s[n] : s.black : S.RegEx.isHex.test(n) ? i = "rgb(" + S.Values.hexToRgb(n).join(" ") + ")" : /^rgba?\(/i.test(n) || (i = s.black), o = (i || n).toString().match(S.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g, " ")
                                    }
                                    return 8 >= d || 3 !== o.split(" ").length || (o += " 1"), o;
                                case "inject":
                                    return 8 >= d ? 4 === n.split(" ").length && (n = n.split(/\s+/).slice(0, 3).join(" ")) : 3 === n.split(" ").length && (n += " 1"), (8 >= d ? "rgb" : "rgba") + "(" + n.replace(/\s+/g, ",").replace(/\.(\d)+(?=,)/g, "") + ")"
                            }
                        }
                    }()
                }
            },
            Names: {
                camelCase: function(e) {
                    return e.replace(/-(\w)/g, function(e, t) {
                        return t.toUpperCase()
                    })
                },
                SVGAttribute: function(e) {
                    var t = "width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";
                    return (d || b.State.isAndroid && !b.State.isChrome) && (t += "|transform"), new RegExp("^(" + t + ")$", "i").test(e)
                },
                prefixCheck: function(e) {
                    if (b.State.prefixMatches[e]) return [b.State.prefixMatches[e], !0];
                    for (var t = ["", "Webkit", "Moz", "ms", "O"], r = 0, a = t.length; a > r; r++) {
                        var n;
                        if (n = 0 === r ? e : t[r] + e.replace(/^\w/, function(e) {
                                return e.toUpperCase()
                            }), m.isString(b.State.prefixElement.style[n])) return b.State.prefixMatches[e] = n, [n, !0]
                    }
                    return [e, !1]
                }
            },
            Values: {
                hexToRgb: function(e) {
                    var t, r = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
                        a = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
                    return e = e.replace(r, function(e, t, r, a) {
                        return t + t + r + r + a + a
                    }), t = a.exec(e), t ? [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)] : [0, 0, 0]
                },
                isCSSNullValue: function(e) {
                    return 0 == e || /^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(e)
                },
                getUnitType: function(e) {
                    return /^(rotate|skew)/i.test(e) ? "deg" : /(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(e) ? "" : "px"
                },
                getDisplayType: function(e) {
                    var t = e && e.tagName.toString().toLowerCase();
                    return /^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(t) ? "inline" : /^(li)$/i.test(t) ? "list-item" : /^(tr)$/i.test(t) ? "table-row" : /^(table)$/i.test(t) ? "table" : /^(tbody)$/i.test(t) ? "table-row-group" : "block"
                },
                addClass: function(e, t) {
                    e.classList ? e.classList.add(t) : e.className += (e.className.length ? " " : "") + t
                },
                removeClass: function(e, t) {
                    e.classList ? e.classList.remove(t) : e.className = e.className.toString().replace(new RegExp("(^|\\s)" + t.split(" ").join("|") + "(\\s|$)", "gi"), " ")
                }
            },
            getPropertyValue: function(e, r, n, o) {
                function s(e, r) {
                    function n() {
                        u && S.setPropertyValue(e, "display", "none")
                    }
                    var l = 0;
                    if (8 >= d) l = f.css(e, r);
                    else {
                        var u = !1;
                        if (/^(width|height)$/.test(r) && 0 === S.getPropertyValue(e, "display") && (u = !0, S.setPropertyValue(e, "display", S.Values.getDisplayType(e))), !o) {
                            if ("height" === r && "border-box" !== S.getPropertyValue(e, "boxSizing").toString().toLowerCase()) {
                                var c = e.offsetHeight - (parseFloat(S.getPropertyValue(e, "borderTopWidth")) || 0) - (parseFloat(S.getPropertyValue(e, "borderBottomWidth")) || 0) - (parseFloat(S.getPropertyValue(e, "paddingTop")) || 0) - (parseFloat(S.getPropertyValue(e, "paddingBottom")) || 0);
                                return n(), c
                            }
                            if ("width" === r && "border-box" !== S.getPropertyValue(e, "boxSizing").toString().toLowerCase()) {
                                var p = e.offsetWidth - (parseFloat(S.getPropertyValue(e, "borderLeftWidth")) || 0) - (parseFloat(S.getPropertyValue(e, "borderRightWidth")) || 0) - (parseFloat(S.getPropertyValue(e, "paddingLeft")) || 0) - (parseFloat(S.getPropertyValue(e, "paddingRight")) || 0);
                                return n(), p
                            }
                        }
                        var g;
                        g = i(e) === a ? t.getComputedStyle(e, null) : i(e).computedStyle ? i(e).computedStyle : i(e).computedStyle = t.getComputedStyle(e, null), "borderColor" === r && (r = "borderTopColor"), l = 9 === d && "filter" === r ? g.getPropertyValue(r) : g[r], ("" === l || null === l) && (l = e.style[r]), n()
                    }
                    if ("auto" === l && /^(top|right|bottom|left)$/i.test(r)) {
                        var m = s(e, "position");
                        ("fixed" === m || "absolute" === m && /top|left/i.test(r)) && (l = f(e).position()[r] + "px")
                    }
                    return l
                }
                var l;
                if (S.Hooks.registered[r]) {
                    var u = r,
                        c = S.Hooks.getRoot(u);
                    n === a && (n = S.getPropertyValue(e, S.Names.prefixCheck(c)[0])), S.Normalizations.registered[c] && (n = S.Normalizations.registered[c]("extract", e, n)), l = S.Hooks.extractValue(u, n)
                } else if (S.Normalizations.registered[r]) {
                    var p, g;
                    p = S.Normalizations.registered[r]("name", e), "transform" !== p && (g = s(e, S.Names.prefixCheck(p)[0]), S.Values.isCSSNullValue(g) && S.Hooks.templates[r] && (g = S.Hooks.templates[r][1])), l = S.Normalizations.registered[r]("extract", e, g)
                }
                if (!/^[\d-]/.test(l))
                    if (i(e) && i(e).isSVG && S.Names.SVGAttribute(r))
                        if (/^(height|width)$/i.test(r)) try {
                            l = e.getBBox()[r]
                        } catch (m) {
                            l = 0
                        } else l = e.getAttribute(r);
                        else l = s(e, S.Names.prefixCheck(r)[0]);
                return S.Values.isCSSNullValue(l) && (l = 0), b.debug >= 2 && console.log("Get " + r + ": " + l), l
            },
            setPropertyValue: function(e, r, a, n, o) {
                var s = r;
                if ("scroll" === r) o.container ? o.container["scroll" + o.direction] = a : "Left" === o.direction ? t.scrollTo(a, o.alternateValue) : t.scrollTo(o.alternateValue, a);
                else if (S.Normalizations.registered[r] && "transform" === S.Normalizations.registered[r]("name", e)) S.Normalizations.registered[r]("inject", e, a), s = "transform", a = i(e).transformCache[r];
                else {
                    if (S.Hooks.registered[r]) {
                        var l = r,
                            u = S.Hooks.getRoot(r);
                        n = n || S.getPropertyValue(e, u), a = S.Hooks.injectValue(l, a, n), r = u
                    }
                    if (S.Normalizations.registered[r] && (a = S.Normalizations.registered[r]("inject", e, a), r = S.Normalizations.registered[r]("name", e)), s = S.Names.prefixCheck(r)[0], 8 >= d) try {
                        e.style[s] = a
                    } catch (c) {
                        b.debug && console.log("Browser does not support [" + a + "] for [" + s + "]")
                    } else i(e) && i(e).isSVG && S.Names.SVGAttribute(r) ? e.setAttribute(r, a) : e.style[s] = a;
                    b.debug >= 2 && console.log("Set " + r + " (" + s + "): " + a)
                }
                return [s, a]
            },
            flushTransformCache: function(e) {
                function t(t) {
                    return parseFloat(S.getPropertyValue(e, t))
                }
                var r = "";
                if ((d || b.State.isAndroid && !b.State.isChrome) && i(e).isSVG) {
                    var a = {
                        translate: [t("translateX"), t("translateY")],
                        skewX: [t("skewX")],
                        skewY: [t("skewY")],
                        scale: 1 !== t("scale") ? [t("scale"), t("scale")] : [t("scaleX"), t("scaleY")],
                        rotate: [t("rotateZ"), 0, 0]
                    };
                    f.each(i(e).transformCache, function(e) {
                        /^translate/i.test(e) ? e = "translate" : /^scale/i.test(e) ? e = "scale" : /^rotate/i.test(e) && (e = "rotate"), a[e] && (r += e + "(" + a[e].join(" ") + ") ", delete a[e])
                    })
                } else {
                    var n, o;
                    f.each(i(e).transformCache, function(t) {
                        return n = i(e).transformCache[t], "transformPerspective" === t ? (o = n, !0) : (9 === d && "rotateZ" === t && (t = "rotate"), void(r += t + n + " "))
                    }), o && (r = "perspective" + o + " " + r)
                }
                S.setPropertyValue(e, "transform", r)
            }
        };
        S.Hooks.register(), S.Normalizations.register(), b.hook = function(e, t, r) {
            var n = a;
            return e = o(e), f.each(e, function(e, o) {
                if (i(o) === a && b.init(o), r === a) n === a && (n = b.CSS.getPropertyValue(o, t));
                else {
                    var s = b.CSS.setPropertyValue(o, t, r);
                    "transform" === s[0] && b.CSS.flushTransformCache(o), n = s
                }
            }), n
        };
        var P = function() {
            function e() {
                return s ? k.promise || null : l
            }

            function n() {
                function e() {
                    function e(e, t) {
                        var r = a,
                            n = a,
                            i = a;
                        return m.isArray(e) ? (r = e[0], !m.isArray(e[1]) && /^[\d-]/.test(e[1]) || m.isFunction(e[1]) || S.RegEx.isHex.test(e[1]) ? i = e[1] : (m.isString(e[1]) && !S.RegEx.isHex.test(e[1]) || m.isArray(e[1])) && (n = t ? e[1] : u(e[1], s.duration), e[2] !== a && (i = e[2]))) : r = e, t || (n = n || s.easing), m.isFunction(r) && (r = r.call(o, V, w)), m.isFunction(i) && (i = i.call(o, V, w)), [r || 0, n, i]
                    }

                    function p(e, t) {
                        var r, a;
                        return a = (t || "0").toString().toLowerCase().replace(/[%A-z]+$/, function(e) {
                            return r = e, ""
                        }), r || (r = S.Values.getUnitType(e)), [a, r]
                    }

                    function d() {
                        var e = {
                                myParent: o.parentNode || r.body,
                                position: S.getPropertyValue(o, "position"),
                                fontSize: S.getPropertyValue(o, "fontSize")
                            },
                            a = e.position === L.lastPosition && e.myParent === L.lastParent,
                            n = e.fontSize === L.lastFontSize;
                        L.lastParent = e.myParent, L.lastPosition = e.position, L.lastFontSize = e.fontSize;
                        var s = 100,
                            l = {};
                        if (n && a) l.emToPx = L.lastEmToPx, l.percentToPxWidth = L.lastPercentToPxWidth, l.percentToPxHeight = L.lastPercentToPxHeight;
                        else {
                            var u = i(o).isSVG ? r.createElementNS("http://www.w3.org/2000/svg", "rect") : r.createElement("div");
                            b.init(u), e.myParent.appendChild(u), f.each(["overflow", "overflowX", "overflowY"], function(e, t) {
                                b.CSS.setPropertyValue(u, t, "hidden")
                            }), b.CSS.setPropertyValue(u, "position", e.position), b.CSS.setPropertyValue(u, "fontSize", e.fontSize), b.CSS.setPropertyValue(u, "boxSizing", "content-box"), f.each(["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height"], function(e, t) {
                                b.CSS.setPropertyValue(u, t, s + "%")
                            }), b.CSS.setPropertyValue(u, "paddingLeft", s + "em"), l.percentToPxWidth = L.lastPercentToPxWidth = (parseFloat(S.getPropertyValue(u, "width", null, !0)) || 1) / s, l.percentToPxHeight = L.lastPercentToPxHeight = (parseFloat(S.getPropertyValue(u, "height", null, !0)) || 1) / s, l.emToPx = L.lastEmToPx = (parseFloat(S.getPropertyValue(u, "paddingLeft")) || 1) / s, e.myParent.removeChild(u)
                        }
                        return null === L.remToPx && (L.remToPx = parseFloat(S.getPropertyValue(r.body, "fontSize")) || 16), null === L.vwToPx && (L.vwToPx = parseFloat(t.innerWidth) / 100, L.vhToPx = parseFloat(t.innerHeight) / 100), l.remToPx = L.remToPx, l.vwToPx = L.vwToPx, l.vhToPx = L.vhToPx, b.debug >= 1 && console.log("Unit ratios: " + JSON.stringify(l), o), l
                    }
                    if (s.begin && 0 === V) try {
                        s.begin.call(g, g)
                    } catch (h) {
                        setTimeout(function() {
                            throw h
                        }, 1)
                    }
                    if ("scroll" === A) {
                        var x, P, C, T = /^x$/i.test(s.axis) ? "Left" : "Top",
                            F = parseFloat(s.offset) || 0;
                        s.container ? m.isWrapped(s.container) || m.isNode(s.container) ? (s.container = s.container[0] || s.container, x = s.container["scroll" + T], C = x + f(o).position()[T.toLowerCase()] + F) : s.container = null : (x = b.State.scrollAnchor[b.State["scrollProperty" + T]], P = b.State.scrollAnchor[b.State["scrollProperty" + ("Left" === T ? "Top" : "Left")]], C = f(o).offset()[T.toLowerCase()] + F), l = {
                            scroll: {
                                rootPropertyValue: !1,
                                startValue: x,
                                currentValue: x,
                                endValue: C,
                                unitType: "",
                                easing: s.easing,
                                scrollData: {
                                    container: s.container,
                                    direction: T,
                                    alternateValue: P
                                }
                            },
                            element: o
                        }, b.debug && console.log("tweensContainer (scroll): ", l.scroll, o)
                    } else if ("reverse" === A) {
                        if (!i(o).tweensContainer) return void f.dequeue(o, s.queue);
                        "none" === i(o).opts.display && (i(o).opts.display = "auto"), "hidden" === i(o).opts.visibility && (i(o).opts.visibility = "visible"), i(o).opts.loop = !1, i(o).opts.begin = null, i(o).opts.complete = null, v.easing || delete s.easing, v.duration || delete s.duration, s = f.extend({}, i(o).opts, s);
                        var E = f.extend(!0, {}, i(o).tweensContainer);
                        for (var j in E)
                            if ("element" !== j) {
                                var H = E[j].startValue;
                                E[j].startValue = E[j].currentValue = E[j].endValue, E[j].endValue = H, m.isEmptyObject(v) || (E[j].easing = s.easing), b.debug && console.log("reverse tweensContainer (" + j + "): " + JSON.stringify(E[j]), o)
                            }
                        l = E
                    } else if ("start" === A) {
                        var E;
                        i(o).tweensContainer && i(o).isAnimating === !0 && (E = i(o).tweensContainer), f.each(y, function(t, r) {
                            if (RegExp("^" + S.Lists.colors.join("$|^") + "$").test(t)) {
                                var n = e(r, !0),
                                    o = n[0],
                                    i = n[1],
                                    s = n[2];
                                if (S.RegEx.isHex.test(o)) {
                                    for (var l = ["Red", "Green", "Blue"], u = S.Values.hexToRgb(o), c = s ? S.Values.hexToRgb(s) : a, p = 0; p < l.length; p++) {
                                        var f = [u[p]];
                                        i && f.push(i), c !== a && f.push(c[p]), y[t + l[p]] = f
                                    }
                                    delete y[t]
                                }
                            }
                        });
                        for (var N in y) {
                            var O = e(y[N]),
                                z = O[0],
                                q = O[1],
                                $ = O[2];
                            N = S.Names.camelCase(N);
                            var M = S.Hooks.getRoot(N),
                                I = !1;
                            if (i(o).isSVG || "tween" === M || S.Names.prefixCheck(M)[1] !== !1 || S.Normalizations.registered[M] !== a) {
                                (s.display !== a && null !== s.display && "none" !== s.display || s.visibility !== a && "hidden" !== s.visibility) && /opacity|filter/.test(N) && !$ && 0 !== z && ($ = 0), s._cacheValues && E && E[N] ? ($ === a && ($ = E[N].endValue + E[N].unitType), I = i(o).rootPropertyValueCache[M]) : S.Hooks.registered[N] ? $ === a ? (I = S.getPropertyValue(o, M), $ = S.getPropertyValue(o, N, I)) : I = S.Hooks.templates[M][1] : $ === a && ($ = S.getPropertyValue(o, N));
                                var B, W, G, D = !1;
                                if (B = p(N, $), $ = B[0], G = B[1], B = p(N, z), z = B[0].replace(/^([+-\/*])=/, function(e, t) {
                                        return D = t, ""
                                    }), W = B[1], $ = parseFloat($) || 0, z = parseFloat(z) || 0, "%" === W && (/^(fontSize|lineHeight)$/.test(N) ? (z /= 100, W = "em") : /^scale/.test(N) ? (z /= 100, W = "") : /(Red|Green|Blue)$/i.test(N) && (z = z / 100 * 255, W = "")), /[\/*]/.test(D)) W = G;
                                else if (G !== W && 0 !== $)
                                    if (0 === z) W = G;
                                    else {
                                        n = n || d();
                                        var X = /margin|padding|left|right|width|text|word|letter/i.test(N) || /X$/.test(N) || "x" === N ? "x" : "y";
                                        switch (G) {
                                            case "%":
                                                $ *= "x" === X ? n.percentToPxWidth : n.percentToPxHeight;
                                                break;
                                            case "px":
                                                break;
                                            default:
                                                $ *= n[G + "ToPx"]
                                        }
                                        switch (W) {
                                            case "%":
                                                $ *= 1 / ("x" === X ? n.percentToPxWidth : n.percentToPxHeight);
                                                break;
                                            case "px":
                                                break;
                                            default:
                                                $ *= 1 / n[W + "ToPx"]
                                        }
                                    }
                                switch (D) {
                                    case "+":
                                        z = $ + z;
                                        break;
                                    case "-":
                                        z = $ - z;
                                        break;
                                    case "*":
                                        z = $ * z;
                                        break;
                                    case "/":
                                        z = $ / z
                                }
                                l[N] = {
                                    rootPropertyValue: I,
                                    startValue: $,
                                    currentValue: $,
                                    endValue: z,
                                    unitType: W,
                                    easing: q
                                }, b.debug && console.log("tweensContainer (" + N + "): " + JSON.stringify(l[N]), o)
                            } else b.debug && console.log("Skipping [" + M + "] due to a lack of browser support.")
                        }
                        l.element = o
                    }
                    l.element && (S.Values.addClass(o, "velocity-animating"), R.push(l), "" === s.queue && (i(o).tweensContainer = l, i(o).opts = s), i(o).isAnimating = !0, V === w - 1 ? (b.State.calls.push([R, g, s, null, k.resolver]), b.State.isTicking === !1 && (b.State.isTicking = !0, c())) : V++)
                }
                var n, o = this,
                    s = f.extend({}, b.defaults, v),
                    l = {};
                switch (i(o) === a && b.init(o), parseFloat(s.delay) && s.queue !== !1 && f.queue(o, s.queue, function(e) {
                    b.velocityQueueEntryFlag = !0, i(o).delayTimer = {
                        setTimeout: setTimeout(e, parseFloat(s.delay)),
                        next: e
                    }
                }), s.duration.toString().toLowerCase()) {
                    case "fast":
                        s.duration = 200;
                        break;
                    case "normal":
                        s.duration = h;
                        break;
                    case "slow":
                        s.duration = 600;
                        break;
                    default:
                        s.duration = parseFloat(s.duration) || 1
                }
                b.mock !== !1 && (b.mock === !0 ? s.duration = s.delay = 1 : (s.duration *= parseFloat(b.mock) || 1, s.delay *= parseFloat(b.mock) || 1)), s.easing = u(s.easing, s.duration), s.begin && !m.isFunction(s.begin) && (s.begin = null), s.progress && !m.isFunction(s.progress) && (s.progress = null), s.complete && !m.isFunction(s.complete) && (s.complete = null), s.display !== a && null !== s.display && (s.display = s.display.toString().toLowerCase(), "auto" === s.display && (s.display = b.CSS.Values.getDisplayType(o))), s.visibility !== a && null !== s.visibility && (s.visibility = s.visibility.toString().toLowerCase()), s.mobileHA = s.mobileHA && b.State.isMobile && !b.State.isGingerbread, s.queue === !1 ? s.delay ? setTimeout(e, s.delay) : e() : f.queue(o, s.queue, function(t, r) {
                    return r === !0 ? (k.promise && k.resolver(g), !0) : (b.velocityQueueEntryFlag = !0, void e(t))
                }), "" !== s.queue && "fx" !== s.queue || "inprogress" === f.queue(o)[0] || f.dequeue(o)
            }
            var s, l, d, g, y, v, x = arguments[0] && (arguments[0].p || f.isPlainObject(arguments[0].properties) && !arguments[0].properties.names || m.isString(arguments[0].properties));
            if (m.isWrapped(this) ? (s = !1, d = 0, g = this, l = this) : (s = !0, d = 1, g = x ? arguments[0].elements || arguments[0].e : arguments[0]), g = o(g)) {
                x ? (y = arguments[0].properties || arguments[0].p, v = arguments[0].options || arguments[0].o) : (y = arguments[d], v = arguments[d + 1]);
                var w = g.length,
                    V = 0;
                if (!/^(stop|finish|finishAll)$/i.test(y) && !f.isPlainObject(v)) {
                    var C = d + 1;
                    v = {};
                    for (var T = C; T < arguments.length; T++) m.isArray(arguments[T]) || !/^(fast|normal|slow)$/i.test(arguments[T]) && !/^\d/.test(arguments[T]) ? m.isString(arguments[T]) || m.isArray(arguments[T]) ? v.easing = arguments[T] : m.isFunction(arguments[T]) && (v.complete = arguments[T]) : v.duration = arguments[T]
                }
                var k = {
                    promise: null,
                    resolver: null,
                    rejecter: null
                };
                s && b.Promise && (k.promise = new b.Promise(function(e, t) {
                    k.resolver = e, k.rejecter = t
                }));
                var A;
                switch (y) {
                    case "scroll":
                        A = "scroll";
                        break;
                    case "reverse":
                        A = "reverse";
                        break;
                    case "finish":
                    case "finishAll":
                    case "stop":
                        f.each(g, function(e, t) {
                            i(t) && i(t).delayTimer && (clearTimeout(i(t).delayTimer.setTimeout), i(t).delayTimer.next && i(t).delayTimer.next(), delete i(t).delayTimer), "finishAll" !== y || v !== !0 && !m.isString(v) || (f.each(f.queue(t, m.isString(v) ? v : ""), function(e, t) {
                                m.isFunction(t) && t()
                            }), f.queue(t, m.isString(v) ? v : "", []))
                        });
                        var F = [];
                        return f.each(b.State.calls, function(e, t) {
                            t && f.each(t[1], function(r, n) {
                                var o = v === a ? "" : v;
                                return o === !0 || t[2].queue === o || v === a && t[2].queue === !1 ? void f.each(g, function(r, a) {
                                    a === n && ((v === !0 || m.isString(v)) && (f.each(f.queue(a, m.isString(v) ? v : ""), function(e, t) {
                                        m.isFunction(t) && t(null, !0)
                                    }), f.queue(a, m.isString(v) ? v : "", [])), "stop" === y ? (i(a) && i(a).tweensContainer && o !== !1 && f.each(i(a).tweensContainer, function(e, t) {
                                        t.endValue = t.currentValue
                                    }), F.push(e)) : ("finish" === y || "finishAll" === y) && (t[2].duration = 1))
                                }) : !0
                            })
                        }), "stop" === y && (f.each(F, function(e, t) {
                            p(t, !0)
                        }), k.promise && k.resolver(g)), e();
                    default:
                        if (!f.isPlainObject(y) || m.isEmptyObject(y)) {
                            if (m.isString(y) && b.Redirects[y]) {
                                var E = f.extend({}, v),
                                    j = E.duration,
                                    H = E.delay || 0;
                                return E.backwards === !0 && (g = f.extend(!0, [], g).reverse()), f.each(g, function(e, t) {
                                    parseFloat(E.stagger) ? E.delay = H + parseFloat(E.stagger) * e : m.isFunction(E.stagger) && (E.delay = H + E.stagger.call(t, e, w)), E.drag && (E.duration = parseFloat(j) || (/^(callout|transition)/.test(y) ? 1e3 : h), E.duration = Math.max(E.duration * (E.backwards ? 1 - e / w : (e + 1) / w), .75 * E.duration, 200)), b.Redirects[y].call(t, t, E || {}, e, w, g, k.promise ? k : a)
                                }), e()
                            }
                            var N = "Velocity: First argument (" + y + ") was not a property map, a known action, or a registered redirect. Aborting.";
                            return k.promise ? k.rejecter(new Error(N)) : console.log(N), e()
                        }
                        A = "start"
                }
                var L = {
                        lastParent: null,
                        lastPosition: null,
                        lastFontSize: null,
                        lastPercentToPxWidth: null,
                        lastPercentToPxHeight: null,
                        lastEmToPx: null,
                        remToPx: null,
                        vwToPx: null,
                        vhToPx: null
                    },
                    R = [];
                f.each(g, function(e, t) {
                    m.isNode(t) && n.call(t)
                });
                var O, E = f.extend({}, b.defaults, v);
                if (E.loop = parseInt(E.loop), O = 2 * E.loop - 1, E.loop)
                    for (var z = 0; O > z; z++) {
                        var q = {
                            delay: E.delay,
                            progress: E.progress
                        };
                        z === O - 1 && (q.display = E.display, q.visibility = E.visibility, q.complete = E.complete), P(g, "reverse", q)
                    }
                return e()
            }
        };
        b = f.extend(P, b), b.animate = P;
        var w = t.requestAnimationFrame || g;
        return b.State.isMobile || r.hidden === a || r.addEventListener("visibilitychange", function() {
            r.hidden ? (w = function(e) {
                return setTimeout(function() {
                    e(!0)
                }, 16)
            }, c()) : w = t.requestAnimationFrame || g
        }), e.Velocity = b, e !== t && (e.fn.velocity = P, e.fn.velocity.defaults = b.defaults), f.each(["Down", "Up"], function(e, t) {
            b.Redirects["slide" + t] = function(e, r, n, o, i, s) {
                var l = f.extend({}, r),
                    u = l.begin,
                    c = l.complete,
                    p = {
                        height: "",
                        marginTop: "",
                        marginBottom: "",
                        paddingTop: "",
                        paddingBottom: ""
                    },
                    d = {};
                l.display === a && (l.display = "Down" === t ? "inline" === b.CSS.Values.getDisplayType(e) ? "inline-block" : "block" : "none"), l.begin = function() {
                    u && u.call(i, i);
                    for (var r in p) {
                        d[r] = e.style[r];
                        var a = b.CSS.getPropertyValue(e, r);
                        p[r] = "Down" === t ? [a, 0] : [0, a]
                    }
                    d.overflow = e.style.overflow, e.style.overflow = "hidden"
                }, l.complete = function() {
                    for (var t in d) e.style[t] = d[t];
                    c && c.call(i, i), s && s.resolver(i)
                }, b(e, p, l)
            }
        }), f.each(["In", "Out"], function(e, t) {
            b.Redirects["fade" + t] = function(e, r, n, o, i, s) {
                var l = f.extend({}, r),
                    u = {
                        opacity: "In" === t ? 1 : 0
                    },
                    c = l.complete;
                l.complete = n !== o - 1 ? l.begin = null : function() {
                    c && c.call(i, i), s && s.resolver(i)
                }, l.display === a && (l.display = "In" === t ? "auto" : "none"), b(this, u, l)
            }
        }), b
    }(window.jQuery || window.Zepto || window, window, document)
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJ2ZWxvY2l0eS5taW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiISBmdW5jdGlvbihlKSB7XG4gICAgZnVuY3Rpb24gdChlKSB7XG4gICAgICAgIHZhciB0ID0gZS5sZW5ndGgsXG4gICAgICAgICAgICBhID0gci50eXBlKGUpO1xuICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSBhIHx8IHIuaXNXaW5kb3coZSkgPyAhMSA6IDEgPT09IGUubm9kZVR5cGUgJiYgdCA/ICEwIDogXCJhcnJheVwiID09PSBhIHx8IDAgPT09IHQgfHwgXCJudW1iZXJcIiA9PSB0eXBlb2YgdCAmJiB0ID4gMCAmJiB0IC0gMSBpbiBlXG4gICAgfVxuICAgIGlmICghZS5qUXVlcnkpIHtcbiAgICAgICAgdmFyIHIgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHIuZm4uaW5pdChlLCB0KVxuICAgICAgICB9O1xuICAgICAgICByLmlzV2luZG93ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgIT0gZSAmJiBlID09IGUud2luZG93XG4gICAgICAgIH0sIHIudHlwZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsID09IGUgPyBlICsgXCJcIiA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlID8gbltpLmNhbGwoZSldIHx8IFwib2JqZWN0XCIgOiB0eXBlb2YgZVxuICAgICAgICB9LCByLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBcImFycmF5XCIgPT09IHIudHlwZShlKVxuICAgICAgICB9LCByLmlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgIGlmICghZSB8fCBcIm9iamVjdFwiICE9PSByLnR5cGUoZSkgfHwgZS5ub2RlVHlwZSB8fCByLmlzV2luZG93KGUpKSByZXR1cm4gITE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChlLmNvbnN0cnVjdG9yICYmICFvLmNhbGwoZSwgXCJjb25zdHJ1Y3RvclwiKSAmJiAhby5jYWxsKGUuY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIikpIHJldHVybiAhMVxuICAgICAgICAgICAgfSBjYXRjaCAoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh0IGluIGUpO1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdCB8fCBvLmNhbGwoZSwgdClcbiAgICAgICAgfSwgci5lYWNoID0gZnVuY3Rpb24oZSwgciwgYSkge1xuICAgICAgICAgICAgdmFyIG4sIG8gPSAwLFxuICAgICAgICAgICAgICAgIGkgPSBlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzID0gdChlKTtcbiAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpID4gbyAmJiAobiA9IHIuYXBwbHkoZVtvXSwgYSksIG4gIT09ICExKTsgbysrKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGZvciAobyBpbiBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gPSByLmFwcGx5KGVbb10sIGEpLCBuID09PSAhMSkgYnJlYWtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocylcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA+IG8gJiYgKG4gPSByLmNhbGwoZVtvXSwgbywgZVtvXSksIG4gIT09ICExKTsgbysrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmb3IgKG8gaW4gZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPSByLmNhbGwoZVtvXSwgbywgZVtvXSksIG4gPT09ICExKSBicmVhazsgcmV0dXJuIGVcbiAgICAgICAgfSwgci5kYXRhID0gZnVuY3Rpb24oZSwgdCwgbikge1xuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gbikge1xuICAgICAgICAgICAgICAgIHZhciBvID0gZVtyLmV4cGFuZG9dLFxuICAgICAgICAgICAgICAgICAgICBpID0gbyAmJiBhW29dO1xuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHQpIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIGlmIChpICYmIHQgaW4gaSkgcmV0dXJuIGlbdF1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodm9pZCAwICE9PSB0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG8gPSBlW3IuZXhwYW5kb10gfHwgKGVbci5leHBhbmRvXSA9ICsrci51dWlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVtvXSA9IGFbb10gfHwge30sIGFbb11bdF0gPSBuLCBuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHIucmVtb3ZlRGF0YSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgIHZhciBuID0gZVtyLmV4cGFuZG9dLFxuICAgICAgICAgICAgICAgIG8gPSBuICYmIGFbbl07XG4gICAgICAgICAgICBvICYmIHIuZWFjaCh0LCBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9bdF1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIHIuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZSwgdCwgYSwgbiwgbywgaSwgcyA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgICAgICAgICBsID0gMSxcbiAgICAgICAgICAgICAgICB1ID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjID0gITE7XG4gICAgICAgICAgICBmb3IgKFwiYm9vbGVhblwiID09IHR5cGVvZiBzICYmIChjID0gcywgcyA9IGFyZ3VtZW50c1tsXSB8fCB7fSwgbCsrKSwgXCJvYmplY3RcIiAhPSB0eXBlb2YgcyAmJiBcImZ1bmN0aW9uXCIgIT09IHIudHlwZShzKSAmJiAocyA9IHt9KSwgbCA9PT0gdSAmJiAocyA9IHRoaXMsIGwtLSk7IHUgPiBsOyBsKyspXG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gKG8gPSBhcmd1bWVudHNbbF0pKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKG4gaW4gbykgZSA9IHNbbl0sIGEgPSBvW25dLCBzICE9PSBhICYmIChjICYmIGEgJiYgKHIuaXNQbGFpbk9iamVjdChhKSB8fCAodCA9IHIuaXNBcnJheShhKSkpID8gKHQgPyAodCA9ICExLCBpID0gZSAmJiByLmlzQXJyYXkoZSkgPyBlIDogW10pIDogaSA9IGUgJiYgci5pc1BsYWluT2JqZWN0KGUpID8gZSA6IHt9LCBzW25dID0gci5leHRlbmQoYywgaSwgYSkpIDogdm9pZCAwICE9PSBhICYmIChzW25dID0gYSkpO1xuICAgICAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgfSwgci5xdWV1ZSA9IGZ1bmN0aW9uKGUsIGEsIG4pIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG8oZSwgcikge1xuICAgICAgICAgICAgICAgIHZhciBhID0gciB8fCBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCAhPSBlICYmICh0KE9iamVjdChlKSkgPyAhIGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9ICt0Lmxlbmd0aCwgYSA9IDAsIG4gPSBlLmxlbmd0aDsgciA+IGE7KSBlW24rK10gPSB0W2ErK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChyICE9PSByKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IHZvaWQgMCAhPT0gdFthXTspIGVbbisrXSA9IHRbYSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUubGVuZ3RoID0gbiwgZVxuICAgICAgICAgICAgICAgIH0oYSwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IFtlXSA6IGUpIDogW10ucHVzaC5jYWxsKGEsIGUpKSwgYVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBhID0gKGEgfHwgXCJmeFwiKSArIFwicXVldWVcIjtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHIuZGF0YShlLCBhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbiA/ICghaSB8fCByLmlzQXJyYXkobikgPyBpID0gci5kYXRhKGUsIGEsIG8obikpIDogaS5wdXNoKG4pLCBpKSA6IGkgfHwgW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgci5kZXF1ZXVlID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgci5lYWNoKGUubm9kZVR5cGUgPyBbZV0gOiBlLCBmdW5jdGlvbihlLCBhKSB7XG4gICAgICAgICAgICAgICAgdCA9IHQgfHwgXCJmeFwiO1xuICAgICAgICAgICAgICAgIHZhciBuID0gci5xdWV1ZShhLCB0KSxcbiAgICAgICAgICAgICAgICAgICAgbyA9IG4uc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBcImlucHJvZ3Jlc3NcIiA9PT0gbyAmJiAobyA9IG4uc2hpZnQoKSksIG8gJiYgKFwiZnhcIiA9PT0gdCAmJiBuLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpLCBvLmNhbGwoYSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHIuZGVxdWV1ZShhLCB0KVxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgci5mbiA9IHIucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLm5vZGVUeXBlKSByZXR1cm4gdGhpc1swXSA9IGUsIHRoaXM7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgRE9NIG5vZGUuXCIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID8gdGhpc1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IHQudG9wICsgKGUucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuc2Nyb2xsVG9wIHx8IDApIC0gKGRvY3VtZW50LmNsaWVudFRvcCB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdC5sZWZ0ICsgKGUucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2N1bWVudC5jbGllbnRMZWZ0IHx8IDApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gdGhpcy5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQ7IGUgJiYgXCJodG1sXCIgPT09ICFlLm5vZGVUeXBlLnRvTG93ZXJDYXNlICYmIFwic3RhdGljXCIgPT09IGUuc3R5bGUucG9zaXRpb247KSBlID0gZS5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlIHx8IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpc1swXSxcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUuYXBwbHkodCksXG4gICAgICAgICAgICAgICAgICAgIGEgPSB0aGlzLm9mZnNldCgpLFxuICAgICAgICAgICAgICAgICAgICBuID0gL14oPzpib2R5fGh0bWwpJC9pLnRlc3QoZS5ub2RlTmFtZSkgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgICAgICAgICAgICAgIH0gOiByKGUpLm9mZnNldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnRvcCAtPSBwYXJzZUZsb2F0KHQuc3R5bGUubWFyZ2luVG9wKSB8fCAwLCBhLmxlZnQgLT0gcGFyc2VGbG9hdCh0LnN0eWxlLm1hcmdpbkxlZnQpIHx8IDAsIGUuc3R5bGUgJiYgKG4udG9wICs9IHBhcnNlRmxvYXQoZS5zdHlsZS5ib3JkZXJUb3BXaWR0aCkgfHwgMCwgbi5sZWZ0ICs9IHBhcnNlRmxvYXQoZS5zdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIHx8IDApLCB7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogYS50b3AgLSBuLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogYS5sZWZ0IC0gbi5sZWZ0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYSA9IHt9O1xuICAgICAgICByLmV4cGFuZG8gPSBcInZlbG9jaXR5XCIgKyAobmV3IERhdGUpLmdldFRpbWUoKSwgci51dWlkID0gMDtcbiAgICAgICAgZm9yICh2YXIgbiA9IHt9LCBvID0gbi5oYXNPd25Qcm9wZXJ0eSwgaSA9IG4udG9TdHJpbmcsIHMgPSBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3JcIi5zcGxpdChcIiBcIiksIGwgPSAwOyBsIDwgcy5sZW5ndGg7IGwrKykgbltcIltvYmplY3QgXCIgKyBzW2xdICsgXCJdXCJdID0gc1tsXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByLmZuLmluaXQucHJvdG90eXBlID0gci5mbiwgZS5WZWxvY2l0eSA9IHtcbiAgICAgICAgICAgIFV0aWxpdGllczogclxuICAgICAgICB9XG4gICAgfVxufSh3aW5kb3cpLFxuZnVuY3Rpb24oZSkge1xuICAgIFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA/IG1vZHVsZS5leHBvcnRzID0gZSgpIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShlKSA6IGUoKVxufShmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSwgdCwgciwgYSkge1xuICAgICAgICBmdW5jdGlvbiBuKGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAtMSwgciA9IGUgPyBlLmxlbmd0aCA6IDAsIGEgPSBbXTsgKyt0IDwgcjspIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGVbdF07XG4gICAgICAgICAgICAgICAgbiAmJiBhLnB1c2gobilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmlzV3JhcHBlZChlKSA/IGUgPSBbXS5zbGljZS5jYWxsKGUpIDogbS5pc05vZGUoZSkgJiYgKGUgPSBbZV0pLCBlXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpKGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gZi5kYXRhKGUsIFwidmVsb2NpdHlcIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PT0gdCA/IGEgOiB0XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodCAqIGUpICogKDEgLyBlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbChlLCByLCBhLCBuKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBvKGUsIHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAtIDMgKiB0ICsgMyAqIGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaShlLCB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDMgKiB0IC0gNiAqIGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcyhlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDMgKiBlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSwgdCwgcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG8odCwgcikgKiBlICsgaSh0LCByKSkgKiBlICsgcyh0KSkgKiBlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSwgdCwgcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAzICogbyh0LCByKSAqIGUgKiBlICsgMiAqIGkodCwgcikgKiBlICsgcyh0KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjKHQsIHIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbSA+IG47ICsrbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHUociwgZSwgYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvKSByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBsKHIsIGUsIGEpIC0gdDtcbiAgICAgICAgICAgICAgICAgICAgciAtPSBpIC8gb1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gclxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyBiID4gdDsgKyt0KSB3W3RdID0gbCh0ICogeCwgZSwgYSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZih0LCByLCBuKSB7XG4gICAgICAgICAgICAgICAgdmFyIG8sIGksIHMgPSAwO1xuICAgICAgICAgICAgICAgIGRvIGkgPSByICsgKG4gLSByKSAvIDIsIG8gPSBsKGksIGUsIGEpIC0gdCwgbyA+IDAgPyBuID0gaSA6IHIgPSBpOyB3aGlsZSAoTWF0aC5hYnMobykgPiBoICYmICsrcyA8IHYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGQodCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBuID0gMSwgbyA9IGIgLSAxOyBuICE9IG8gJiYgd1tuXSA8PSB0OyArK24pIHIgKz0geDtcbiAgICAgICAgICAgICAgICAtLW47XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAodCAtIHdbbl0pIC8gKHdbbiArIDFdIC0gd1tuXSksXG4gICAgICAgICAgICAgICAgICAgIHMgPSByICsgaSAqIHgsXG4gICAgICAgICAgICAgICAgICAgIGwgPSB1KHMsIGUsIGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsID49IHkgPyBjKHQsIHMpIDogMCA9PSBsID8gcyA6IGYodCwgciwgciArIHgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgICAgICAgICAgViA9ICEwLCAoZSAhPSByIHx8IGEgIT0gbikgJiYgcCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbSA9IDQsXG4gICAgICAgICAgICAgICAgeSA9IC4wMDEsXG4gICAgICAgICAgICAgICAgaCA9IDFlLTcsXG4gICAgICAgICAgICAgICAgdiA9IDEwLFxuICAgICAgICAgICAgICAgIGIgPSAxMSxcbiAgICAgICAgICAgICAgICB4ID0gMSAvIChiIC0gMSksXG4gICAgICAgICAgICAgICAgUyA9IFwiRmxvYXQzMkFycmF5XCIgaW4gdDtcbiAgICAgICAgICAgIGlmICg0ICE9PSBhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgICAgICAgICBmb3IgKHZhciBQID0gMDsgNCA+IFA7ICsrUClcbiAgICAgICAgICAgICAgICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgYXJndW1lbnRzW1BdIHx8IGlzTmFOKGFyZ3VtZW50c1tQXSkgfHwgIWlzRmluaXRlKGFyZ3VtZW50c1tQXSkpIHJldHVybiAhMTtcbiAgICAgICAgICAgIGUgPSBNYXRoLm1pbihlLCAxKSwgYSA9IE1hdGgubWluKGEsIDEpLCBlID0gTWF0aC5tYXgoZSwgMCksIGEgPSBNYXRoLm1heChhLCAwKTtcbiAgICAgICAgICAgIHZhciB3ID0gUyA/IG5ldyBGbG9hdDMyQXJyYXkoYikgOiBuZXcgQXJyYXkoYiksXG4gICAgICAgICAgICAgICAgViA9ICExLFxuICAgICAgICAgICAgICAgIEMgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWIHx8IGcoKSwgZSA9PT0gciAmJiBhID09PSBuID8gdCA6IDAgPT09IHQgPyAwIDogMSA9PT0gdCA/IDEgOiBsKGQodCksIHIsIG4pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEMuZ2V0Q29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICB4OiBlLFxuICAgICAgICAgICAgICAgICAgICB5OiByXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB4OiBhLFxuICAgICAgICAgICAgICAgICAgICB5OiBuXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgVCA9IFwiZ2VuZXJhdGVCZXppZXIoXCIgKyBbZSwgciwgYSwgbl0gKyBcIilcIjtcbiAgICAgICAgICAgIHJldHVybiBDLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRcbiAgICAgICAgICAgIH0sIENcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHUoZSwgdCkge1xuICAgICAgICAgICAgdmFyIHIgPSBlO1xuICAgICAgICAgICAgcmV0dXJuIG0uaXNTdHJpbmcoZSkgPyBiLkVhc2luZ3NbZV0gfHwgKHIgPSAhMSkgOiByID0gbS5pc0FycmF5KGUpICYmIDEgPT09IGUubGVuZ3RoID8gcy5hcHBseShudWxsLCBlKSA6IG0uaXNBcnJheShlKSAmJiAyID09PSBlLmxlbmd0aCA/IHguYXBwbHkobnVsbCwgZS5jb25jYXQoW3RdKSkgOiBtLmlzQXJyYXkoZSkgJiYgNCA9PT0gZS5sZW5ndGggPyBsLmFwcGx5KG51bGwsIGUpIDogITEsIHIgPT09ICExICYmIChyID0gYi5FYXNpbmdzW2IuZGVmYXVsdHMuZWFzaW5nXSA/IGIuZGVmYXVsdHMuZWFzaW5nIDogdiksIHJcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGMoZSkge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IChuZXcgRGF0ZSkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICAgICAgICByID0gYi5TdGF0ZS5jYWxscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgciA+IDFlNCAmJiAoYi5TdGF0ZS5jYWxscyA9IG4oYi5TdGF0ZS5jYWxscykpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG8gPSAwOyByID4gbzsgbysrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYi5TdGF0ZS5jYWxsc1tvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBiLlN0YXRlLmNhbGxzW29dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBzWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzWzNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSAhIWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBkIHx8IChkID0gYi5TdGF0ZS5jYWxsc1tvXVszXSA9IHQgLSAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBoID0gTWF0aC5taW4oKHQgLSBkKSAvIHUuZHVyYXRpb24sIDEpLCB2ID0gMCwgeCA9IGwubGVuZ3RoOyB4ID4gdjsgdisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFAgPSBsW3ZdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWID0gUC5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpKFYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1LmRpc3BsYXkgIT09IGEgJiYgbnVsbCAhPT0gdS5kaXNwbGF5ICYmIFwibm9uZVwiICE9PSB1LmRpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImZsZXhcIiA9PT0gdS5kaXNwbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFQgPSBbXCItd2Via2l0LWJveFwiLCBcIi1tb3otYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCItd2Via2l0LWZsZXhcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5lYWNoKFQsIGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUy5zZXRQcm9wZXJ0eVZhbHVlKFYsIFwiZGlzcGxheVwiLCB0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTLnNldFByb3BlcnR5VmFsdWUoViwgXCJkaXNwbGF5XCIsIHUuZGlzcGxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1LnZpc2liaWxpdHkgIT09IGEgJiYgXCJoaWRkZW5cIiAhPT0gdS52aXNpYmlsaXR5ICYmIFMuc2V0UHJvcGVydHlWYWx1ZShWLCBcInZpc2liaWxpdHlcIiwgdS52aXNpYmlsaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBQKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZWxlbWVudFwiICE9PSBrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEEsIEYgPSBQW2tdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFID0gbS5pc1N0cmluZyhGLmVhc2luZykgPyBiLkVhc2luZ3NbRi5lYXNpbmddIDogRi5lYXNpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDEgPT09IGgpIEEgPSBGLmVuZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IEYuZW5kVmFsdWUgLSBGLnN0YXJ0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBID0gRi5zdGFydFZhbHVlICsgaiAqIEUoaCwgdSwgaiksICFnICYmIEEgPT09IEYuY3VycmVudFZhbHVlKSBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRi5jdXJyZW50VmFsdWUgPSBBLCBcInR3ZWVuXCIgPT09IGspIHkgPSBBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoUy5Ib29rcy5yZWdpc3RlcmVkW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgSCA9IFMuSG9va3MuZ2V0Um9vdChrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOID0gaShWKS5yb290UHJvcGVydHlWYWx1ZUNhY2hlW0hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTiAmJiAoRi5yb290UHJvcGVydHlWYWx1ZSA9IE4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEwgPSBTLnNldFByb3BlcnR5VmFsdWUoViwgaywgRi5jdXJyZW50VmFsdWUgKyAoMCA9PT0gcGFyc2VGbG9hdChBKSA/IFwiXCIgOiBGLnVuaXRUeXBlKSwgRi5yb290UHJvcGVydHlWYWx1ZSwgRi5zY3JvbGxEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUy5Ib29rcy5yZWdpc3RlcmVkW2tdICYmIChpKFYpLnJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGVbSF0gPSBTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbSF0gPyBTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbSF0oXCJleHRyYWN0XCIsIG51bGwsIExbMV0pIDogTFsxXSksIFwidHJhbnNmb3JtXCIgPT09IExbMF0gJiYgKEMgPSAhMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUubW9iaWxlSEEgJiYgaShWKS50cmFuc2Zvcm1DYWNoZS50cmFuc2xhdGUzZCA9PT0gYSAmJiAoaShWKS50cmFuc2Zvcm1DYWNoZS50cmFuc2xhdGUzZCA9IFwiKDBweCwgMHB4LCAwcHgpXCIsIEMgPSAhMCksIEMgJiYgUy5mbHVzaFRyYW5zZm9ybUNhY2hlKFYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdS5kaXNwbGF5ICE9PSBhICYmIFwibm9uZVwiICE9PSB1LmRpc3BsYXkgJiYgKGIuU3RhdGUuY2FsbHNbb11bMl0uZGlzcGxheSA9ICExKSwgdS52aXNpYmlsaXR5ICE9PSBhICYmIFwiaGlkZGVuXCIgIT09IHUudmlzaWJpbGl0eSAmJiAoYi5TdGF0ZS5jYWxsc1tvXVsyXS52aXNpYmlsaXR5ID0gITEpLCB1LnByb2dyZXNzICYmIHUucHJvZ3Jlc3MuY2FsbChzWzFdLCBzWzFdLCBoLCBNYXRoLm1heCgwLCBkICsgdS5kdXJhdGlvbiAtIHQpLCBkLCB5KSwgMSA9PT0gaCAmJiBwKG8pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIuU3RhdGUuaXNUaWNraW5nICYmIHcoYylcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHAoZSwgdCkge1xuICAgICAgICAgICAgaWYgKCFiLlN0YXRlLmNhbGxzW2VdKSByZXR1cm4gITE7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gYi5TdGF0ZS5jYWxsc1tlXVswXSwgbiA9IGIuU3RhdGUuY2FsbHNbZV1bMV0sIG8gPSBiLlN0YXRlLmNhbGxzW2VdWzJdLCBzID0gYi5TdGF0ZS5jYWxsc1tlXVs0XSwgbCA9ICExLCB1ID0gMCwgYyA9IHIubGVuZ3RoOyBjID4gdTsgdSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSByW3VdLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHQgfHwgby5sb29wIHx8IChcIm5vbmVcIiA9PT0gby5kaXNwbGF5ICYmIFMuc2V0UHJvcGVydHlWYWx1ZShwLCBcImRpc3BsYXlcIiwgby5kaXNwbGF5KSwgXCJoaWRkZW5cIiA9PT0gby52aXNpYmlsaXR5ICYmIFMuc2V0UHJvcGVydHlWYWx1ZShwLCBcInZpc2liaWxpdHlcIiwgby52aXNpYmlsaXR5KSksIG8ubG9vcCAhPT0gITAgJiYgKGYucXVldWUocClbMV0gPT09IGEgfHwgIS9cXC52ZWxvY2l0eVF1ZXVlRW50cnlGbGFnL2kudGVzdChmLnF1ZXVlKHApWzFdKSkgJiYgaShwKSkge1xuICAgICAgICAgICAgICAgICAgICBpKHApLmlzQW5pbWF0aW5nID0gITEsIGkocCkucm9vdFByb3BlcnR5VmFsdWVDYWNoZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9ICExO1xuICAgICAgICAgICAgICAgICAgICBmLmVhY2goUy5MaXN0cy50cmFuc2Zvcm1zM0QsIGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gL15zY2FsZS8udGVzdCh0KSA/IDEgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBpKHApLnRyYW5zZm9ybUNhY2hlW3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaShwKS50cmFuc2Zvcm1DYWNoZVt0XSAhPT0gYSAmJiBuZXcgUmVnRXhwKFwiXlxcXFwoXCIgKyByICsgXCJbXi5dXCIpLnRlc3QobikgJiYgKGQgPSAhMCwgZGVsZXRlIGkocCkudHJhbnNmb3JtQ2FjaGVbdF0pXG4gICAgICAgICAgICAgICAgICAgIH0pLCBvLm1vYmlsZUhBICYmIChkID0gITAsIGRlbGV0ZSBpKHApLnRyYW5zZm9ybUNhY2hlLnRyYW5zbGF0ZTNkKSwgZCAmJiBTLmZsdXNoVHJhbnNmb3JtQ2FjaGUocCksIFMuVmFsdWVzLnJlbW92ZUNsYXNzKHAsIFwidmVsb2NpdHktYW5pbWF0aW5nXCIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdCAmJiBvLmNvbXBsZXRlICYmICFvLmxvb3AgJiYgdSA9PT0gYyAtIDEpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG8uY29tcGxldGUuY2FsbChuLCBuKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGdcbiAgICAgICAgICAgICAgICAgICAgfSwgMSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcyAmJiBvLmxvb3AgIT09ICEwICYmIHMobiksIGkocCkgJiYgby5sb29wID09PSAhMCAmJiAhdCAmJiAoZi5lYWNoKGkocCkudHdlZW5zQ29udGFpbmVyLCBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIC9ecm90YXRlLy50ZXN0KGUpICYmIDM2MCA9PT0gcGFyc2VGbG9hdCh0LmVuZFZhbHVlKSAmJiAodC5lbmRWYWx1ZSA9IDAsIHQuc3RhcnRWYWx1ZSA9IDM2MCksIC9eYmFja2dyb3VuZFBvc2l0aW9uLy50ZXN0KGUpICYmIDEwMCA9PT0gcGFyc2VGbG9hdCh0LmVuZFZhbHVlKSAmJiBcIiVcIiA9PT0gdC51bml0VHlwZSAmJiAodC5lbmRWYWx1ZSA9IDAsIHQuc3RhcnRWYWx1ZSA9IDEwMClcbiAgICAgICAgICAgICAgICB9KSwgYihwLCBcInJldmVyc2VcIiwge1xuICAgICAgICAgICAgICAgICAgICBsb29wOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZGVsYXk6IG8uZGVsYXlcbiAgICAgICAgICAgICAgICB9KSksIG8ucXVldWUgIT09ICExICYmIGYuZGVxdWV1ZShwLCBvLnF1ZXVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi5TdGF0ZS5jYWxsc1tlXSA9ICExO1xuICAgICAgICAgICAgZm9yICh2YXIgbSA9IDAsIHkgPSBiLlN0YXRlLmNhbGxzLmxlbmd0aDsgeSA+IG07IG0rKylcbiAgICAgICAgICAgICAgICBpZiAoYi5TdGF0ZS5jYWxsc1ttXSAhPT0gITEpIHtcbiAgICAgICAgICAgICAgICAgICAgbCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGwgPT09ICExICYmIChiLlN0YXRlLmlzVGlja2luZyA9ICExLCBkZWxldGUgYi5TdGF0ZS5jYWxscywgYi5TdGF0ZS5jYWxscyA9IFtdKVxuICAgICAgICB9XG4gICAgICAgIHZhciBmLCBkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHIuZG9jdW1lbnRNb2RlKSByZXR1cm4gci5kb2N1bWVudE1vZGU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDc7IGUgPiA0OyBlLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSByLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmlubmVySFRNTCA9IFwiPCEtLVtpZiBJRSBcIiArIGUgKyBcIl0+PHNwYW4+PC9zcGFuPjwhW2VuZGlmXS0tPlwiLCB0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3BhblwiKS5sZW5ndGgpIHJldHVybiB0ID0gbnVsbCwgZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYVxuICAgICAgICAgICAgfSgpLFxuICAgICAgICAgICAgZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgdC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciwgYSA9IChuZXcgRGF0ZSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gciA9IE1hdGgubWF4KDAsIDE2IC0gKGEgLSBlKSksIGUgPSBhICsgciwgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQoYSArIHIpXG4gICAgICAgICAgICAgICAgICAgIH0sIHIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSgpLFxuICAgICAgICAgICAgbSA9IHtcbiAgICAgICAgICAgICAgICBpc1N0cmluZzogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgQXJyYXldXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNGdW5jdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzTm9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBlLm5vZGVUeXBlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc05vZGVMaXN0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIC9eXFxbb2JqZWN0IChIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdHxPYmplY3QpXFxdJC8udGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkpICYmIGUubGVuZ3RoICE9PSBhICYmICgwID09PSBlLmxlbmd0aCB8fCBcIm9iamVjdFwiID09IHR5cGVvZiBlWzBdICYmIGVbMF0ubm9kZVR5cGUgPiAwKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNXcmFwcGVkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIChlLmpxdWVyeSB8fCB0LlplcHRvICYmIHQuWmVwdG8uemVwdG8uaXNaKGUpKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNTVkc6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuU1ZHRWxlbWVudCAmJiBlIGluc3RhbmNlb2YgdC5TVkdFbGVtZW50XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgaW4gZSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeSA9ICExO1xuICAgICAgICBpZiAoZS5mbiAmJiBlLmZuLmpxdWVyeSA/IChmID0gZSwgeSA9ICEwKSA6IGYgPSB0LlZlbG9jaXR5LlV0aWxpdGllcywgOCA+PSBkICYmICF5KSB0aHJvdyBuZXcgRXJyb3IoXCJWZWxvY2l0eTogSUU4IGFuZCBiZWxvdyByZXF1aXJlIGpRdWVyeSB0byBiZSBsb2FkZWQgYmVmb3JlIFZlbG9jaXR5LlwiKTtcbiAgICAgICAgaWYgKDcgPj0gZCkgcmV0dXJuIHZvaWQoalF1ZXJ5LmZuLnZlbG9jaXR5ID0galF1ZXJ5LmZuLmFuaW1hdGUpO1xuICAgICAgICB2YXIgaCA9IDQwMCxcbiAgICAgICAgICAgIHYgPSBcInN3aW5nXCIsXG4gICAgICAgICAgICBiID0ge1xuICAgICAgICAgICAgICAgIFN0YXRlOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzTW9iaWxlOiAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksXG4gICAgICAgICAgICAgICAgICAgIGlzQW5kcm9pZDogL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLFxuICAgICAgICAgICAgICAgICAgICBpc0dpbmdlcmJyZWFkOiAvQW5kcm9pZCAyXFwuM1xcLlszLTddL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgICAgICAgICAgICAgICAgaXNDaHJvbWU6IHQuY2hyb21lLFxuICAgICAgICAgICAgICAgICAgICBpc0ZpcmVmb3g6IC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4RWxlbWVudDogci5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXhNYXRjaGVzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxQcm9wZXJ0eUxlZnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFByb3BlcnR5VG9wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBpc1RpY2tpbmc6ICExLFxuICAgICAgICAgICAgICAgICAgICBjYWxsczogW11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIENTUzoge30sXG4gICAgICAgICAgICAgICAgVXRpbGl0aWVzOiBmLFxuICAgICAgICAgICAgICAgIFJlZGlyZWN0czoge30sXG4gICAgICAgICAgICAgICAgRWFzaW5nczoge30sXG4gICAgICAgICAgICAgICAgUHJvbWlzZTogdC5Qcm9taXNlLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogaCxcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiB2LFxuICAgICAgICAgICAgICAgICAgICBiZWdpbjogYSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGEsXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiBhLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBhLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBhLFxuICAgICAgICAgICAgICAgICAgICBsb29wOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgZGVsYXk6ICExLFxuICAgICAgICAgICAgICAgICAgICBtb2JpbGVIQTogITAsXG4gICAgICAgICAgICAgICAgICAgIF9jYWNoZVZhbHVlczogITBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZi5kYXRhKGUsIFwidmVsb2NpdHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTVkc6IG0uaXNTVkcoZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FuaW1hdGluZzogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZFN0eWxlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW5zQ29udGFpbmVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFByb3BlcnR5VmFsdWVDYWNoZToge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1DYWNoZToge31cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhvb2s6IG51bGwsXG4gICAgICAgICAgICAgICAgbW9jazogITEsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICBtYWpvcjogMSxcbiAgICAgICAgICAgICAgICAgICAgbWlub3I6IDIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoOiAyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWJ1ZzogITFcbiAgICAgICAgICAgIH07XG4gICAgICAgIHQucGFnZVlPZmZzZXQgIT09IGEgPyAoYi5TdGF0ZS5zY3JvbGxBbmNob3IgPSB0LCBiLlN0YXRlLnNjcm9sbFByb3BlcnR5TGVmdCA9IFwicGFnZVhPZmZzZXRcIiwgYi5TdGF0ZS5zY3JvbGxQcm9wZXJ0eVRvcCA9IFwicGFnZVlPZmZzZXRcIikgOiAoYi5TdGF0ZS5zY3JvbGxBbmNob3IgPSByLmRvY3VtZW50RWxlbWVudCB8fCByLmJvZHkucGFyZW50Tm9kZSB8fCByLmJvZHksIGIuU3RhdGUuc2Nyb2xsUHJvcGVydHlMZWZ0ID0gXCJzY3JvbGxMZWZ0XCIsIGIuU3RhdGUuc2Nyb2xsUHJvcGVydHlUb3AgPSBcInNjcm9sbFRvcFwiKTtcbiAgICAgICAgdmFyIHggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtZS50ZW5zaW9uICogZS54IC0gZS5mcmljdGlvbiAqIGUudlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB0KHQsIHIsIGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogdC54ICsgYS5keCAqIHIsXG4gICAgICAgICAgICAgICAgICAgIHY6IHQudiArIGEuZHYgKiByLFxuICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uOiB0LnRlbnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGZyaWN0aW9uOiB0LmZyaWN0aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkeDogbi52LFxuICAgICAgICAgICAgICAgICAgICBkdjogZShuKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcihyLCBhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkeDogci52LFxuICAgICAgICAgICAgICAgICAgICAgICAgZHY6IGUocilcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbyA9IHQociwgLjUgKiBhLCBuKSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IHQociwgLjUgKiBhLCBvKSxcbiAgICAgICAgICAgICAgICAgICAgcyA9IHQociwgYSwgaSksXG4gICAgICAgICAgICAgICAgICAgIGwgPSAxIC8gNiAqIChuLmR4ICsgMiAqIChvLmR4ICsgaS5keCkgKyBzLmR4KSxcbiAgICAgICAgICAgICAgICAgICAgdSA9IDEgLyA2ICogKG4uZHYgKyAyICogKG8uZHYgKyBpLmR2KSArIHMuZHYpO1xuICAgICAgICAgICAgICAgIHJldHVybiByLnggPSByLnggKyBsICogYSwgci52ID0gci52ICsgdSAqIGEsIHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBhKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgbywgaSwgcywgbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgdjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmljdGlvbjogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1ID0gWzBdLFxuICAgICAgICAgICAgICAgICAgICBjID0gMCxcbiAgICAgICAgICAgICAgICAgICAgcCA9IDFlLTQsXG4gICAgICAgICAgICAgICAgICAgIGYgPSAuMDE2O1xuICAgICAgICAgICAgICAgIGZvciAoZSA9IHBhcnNlRmxvYXQoZSkgfHwgNTAwLCB0ID0gcGFyc2VGbG9hdCh0KSB8fCAyMCwgbiA9IG4gfHwgbnVsbCwgbC50ZW5zaW9uID0gZSwgbC5mcmljdGlvbiA9IHQsIG8gPSBudWxsICE9PSBuLCBvID8gKGMgPSBhKGUsIHQpLCBpID0gYyAvIG4gKiBmKSA6IGkgPSBmOyBzID0gcihzIHx8IGwsIGkpLCB1LnB1c2goMSArIHMueCksIGMgKz0gMTYsIE1hdGguYWJzKHMueCkgPiBwICYmIE1hdGguYWJzKHMudikgPiBwOyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG8gPyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1W2UgKiAodS5sZW5ndGggLSAxKSB8IDBdXG4gICAgICAgICAgICAgICAgfSA6IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSgpO1xuICAgICAgICBiLkVhc2luZ3MgPSB7XG4gICAgICAgICAgICBsaW5lYXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN3aW5nOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC41IC0gTWF0aC5jb3MoZSAqIE1hdGguUEkpIC8gMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNwcmluZzogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5jb3MoNC41ICogZSAqIE1hdGguUEkpICogTWF0aC5leHAoNiAqIC1lKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmLmVhY2goW1xuICAgICAgICAgICAgW1wiZWFzZVwiLCBbLjI1LCAuMSwgLjI1LCAxXV0sXG4gICAgICAgICAgICBbXCJlYXNlLWluXCIsIFsuNDIsIDAsIDEsIDFdXSxcbiAgICAgICAgICAgIFtcImVhc2Utb3V0XCIsIFswLCAwLCAuNTgsIDFdXSxcbiAgICAgICAgICAgIFtcImVhc2UtaW4tb3V0XCIsIFsuNDIsIDAsIC41OCwgMV1dLFxuICAgICAgICAgICAgW1wiZWFzZUluU2luZVwiLCBbLjQ3LCAwLCAuNzQ1LCAuNzE1XV0sXG4gICAgICAgICAgICBbXCJlYXNlT3V0U2luZVwiLCBbLjM5LCAuNTc1LCAuNTY1LCAxXV0sXG4gICAgICAgICAgICBbXCJlYXNlSW5PdXRTaW5lXCIsIFsuNDQ1LCAuMDUsIC41NSwgLjk1XV0sXG4gICAgICAgICAgICBbXCJlYXNlSW5RdWFkXCIsIFsuNTUsIC4wODUsIC42OCwgLjUzXV0sXG4gICAgICAgICAgICBbXCJlYXNlT3V0UXVhZFwiLCBbLjI1LCAuNDYsIC40NSwgLjk0XV0sXG4gICAgICAgICAgICBbXCJlYXNlSW5PdXRRdWFkXCIsIFsuNDU1LCAuMDMsIC41MTUsIC45NTVdXSxcbiAgICAgICAgICAgIFtcImVhc2VJbkN1YmljXCIsIFsuNTUsIC4wNTUsIC42NzUsIC4xOV1dLFxuICAgICAgICAgICAgW1wiZWFzZU91dEN1YmljXCIsIFsuMjE1LCAuNjEsIC4zNTUsIDFdXSxcbiAgICAgICAgICAgIFtcImVhc2VJbk91dEN1YmljXCIsIFsuNjQ1LCAuMDQ1LCAuMzU1LCAxXV0sXG4gICAgICAgICAgICBbXCJlYXNlSW5RdWFydFwiLCBbLjg5NSwgLjAzLCAuNjg1LCAuMjJdXSxcbiAgICAgICAgICAgIFtcImVhc2VPdXRRdWFydFwiLCBbLjE2NSwgLjg0LCAuNDQsIDFdXSxcbiAgICAgICAgICAgIFtcImVhc2VJbk91dFF1YXJ0XCIsIFsuNzcsIDAsIC4xNzUsIDFdXSxcbiAgICAgICAgICAgIFtcImVhc2VJblF1aW50XCIsIFsuNzU1LCAuMDUsIC44NTUsIC4wNl1dLFxuICAgICAgICAgICAgW1wiZWFzZU91dFF1aW50XCIsIFsuMjMsIDEsIC4zMiwgMV1dLFxuICAgICAgICAgICAgW1wiZWFzZUluT3V0UXVpbnRcIiwgWy44NiwgMCwgLjA3LCAxXV0sXG4gICAgICAgICAgICBbXCJlYXNlSW5FeHBvXCIsIFsuOTUsIC4wNSwgLjc5NSwgLjAzNV1dLFxuICAgICAgICAgICAgW1wiZWFzZU91dEV4cG9cIiwgWy4xOSwgMSwgLjIyLCAxXV0sXG4gICAgICAgICAgICBbXCJlYXNlSW5PdXRFeHBvXCIsIFsxLCAwLCAwLCAxXV0sXG4gICAgICAgICAgICBbXCJlYXNlSW5DaXJjXCIsIFsuNiwgLjA0LCAuOTgsIC4zMzVdXSxcbiAgICAgICAgICAgIFtcImVhc2VPdXRDaXJjXCIsIFsuMDc1LCAuODIsIC4xNjUsIDFdXSxcbiAgICAgICAgICAgIFtcImVhc2VJbk91dENpcmNcIiwgWy43ODUsIC4xMzUsIC4xNSwgLjg2XV1cbiAgICAgICAgXSwgZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgYi5FYXNpbmdzW3RbMF1dID0gbC5hcHBseShudWxsLCB0WzFdKVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIFMgPSBiLkNTUyA9IHtcbiAgICAgICAgICAgIFJlZ0V4OiB7XG4gICAgICAgICAgICAgICAgaXNIZXg6IC9eIyhbQS1mXFxkXXszfSl7MSwyfSQvaSxcbiAgICAgICAgICAgICAgICB2YWx1ZVVud3JhcDogL15bQS16XStcXCgoLiopXFwpJC9pLFxuICAgICAgICAgICAgICAgIHdyYXBwZWRWYWx1ZUFscmVhZHlFeHRyYWN0ZWQ6IC9bMC05Ll0rIFswLTkuXSsgWzAtOS5dKyggWzAtOS5dKyk/LyxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwbGl0OiAvKFtBLXpdK1xcKC4rXFwpKXwoKFtBLXowLTkjLS5dKz8pKD89XFxzfCQpKS9naVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIExpc3RzOiB7XG4gICAgICAgICAgICAgICAgY29sb3JzOiBbXCJmaWxsXCIsIFwic3Ryb2tlXCIsIFwic3RvcENvbG9yXCIsIFwiY29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBcImJvcmRlclRvcENvbG9yXCIsIFwiYm9yZGVyUmlnaHRDb2xvclwiLCBcImJvcmRlckJvdHRvbUNvbG9yXCIsIFwiYm9yZGVyTGVmdENvbG9yXCIsIFwib3V0bGluZUNvbG9yXCJdLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybXNCYXNlOiBbXCJ0cmFuc2xhdGVYXCIsIFwidHJhbnNsYXRlWVwiLCBcInNjYWxlXCIsIFwic2NhbGVYXCIsIFwic2NhbGVZXCIsIFwic2tld1hcIiwgXCJza2V3WVwiLCBcInJvdGF0ZVpcIl0sXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtczNEOiBbXCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLCBcInRyYW5zbGF0ZVpcIiwgXCJzY2FsZVpcIiwgXCJyb3RhdGVYXCIsIFwicm90YXRlWVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEhvb2tzOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRTaGFkb3c6IFtcIkNvbG9yIFggWSBCbHVyXCIsIFwiYmxhY2sgMHB4IDBweCAwcHhcIl0sXG4gICAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogW1wiQ29sb3IgWCBZIEJsdXIgU3ByZWFkXCIsIFwiYmxhY2sgMHB4IDBweCAwcHggMHB4XCJdLFxuICAgICAgICAgICAgICAgICAgICBjbGlwOiBbXCJUb3AgUmlnaHQgQm90dG9tIExlZnRcIiwgXCIwcHggMHB4IDBweCAwcHhcIl0sXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogW1wiWCBZXCIsIFwiMCUgMCVcIl0sXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogW1wiWCBZIFpcIiwgXCI1MCUgNTAlIDBweFwiXSxcbiAgICAgICAgICAgICAgICAgICAgcGVyc3BlY3RpdmVPcmlnaW46IFtcIlggWVwiLCBcIjUwJSA1MCVcIl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWQ6IHt9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBTLkxpc3RzLmNvbG9ycy5sZW5ndGg7IGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBcImNvbG9yXCIgPT09IFMuTGlzdHMuY29sb3JzW2VdID8gXCIwIDAgMCAxXCIgOiBcIjI1NSAyNTUgMjU1IDFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMuSG9va3MudGVtcGxhdGVzW1MuTGlzdHMuY29sb3JzW2VdXSA9IFtcIlJlZCBHcmVlbiBCbHVlIEFscGhhXCIsIHRdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHIsIGEsIG47XG4gICAgICAgICAgICAgICAgICAgIGlmIChkKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChyIGluIFMuSG9va3MudGVtcGxhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IFMuSG9va3MudGVtcGxhdGVzW3JdLCBuID0gYVswXS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBhWzFdLm1hdGNoKFMuUmVnRXgudmFsdWVTcGxpdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb2xvclwiID09PSBuWzBdICYmIChuLnB1c2gobi5zaGlmdCgpKSwgby5wdXNoKG8uc2hpZnQoKSksIFMuSG9va3MudGVtcGxhdGVzW3JdID0gW24uam9pbihcIiBcIiksIG8uam9pbihcIiBcIildKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHIgaW4gUy5Ib29rcy50ZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBTLkhvb2tzLnRlbXBsYXRlc1tyXSwgbiA9IGFbMF0uc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSBpbiBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSByICsgbltlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUy5Ib29rcy5yZWdpc3RlcmVkW2ldID0gW3IsIHNdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFJvb3Q6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBTLkhvb2tzLnJlZ2lzdGVyZWRbZV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ID8gdFswXSA6IGVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsZWFuUm9vdFByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFMuUmVnRXgudmFsdWVVbndyYXAudGVzdCh0KSAmJiAodCA9IHQubWF0Y2goUy5SZWdFeC52YWx1ZVVud3JhcClbMV0pLCBTLlZhbHVlcy5pc0NTU051bGxWYWx1ZSh0KSAmJiAodCA9IFMuSG9va3MudGVtcGxhdGVzW2VdWzFdKSwgdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXh0cmFjdFZhbHVlOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gUy5Ib29rcy5yZWdpc3RlcmVkW2VdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSByWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPSBTLkhvb2tzLmNsZWFuUm9vdFByb3BlcnR5VmFsdWUoYSwgdCksIHQudG9TdHJpbmcoKS5tYXRjaChTLlJlZ0V4LnZhbHVlU3BsaXQpW25dXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluamVjdFZhbHVlOiBmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gUy5Ib29rcy5yZWdpc3RlcmVkW2VdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4sIG8sIGkgPSBhWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgPSBTLkhvb2tzLmNsZWFuUm9vdFByb3BlcnR5VmFsdWUoaSwgciksIG4gPSByLnRvU3RyaW5nKCkubWF0Y2goUy5SZWdFeC52YWx1ZVNwbGl0KSwgbltzXSA9IHQsIG8gPSBuLmpvaW4oXCIgXCIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTm9ybWFsaXphdGlvbnM6IHtcbiAgICAgICAgICAgICAgICByZWdpc3RlcmVkOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXA6IGZ1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNsaXBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXh0cmFjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFMuUmVnRXgud3JhcHBlZFZhbHVlQWxyZWFkeUV4dHJhY3RlZC50ZXN0KHIpID8gYSA9IHIgOiAoYSA9IHIudG9TdHJpbmcoKS5tYXRjaChTLlJlZ0V4LnZhbHVlVW53cmFwKSwgYSA9IGEgPyBhWzFdLnJlcGxhY2UoLywoXFxzKyk/L2csIFwiIFwiKSA6IHIpLCBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbmplY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicmVjdChcIiArIHIgKyBcIilcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBibHVyOiBmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5TdGF0ZS5pc0ZpcmVmb3ggPyBcImZpbHRlclwiIDogXCItd2Via2l0LWZpbHRlclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJleHRyYWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gcGFyc2VGbG9hdChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhICYmIDAgIT09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gci50b1N0cmluZygpLm1hdGNoKC9ibHVyXFwoKFswLTldK1tBLXpdKylcXCkvaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gbiA/IG5bMV0gOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluamVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChyKSA/IFwiYmx1cihcIiArIHIgKyBcIilcIiA6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGZ1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICg4ID49IGQpIHN3aXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZpbHRlclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJleHRyYWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gci50b1N0cmluZygpLm1hdGNoKC9hbHBoYVxcKG9wYWNpdHk9KC4qKVxcKS9pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgPSBhID8gYVsxXSAvIDEwMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluamVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5zdHlsZS56b29tID0gMSwgcGFyc2VGbG9hdChyKSA+PSAxID8gXCJcIiA6IFwiYWxwaGEob3BhY2l0eT1cIiArIHBhcnNlSW50KDEwMCAqIHBhcnNlRmxvYXQociksIDEwKSArIFwiKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Ugc3dpdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib3BhY2l0eVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJleHRyYWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbmplY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICA5ID49IGQgfHwgYi5TdGF0ZS5pc0dpbmdlcmJyZWFkIHx8IChTLkxpc3RzLnRyYW5zZm9ybXNCYXNlID0gUy5MaXN0cy50cmFuc2Zvcm1zQmFzZS5jb25jYXQoUy5MaXN0cy50cmFuc2Zvcm1zM0QpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBTLkxpc3RzLnRyYW5zZm9ybXNCYXNlLmxlbmd0aDsgZSsrKSAhIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBTLkxpc3RzLnRyYW5zZm9ybXNCYXNlW2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3RdID0gZnVuY3Rpb24oZSwgciwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNmb3JtXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJleHRyYWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaShyKSA9PT0gYSB8fCBpKHIpLnRyYW5zZm9ybUNhY2hlW3RdID09PSBhID8gL15zY2FsZS9pLnRlc3QodCkgPyAxIDogMCA6IGkocikudHJhbnNmb3JtQ2FjaGVbdF0ucmVwbGFjZSgvWygpXS9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluamVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodC5zdWJzdHIoMCwgdC5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2xhdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9ICEvKCV8cHh8ZW18cmVtfHZ3fHZofFxcZCkkL2kudGVzdChuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5TdGF0ZS5pc0FuZHJvaWQgJiYgaShyKS50cmFuc2Zvcm1DYWNoZVt0XSA9PT0gYSAmJiAxID4gbiAmJiAobiA9IDEpLCBvID0gIS8oXFxkKSQvaS50ZXN0KG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2tld1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gIS8oZGVnfFxcZCkkL2kudGVzdChuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJvdGF0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gIS8oZGVnfFxcZCkkL2kudGVzdChuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8gfHwgKGkocikudHJhbnNmb3JtQ2FjaGVbdF0gPSBcIihcIiArIG4gKyBcIilcIiksIGkocikudHJhbnNmb3JtQ2FjaGVbdF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBTLkxpc3RzLmNvbG9ycy5sZW5ndGg7IGUrKykgISBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gUy5MaXN0cy5jb2xvcnNbZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbdF0gPSBmdW5jdGlvbihlLCByLCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImV4dHJhY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFMuUmVnRXgud3JhcHBlZFZhbHVlQWxyZWFkeUV4dHJhY3RlZC50ZXN0KG4pKSBvID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGFjazogXCJyZ2IoMCwgMCwgMClcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmx1ZTogXCJyZ2IoMCwgMCwgMjU1KVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmF5OiBcInJnYigxMjgsIDEyOCwgMTI4KVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmVlbjogXCJyZ2IoMCwgMTI4LCAwKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWQ6IFwicmdiKDI1NSwgMCwgMClcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGU6IFwicmdiKDI1NSwgMjU1LCAyNTUpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9eW0Etel0rJC9pLnRlc3QobikgPyBpID0gc1tuXSAhPT0gYSA/IHNbbl0gOiBzLmJsYWNrIDogUy5SZWdFeC5pc0hleC50ZXN0KG4pID8gaSA9IFwicmdiKFwiICsgUy5WYWx1ZXMuaGV4VG9SZ2Iobikuam9pbihcIiBcIikgKyBcIilcIiA6IC9ecmdiYT9cXCgvaS50ZXN0KG4pIHx8IChpID0gcy5ibGFjayksIG8gPSAoaSB8fCBuKS50b1N0cmluZygpLm1hdGNoKFMuUmVnRXgudmFsdWVVbndyYXApWzFdLnJlcGxhY2UoLywoXFxzKyk/L2csIFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDggPj0gZCB8fCAzICE9PSBvLnNwbGl0KFwiIFwiKS5sZW5ndGggfHwgKG8gKz0gXCIgMVwiKSwgbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluamVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDggPj0gZCA/IDQgPT09IG4uc3BsaXQoXCIgXCIpLmxlbmd0aCAmJiAobiA9IG4uc3BsaXQoL1xccysvKS5zbGljZSgwLCAzKS5qb2luKFwiIFwiKSkgOiAzID09PSBuLnNwbGl0KFwiIFwiKS5sZW5ndGggJiYgKG4gKz0gXCIgMVwiKSwgKDggPj0gZCA/IFwicmdiXCIgOiBcInJnYmFcIikgKyBcIihcIiArIG4ucmVwbGFjZSgvXFxzKy9nLCBcIixcIikucmVwbGFjZSgvXFwuKFxcZCkrKD89LCkvZywgXCJcIikgKyBcIilcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE5hbWVzOiB7XG4gICAgICAgICAgICAgICAgY2FtZWxDYXNlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnJlcGxhY2UoLy0oXFx3KS9nLCBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBTVkdBdHRyaWJ1dGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBcIndpZHRofGhlaWdodHx4fHl8Y3h8Y3l8cnxyeHxyeXx4MXx4Mnx5MXx5MlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGQgfHwgYi5TdGF0ZS5pc0FuZHJvaWQgJiYgIWIuU3RhdGUuaXNDaHJvbWUpICYmICh0ICs9IFwifHRyYW5zZm9ybVwiKSwgbmV3IFJlZ0V4cChcIl4oXCIgKyB0ICsgXCIpJFwiLCBcImlcIikudGVzdChlKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJlZml4Q2hlY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIuU3RhdGUucHJlZml4TWF0Y2hlc1tlXSkgcmV0dXJuIFtiLlN0YXRlLnByZWZpeE1hdGNoZXNbZV0sICEwXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IFtcIlwiLCBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIsIFwiT1wiXSwgciA9IDAsIGEgPSB0Lmxlbmd0aDsgYSA+IHI7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobiA9IDAgPT09IHIgPyBlIDogdFtyXSArIGUucmVwbGFjZSgvXlxcdy8sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBtLmlzU3RyaW5nKGIuU3RhdGUucHJlZml4RWxlbWVudC5zdHlsZVtuXSkpIHJldHVybiBiLlN0YXRlLnByZWZpeE1hdGNoZXNbZV0gPSBuLCBbbiwgITBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlLCAhMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgVmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgaGV4VG9SZ2I6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQsIHIgPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2k7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlID0gZS5yZXBsYWNlKHIsIGZ1bmN0aW9uKGUsIHQsIHIsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ICsgdCArIHIgKyByICsgYSArIGFcbiAgICAgICAgICAgICAgICAgICAgfSksIHQgPSBhLmV4ZWMoZSksIHQgPyBbcGFyc2VJbnQodFsxXSwgMTYpLCBwYXJzZUludCh0WzJdLCAxNiksIHBhcnNlSW50KHRbM10sIDE2KV0gOiBbMCwgMCwgMF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzQ1NTTnVsbFZhbHVlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwID09IGUgfHwgL14obm9uZXxhdXRvfHRyYW5zcGFyZW50fChyZ2JhXFwoMCwgPzAsID8wLCA/MFxcKSkpJC9pLnRlc3QoZSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFVuaXRUeXBlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvXihyb3RhdGV8c2tldykvaS50ZXN0KGUpID8gXCJkZWdcIiA6IC8oXihzY2FsZXxzY2FsZVh8c2NhbGVZfHNjYWxlWnxhbHBoYXxmbGV4R3Jvd3xmbGV4SGVpZ2h0fHpJbmRleHxmb250V2VpZ2h0KSQpfCgob3BhY2l0eXxyZWR8Z3JlZW58Ymx1ZXxhbHBoYSkkKS9pLnRlc3QoZSkgPyBcIlwiIDogXCJweFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXREaXNwbGF5VHlwZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUgJiYgZS50YWdOYW1lLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9eKGJ8YmlnfGl8c21hbGx8dHR8YWJicnxhY3JvbnltfGNpdGV8Y29kZXxkZm58ZW18a2JkfHN0cm9uZ3xzYW1wfHZhcnxhfGJkb3xicnxpbWd8bWFwfG9iamVjdHxxfHNjcmlwdHxzcGFufHN1YnxzdXB8YnV0dG9ufGlucHV0fGxhYmVsfHNlbGVjdHx0ZXh0YXJlYSkkL2kudGVzdCh0KSA/IFwiaW5saW5lXCIgOiAvXihsaSkkL2kudGVzdCh0KSA/IFwibGlzdC1pdGVtXCIgOiAvXih0cikkL2kudGVzdCh0KSA/IFwidGFibGUtcm93XCIgOiAvXih0YWJsZSkkL2kudGVzdCh0KSA/IFwidGFibGVcIiA6IC9eKHRib2R5KSQvaS50ZXN0KHQpID8gXCJ0YWJsZS1yb3ctZ3JvdXBcIiA6IFwiYmxvY2tcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5jbGFzc0xpc3QgPyBlLmNsYXNzTGlzdC5hZGQodCkgOiBlLmNsYXNzTmFtZSArPSAoZS5jbGFzc05hbWUubGVuZ3RoID8gXCIgXCIgOiBcIlwiKSArIHRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGUuY2xhc3NMaXN0ID8gZS5jbGFzc0xpc3QucmVtb3ZlKHQpIDogZS5jbGFzc05hbWUgPSBlLmNsYXNzTmFtZS50b1N0cmluZygpLnJlcGxhY2UobmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgdC5zcGxpdChcIiBcIikuam9pbihcInxcIikgKyBcIihcXFxcc3wkKVwiLCBcImdpXCIpLCBcIiBcIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UHJvcGVydHlWYWx1ZTogZnVuY3Rpb24oZSwgciwgbiwgbykge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHMoZSwgcikge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdSAmJiBTLnNldFByb3BlcnR5VmFsdWUoZSwgXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDggPj0gZCkgbCA9IGYuY3NzKGUsIHIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL14od2lkdGh8aGVpZ2h0KSQvLnRlc3QocikgJiYgMCA9PT0gUy5nZXRQcm9wZXJ0eVZhbHVlKGUsIFwiZGlzcGxheVwiKSAmJiAodSA9ICEwLCBTLnNldFByb3BlcnR5VmFsdWUoZSwgXCJkaXNwbGF5XCIsIFMuVmFsdWVzLmdldERpc3BsYXlUeXBlKGUpKSksICFvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiaGVpZ2h0XCIgPT09IHIgJiYgXCJib3JkZXItYm94XCIgIT09IFMuZ2V0UHJvcGVydHlWYWx1ZShlLCBcImJveFNpemluZ1wiKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBlLm9mZnNldEhlaWdodCAtIChwYXJzZUZsb2F0KFMuZ2V0UHJvcGVydHlWYWx1ZShlLCBcImJvcmRlclRvcFdpZHRoXCIpKSB8fCAwKSAtIChwYXJzZUZsb2F0KFMuZ2V0UHJvcGVydHlWYWx1ZShlLCBcImJvcmRlckJvdHRvbVdpZHRoXCIpKSB8fCAwKSAtIChwYXJzZUZsb2F0KFMuZ2V0UHJvcGVydHlWYWx1ZShlLCBcInBhZGRpbmdUb3BcIikpIHx8IDApIC0gKHBhcnNlRmxvYXQoUy5nZXRQcm9wZXJ0eVZhbHVlKGUsIFwicGFkZGluZ0JvdHRvbVwiKSkgfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuKCksIGNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwid2lkdGhcIiA9PT0gciAmJiBcImJvcmRlci1ib3hcIiAhPT0gUy5nZXRQcm9wZXJ0eVZhbHVlKGUsIFwiYm94U2l6aW5nXCIpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGUub2Zmc2V0V2lkdGggLSAocGFyc2VGbG9hdChTLmdldFByb3BlcnR5VmFsdWUoZSwgXCJib3JkZXJMZWZ0V2lkdGhcIikpIHx8IDApIC0gKHBhcnNlRmxvYXQoUy5nZXRQcm9wZXJ0eVZhbHVlKGUsIFwiYm9yZGVyUmlnaHRXaWR0aFwiKSkgfHwgMCkgLSAocGFyc2VGbG9hdChTLmdldFByb3BlcnR5VmFsdWUoZSwgXCJwYWRkaW5nTGVmdFwiKSkgfHwgMCkgLSAocGFyc2VGbG9hdChTLmdldFByb3BlcnR5VmFsdWUoZSwgXCJwYWRkaW5nUmlnaHRcIikpIHx8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbigpLCBwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGc7XG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gaShlKSA9PT0gYSA/IHQuZ2V0Q29tcHV0ZWRTdHlsZShlLCBudWxsKSA6IGkoZSkuY29tcHV0ZWRTdHlsZSA/IGkoZSkuY29tcHV0ZWRTdHlsZSA6IGkoZSkuY29tcHV0ZWRTdHlsZSA9IHQuZ2V0Q29tcHV0ZWRTdHlsZShlLCBudWxsKSwgXCJib3JkZXJDb2xvclwiID09PSByICYmIChyID0gXCJib3JkZXJUb3BDb2xvclwiKSwgbCA9IDkgPT09IGQgJiYgXCJmaWx0ZXJcIiA9PT0gciA/IGcuZ2V0UHJvcGVydHlWYWx1ZShyKSA6IGdbcl0sIChcIlwiID09PSBsIHx8IG51bGwgPT09IGwpICYmIChsID0gZS5zdHlsZVtyXSksIG4oKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImF1dG9cIiA9PT0gbCAmJiAvXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC9pLnRlc3QocikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gcyhlLCBcInBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiZml4ZWRcIiA9PT0gbSB8fCBcImFic29sdXRlXCIgPT09IG0gJiYgL3RvcHxsZWZ0L2kudGVzdChyKSkgJiYgKGwgPSBmKGUpLnBvc2l0aW9uKClbcl0gKyBcInB4XCIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGw7XG4gICAgICAgICAgICAgICAgaWYgKFMuSG9va3MucmVnaXN0ZXJlZFtyXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gUy5Ib29rcy5nZXRSb290KHUpO1xuICAgICAgICAgICAgICAgICAgICBuID09PSBhICYmIChuID0gUy5nZXRQcm9wZXJ0eVZhbHVlKGUsIFMuTmFtZXMucHJlZml4Q2hlY2soYylbMF0pKSwgUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW2NdICYmIChuID0gUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW2NdKFwiZXh0cmFjdFwiLCBlLCBuKSksIGwgPSBTLkhvb2tzLmV4dHJhY3RWYWx1ZSh1LCBuKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3JdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwLCBnO1xuICAgICAgICAgICAgICAgICAgICBwID0gUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3JdKFwibmFtZVwiLCBlKSwgXCJ0cmFuc2Zvcm1cIiAhPT0gcCAmJiAoZyA9IHMoZSwgUy5OYW1lcy5wcmVmaXhDaGVjayhwKVswXSksIFMuVmFsdWVzLmlzQ1NTTnVsbFZhbHVlKGcpICYmIFMuSG9va3MudGVtcGxhdGVzW3JdICYmIChnID0gUy5Ib29rcy50ZW1wbGF0ZXNbcl1bMV0pKSwgbCA9IFMuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtyXShcImV4dHJhY3RcIiwgZSwgZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEvXltcXGQtXS8udGVzdChsKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkoZSkgJiYgaShlKS5pc1NWRyAmJiBTLk5hbWVzLlNWR0F0dHJpYnV0ZShyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXihoZWlnaHR8d2lkdGgpJC9pLnRlc3QocikpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IGUuZ2V0QkJveCgpW3JdXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBsID0gZS5nZXRBdHRyaWJ1dGUocik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGwgPSBzKGUsIFMuTmFtZXMucHJlZml4Q2hlY2socilbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBTLlZhbHVlcy5pc0NTU051bGxWYWx1ZShsKSAmJiAobCA9IDApLCBiLmRlYnVnID49IDIgJiYgY29uc29sZS5sb2coXCJHZXQgXCIgKyByICsgXCI6IFwiICsgbCksIGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbihlLCByLCBhLCBuLCBvKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSByO1xuICAgICAgICAgICAgICAgIGlmIChcInNjcm9sbFwiID09PSByKSBvLmNvbnRhaW5lciA/IG8uY29udGFpbmVyW1wic2Nyb2xsXCIgKyBvLmRpcmVjdGlvbl0gPSBhIDogXCJMZWZ0XCIgPT09IG8uZGlyZWN0aW9uID8gdC5zY3JvbGxUbyhhLCBvLmFsdGVybmF0ZVZhbHVlKSA6IHQuc2Nyb2xsVG8oby5hbHRlcm5hdGVWYWx1ZSwgYSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3JdICYmIFwidHJhbnNmb3JtXCIgPT09IFMuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtyXShcIm5hbWVcIiwgZSkpIFMuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtyXShcImluamVjdFwiLCBlLCBhKSwgcyA9IFwidHJhbnNmb3JtXCIsIGEgPSBpKGUpLnRyYW5zZm9ybUNhY2hlW3JdO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUy5Ib29rcy5yZWdpc3RlcmVkW3JdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IFMuSG9va3MuZ2V0Um9vdChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBuIHx8IFMuZ2V0UHJvcGVydHlWYWx1ZShlLCB1KSwgYSA9IFMuSG9va3MuaW5qZWN0VmFsdWUobCwgYSwgbiksIHIgPSB1XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFMuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtyXSAmJiAoYSA9IFMuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtyXShcImluamVjdFwiLCBlLCBhKSwgciA9IFMuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtyXShcIm5hbWVcIiwgZSkpLCBzID0gUy5OYW1lcy5wcmVmaXhDaGVjayhyKVswXSwgOCA+PSBkKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdHlsZVtzXSA9IGFcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5kZWJ1ZyAmJiBjb25zb2xlLmxvZyhcIkJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBbXCIgKyBhICsgXCJdIGZvciBbXCIgKyBzICsgXCJdXCIpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpKGUpICYmIGkoZSkuaXNTVkcgJiYgUy5OYW1lcy5TVkdBdHRyaWJ1dGUocikgPyBlLnNldEF0dHJpYnV0ZShyLCBhKSA6IGUuc3R5bGVbc10gPSBhO1xuICAgICAgICAgICAgICAgICAgICBiLmRlYnVnID49IDIgJiYgY29uc29sZS5sb2coXCJTZXQgXCIgKyByICsgXCIgKFwiICsgcyArIFwiKTogXCIgKyBhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3MsIGFdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmx1c2hUcmFuc2Zvcm1DYWNoZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHQodCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChTLmdldFByb3BlcnR5VmFsdWUoZSwgdCkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoKGQgfHwgYi5TdGF0ZS5pc0FuZHJvaWQgJiYgIWIuU3RhdGUuaXNDaHJvbWUpICYmIGkoZSkuaXNTVkcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGU6IFt0KFwidHJhbnNsYXRlWFwiKSwgdChcInRyYW5zbGF0ZVlcIildLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tld1g6IFt0KFwic2tld1hcIildLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tld1k6IFt0KFwic2tld1lcIildLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IDEgIT09IHQoXCJzY2FsZVwiKSA/IFt0KFwic2NhbGVcIiksIHQoXCJzY2FsZVwiKV0gOiBbdChcInNjYWxlWFwiKSwgdChcInNjYWxlWVwiKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGU6IFt0KFwicm90YXRlWlwiKSwgMCwgMF1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZi5lYWNoKGkoZSkudHJhbnNmb3JtQ2FjaGUsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC9edHJhbnNsYXRlL2kudGVzdChlKSA/IGUgPSBcInRyYW5zbGF0ZVwiIDogL15zY2FsZS9pLnRlc3QoZSkgPyBlID0gXCJzY2FsZVwiIDogL15yb3RhdGUvaS50ZXN0KGUpICYmIChlID0gXCJyb3RhdGVcIiksIGFbZV0gJiYgKHIgKz0gZSArIFwiKFwiICsgYVtlXS5qb2luKFwiIFwiKSArIFwiKSBcIiwgZGVsZXRlIGFbZV0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4sIG87XG4gICAgICAgICAgICAgICAgICAgIGYuZWFjaChpKGUpLnRyYW5zZm9ybUNhY2hlLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiA9IGkoZSkudHJhbnNmb3JtQ2FjaGVbdF0sIFwidHJhbnNmb3JtUGVyc3BlY3RpdmVcIiA9PT0gdCA/IChvID0gbiwgITApIDogKDkgPT09IGQgJiYgXCJyb3RhdGVaXCIgPT09IHQgJiYgKHQgPSBcInJvdGF0ZVwiKSwgdm9pZChyICs9IHQgKyBuICsgXCIgXCIpKVxuICAgICAgICAgICAgICAgICAgICB9KSwgbyAmJiAociA9IFwicGVyc3BlY3RpdmVcIiArIG8gKyBcIiBcIiArIHIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFMuc2V0UHJvcGVydHlWYWx1ZShlLCBcInRyYW5zZm9ybVwiLCByKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTLkhvb2tzLnJlZ2lzdGVyKCksIFMuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXIoKSwgYi5ob29rID0gZnVuY3Rpb24oZSwgdCwgcikge1xuICAgICAgICAgICAgdmFyIG4gPSBhO1xuICAgICAgICAgICAgcmV0dXJuIGUgPSBvKGUpLCBmLmVhY2goZSwgZnVuY3Rpb24oZSwgbykge1xuICAgICAgICAgICAgICAgIGlmIChpKG8pID09PSBhICYmIGIuaW5pdChvKSwgciA9PT0gYSkgbiA9PT0gYSAmJiAobiA9IGIuQ1NTLmdldFByb3BlcnR5VmFsdWUobywgdCkpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGIuQ1NTLnNldFByb3BlcnR5VmFsdWUobywgdCwgcik7XG4gICAgICAgICAgICAgICAgICAgIFwidHJhbnNmb3JtXCIgPT09IHNbMF0gJiYgYi5DU1MuZmx1c2hUcmFuc2Zvcm1DYWNoZShvKSwgbiA9IHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgblxuICAgICAgICB9O1xuICAgICAgICB2YXIgUCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcyA/IGsucHJvbWlzZSB8fCBudWxsIDogbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBuKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGUoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0uaXNBcnJheShlKSA/IChyID0gZVswXSwgIW0uaXNBcnJheShlWzFdKSAmJiAvXltcXGQtXS8udGVzdChlWzFdKSB8fCBtLmlzRnVuY3Rpb24oZVsxXSkgfHwgUy5SZWdFeC5pc0hleC50ZXN0KGVbMV0pID8gaSA9IGVbMV0gOiAobS5pc1N0cmluZyhlWzFdKSAmJiAhUy5SZWdFeC5pc0hleC50ZXN0KGVbMV0pIHx8IG0uaXNBcnJheShlWzFdKSkgJiYgKG4gPSB0ID8gZVsxXSA6IHUoZVsxXSwgcy5kdXJhdGlvbiksIGVbMl0gIT09IGEgJiYgKGkgPSBlWzJdKSkpIDogciA9IGUsIHQgfHwgKG4gPSBuIHx8IHMuZWFzaW5nKSwgbS5pc0Z1bmN0aW9uKHIpICYmIChyID0gci5jYWxsKG8sIFYsIHcpKSwgbS5pc0Z1bmN0aW9uKGkpICYmIChpID0gaS5jYWxsKG8sIFYsIHcpKSwgW3IgfHwgMCwgbiwgaV1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIsIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9ICh0IHx8IFwiMFwiKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWyVBLXpdKyQvLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgPSBlLCBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgciB8fCAociA9IFMuVmFsdWVzLmdldFVuaXRUeXBlKGUpKSwgW2EsIHJdXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG15UGFyZW50OiBvLnBhcmVudE5vZGUgfHwgci5ib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogUy5nZXRQcm9wZXJ0eVZhbHVlKG8sIFwicG9zaXRpb25cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBTLmdldFByb3BlcnR5VmFsdWUobywgXCJmb250U2l6ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGUucG9zaXRpb24gPT09IEwubGFzdFBvc2l0aW9uICYmIGUubXlQYXJlbnQgPT09IEwubGFzdFBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gZS5mb250U2l6ZSA9PT0gTC5sYXN0Rm9udFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBMLmxhc3RQYXJlbnQgPSBlLm15UGFyZW50LCBMLmxhc3RQb3NpdGlvbiA9IGUucG9zaXRpb24sIEwubGFzdEZvbnRTaXplID0gZS5mb250U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICYmIGEpIGwuZW1Ub1B4ID0gTC5sYXN0RW1Ub1B4LCBsLnBlcmNlbnRUb1B4V2lkdGggPSBMLmxhc3RQZXJjZW50VG9QeFdpZHRoLCBsLnBlcmNlbnRUb1B4SGVpZ2h0ID0gTC5sYXN0UGVyY2VudFRvUHhIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGkobykuaXNTVkcgPyByLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicmVjdFwiKSA6IHIuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmluaXQodSksIGUubXlQYXJlbnQuYXBwZW5kQ2hpbGQodSksIGYuZWFjaChbXCJvdmVyZmxvd1wiLCBcIm92ZXJmbG93WFwiLCBcIm92ZXJmbG93WVwiXSwgZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLkNTUy5zZXRQcm9wZXJ0eVZhbHVlKHUsIHQsIFwiaGlkZGVuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGIuQ1NTLnNldFByb3BlcnR5VmFsdWUodSwgXCJwb3NpdGlvblwiLCBlLnBvc2l0aW9uKSwgYi5DU1Muc2V0UHJvcGVydHlWYWx1ZSh1LCBcImZvbnRTaXplXCIsIGUuZm9udFNpemUpLCBiLkNTUy5zZXRQcm9wZXJ0eVZhbHVlKHUsIFwiYm94U2l6aW5nXCIsIFwiY29udGVudC1ib3hcIiksIGYuZWFjaChbXCJtaW5XaWR0aFwiLCBcIm1heFdpZHRoXCIsIFwid2lkdGhcIiwgXCJtaW5IZWlnaHRcIiwgXCJtYXhIZWlnaHRcIiwgXCJoZWlnaHRcIl0sIGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5DU1Muc2V0UHJvcGVydHlWYWx1ZSh1LCB0LCBzICsgXCIlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGIuQ1NTLnNldFByb3BlcnR5VmFsdWUodSwgXCJwYWRkaW5nTGVmdFwiLCBzICsgXCJlbVwiKSwgbC5wZXJjZW50VG9QeFdpZHRoID0gTC5sYXN0UGVyY2VudFRvUHhXaWR0aCA9IChwYXJzZUZsb2F0KFMuZ2V0UHJvcGVydHlWYWx1ZSh1LCBcIndpZHRoXCIsIG51bGwsICEwKSkgfHwgMSkgLyBzLCBsLnBlcmNlbnRUb1B4SGVpZ2h0ID0gTC5sYXN0UGVyY2VudFRvUHhIZWlnaHQgPSAocGFyc2VGbG9hdChTLmdldFByb3BlcnR5VmFsdWUodSwgXCJoZWlnaHRcIiwgbnVsbCwgITApKSB8fCAxKSAvIHMsIGwuZW1Ub1B4ID0gTC5sYXN0RW1Ub1B4ID0gKHBhcnNlRmxvYXQoUy5nZXRQcm9wZXJ0eVZhbHVlKHUsIFwicGFkZGluZ0xlZnRcIikpIHx8IDEpIC8gcywgZS5teVBhcmVudC5yZW1vdmVDaGlsZCh1KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgPT09IEwucmVtVG9QeCAmJiAoTC5yZW1Ub1B4ID0gcGFyc2VGbG9hdChTLmdldFByb3BlcnR5VmFsdWUoci5ib2R5LCBcImZvbnRTaXplXCIpKSB8fCAxNiksIG51bGwgPT09IEwudndUb1B4ICYmIChMLnZ3VG9QeCA9IHBhcnNlRmxvYXQodC5pbm5lcldpZHRoKSAvIDEwMCwgTC52aFRvUHggPSBwYXJzZUZsb2F0KHQuaW5uZXJIZWlnaHQpIC8gMTAwKSwgbC5yZW1Ub1B4ID0gTC5yZW1Ub1B4LCBsLnZ3VG9QeCA9IEwudndUb1B4LCBsLnZoVG9QeCA9IEwudmhUb1B4LCBiLmRlYnVnID49IDEgJiYgY29uc29sZS5sb2coXCJVbml0IHJhdGlvczogXCIgKyBKU09OLnN0cmluZ2lmeShsKSwgbyksIGxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocy5iZWdpbiAmJiAwID09PSBWKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5iZWdpbi5jYWxsKGcsIGcpXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgaFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJzY3JvbGxcIiA9PT0gQSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHgsIFAsIEMsIFQgPSAvXngkL2kudGVzdChzLmF4aXMpID8gXCJMZWZ0XCIgOiBcIlRvcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEYgPSBwYXJzZUZsb2F0KHMub2Zmc2V0KSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5jb250YWluZXIgPyBtLmlzV3JhcHBlZChzLmNvbnRhaW5lcikgfHwgbS5pc05vZGUocy5jb250YWluZXIpID8gKHMuY29udGFpbmVyID0gcy5jb250YWluZXJbMF0gfHwgcy5jb250YWluZXIsIHggPSBzLmNvbnRhaW5lcltcInNjcm9sbFwiICsgVF0sIEMgPSB4ICsgZihvKS5wb3NpdGlvbigpW1QudG9Mb3dlckNhc2UoKV0gKyBGKSA6IHMuY29udGFpbmVyID0gbnVsbCA6ICh4ID0gYi5TdGF0ZS5zY3JvbGxBbmNob3JbYi5TdGF0ZVtcInNjcm9sbFByb3BlcnR5XCIgKyBUXV0sIFAgPSBiLlN0YXRlLnNjcm9sbEFuY2hvcltiLlN0YXRlW1wic2Nyb2xsUHJvcGVydHlcIiArIChcIkxlZnRcIiA9PT0gVCA/IFwiVG9wXCIgOiBcIkxlZnRcIildXSwgQyA9IGYobykub2Zmc2V0KClbVC50b0xvd2VyQ2FzZSgpXSArIEYpLCBsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290UHJvcGVydHlWYWx1ZTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kVmFsdWU6IEMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXRUeXBlOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IHMuZWFzaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHMuY29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRlVmFsdWU6IFBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogb1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgYi5kZWJ1ZyAmJiBjb25zb2xlLmxvZyhcInR3ZWVuc0NvbnRhaW5lciAoc2Nyb2xsKTogXCIsIGwuc2Nyb2xsLCBvKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwicmV2ZXJzZVwiID09PSBBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWkobykudHdlZW5zQ29udGFpbmVyKSByZXR1cm4gdm9pZCBmLmRlcXVldWUobywgcy5xdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vbmVcIiA9PT0gaShvKS5vcHRzLmRpc3BsYXkgJiYgKGkobykub3B0cy5kaXNwbGF5ID0gXCJhdXRvXCIpLCBcImhpZGRlblwiID09PSBpKG8pLm9wdHMudmlzaWJpbGl0eSAmJiAoaShvKS5vcHRzLnZpc2liaWxpdHkgPSBcInZpc2libGVcIiksIGkobykub3B0cy5sb29wID0gITEsIGkobykub3B0cy5iZWdpbiA9IG51bGwsIGkobykub3B0cy5jb21wbGV0ZSA9IG51bGwsIHYuZWFzaW5nIHx8IGRlbGV0ZSBzLmVhc2luZywgdi5kdXJhdGlvbiB8fCBkZWxldGUgcy5kdXJhdGlvbiwgcyA9IGYuZXh0ZW5kKHt9LCBpKG8pLm9wdHMsIHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEUgPSBmLmV4dGVuZCghMCwge30sIGkobykudHdlZW5zQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogaW4gRSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJlbGVtZW50XCIgIT09IGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEggPSBFW2pdLnN0YXJ0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVbal0uc3RhcnRWYWx1ZSA9IEVbal0uY3VycmVudFZhbHVlID0gRVtqXS5lbmRWYWx1ZSwgRVtqXS5lbmRWYWx1ZSA9IEgsIG0uaXNFbXB0eU9iamVjdCh2KSB8fCAoRVtqXS5lYXNpbmcgPSBzLmVhc2luZyksIGIuZGVidWcgJiYgY29uc29sZS5sb2coXCJyZXZlcnNlIHR3ZWVuc0NvbnRhaW5lciAoXCIgKyBqICsgXCIpOiBcIiArIEpTT04uc3RyaW5naWZ5KEVbal0pLCBvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBFXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJzdGFydFwiID09PSBBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkobykudHdlZW5zQ29udGFpbmVyICYmIGkobykuaXNBbmltYXRpbmcgPT09ICEwICYmIChFID0gaShvKS50d2VlbnNDb250YWluZXIpLCBmLmVhY2goeSwgZnVuY3Rpb24odCwgcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSZWdFeHAoXCJeXCIgKyBTLkxpc3RzLmNvbG9ycy5qb2luKFwiJHxeXCIpICsgXCIkXCIpLnRlc3QodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlKHIsICEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBuWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG5bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gblsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFMuUmVnRXguaXNIZXgudGVzdChvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IFtcIlJlZFwiLCBcIkdyZWVuXCIsIFwiQmx1ZVwiXSwgdSA9IFMuVmFsdWVzLmhleFRvUmdiKG8pLCBjID0gcyA/IFMuVmFsdWVzLmhleFRvUmdiKHMpIDogYSwgcCA9IDA7IHAgPCBsLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBbdVtwXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSAmJiBmLnB1c2goaSksIGMgIT09IGEgJiYgZi5wdXNoKGNbcF0pLCB5W3QgKyBsW3BdXSA9IGZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB5W3RdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIE4gaW4geSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBPID0gZSh5W05dKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeiA9IE9bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBPWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkID0gT1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOID0gUy5OYW1lcy5jYW1lbENhc2UoTik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE0gPSBTLkhvb2tzLmdldFJvb3QoTiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEkgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaShvKS5pc1NWRyB8fCBcInR3ZWVuXCIgPT09IE0gfHwgUy5OYW1lcy5wcmVmaXhDaGVjayhNKVsxXSAhPT0gITEgfHwgUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW01dICE9PSBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzLmRpc3BsYXkgIT09IGEgJiYgbnVsbCAhPT0gcy5kaXNwbGF5ICYmIFwibm9uZVwiICE9PSBzLmRpc3BsYXkgfHwgcy52aXNpYmlsaXR5ICE9PSBhICYmIFwiaGlkZGVuXCIgIT09IHMudmlzaWJpbGl0eSkgJiYgL29wYWNpdHl8ZmlsdGVyLy50ZXN0KE4pICYmICEkICYmIDAgIT09IHogJiYgKCQgPSAwKSwgcy5fY2FjaGVWYWx1ZXMgJiYgRSAmJiBFW05dID8gKCQgPT09IGEgJiYgKCQgPSBFW05dLmVuZFZhbHVlICsgRVtOXS51bml0VHlwZSksIEkgPSBpKG8pLnJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGVbTV0pIDogUy5Ib29rcy5yZWdpc3RlcmVkW05dID8gJCA9PT0gYSA/IChJID0gUy5nZXRQcm9wZXJ0eVZhbHVlKG8sIE0pLCAkID0gUy5nZXRQcm9wZXJ0eVZhbHVlKG8sIE4sIEkpKSA6IEkgPSBTLkhvb2tzLnRlbXBsYXRlc1tNXVsxXSA6ICQgPT09IGEgJiYgKCQgPSBTLmdldFByb3BlcnR5VmFsdWUobywgTikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQiwgVywgRywgRCA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQiA9IHAoTiwgJCksICQgPSBCWzBdLCBHID0gQlsxXSwgQiA9IHAoTiwgeiksIHogPSBCWzBdLnJlcGxhY2UoL14oWystXFwvKl0pPS8sIGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRCA9IHQsIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBXID0gQlsxXSwgJCA9IHBhcnNlRmxvYXQoJCkgfHwgMCwgeiA9IHBhcnNlRmxvYXQoeikgfHwgMCwgXCIlXCIgPT09IFcgJiYgKC9eKGZvbnRTaXplfGxpbmVIZWlnaHQpJC8udGVzdChOKSA/ICh6IC89IDEwMCwgVyA9IFwiZW1cIikgOiAvXnNjYWxlLy50ZXN0KE4pID8gKHogLz0gMTAwLCBXID0gXCJcIikgOiAvKFJlZHxHcmVlbnxCbHVlKSQvaS50ZXN0KE4pICYmICh6ID0geiAvIDEwMCAqIDI1NSwgVyA9IFwiXCIpKSwgL1tcXC8qXS8udGVzdChEKSkgVyA9IEc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEcgIT09IFcgJiYgMCAhPT0gJClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSB6KSBXID0gRztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBuIHx8IGQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgWCA9IC9tYXJnaW58cGFkZGluZ3xsZWZ0fHJpZ2h0fHdpZHRofHRleHR8d29yZHxsZXR0ZXIvaS50ZXN0KE4pIHx8IC9YJC8udGVzdChOKSB8fCBcInhcIiA9PT0gTiA/IFwieFwiIDogXCJ5XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChHKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkICo9IFwieFwiID09PSBYID8gbi5wZXJjZW50VG9QeFdpZHRoIDogbi5wZXJjZW50VG9QeEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicHhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCAqPSBuW0cgKyBcIlRvUHhcIl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChXKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkICo9IDEgLyAoXCJ4XCIgPT09IFggPyBuLnBlcmNlbnRUb1B4V2lkdGggOiBuLnBlcmNlbnRUb1B4SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicHhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCAqPSAxIC8gbltXICsgXCJUb1B4XCJdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeiA9ICQgKyB6O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ID0gJCAtIHo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHogPSAkICogejtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeiA9ICQgLyB6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbFtOXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RQcm9wZXJ0eVZhbHVlOiBJLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogJCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTogJCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFZhbHVlOiB6LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pdFR5cGU6IFcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IHFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgYi5kZWJ1ZyAmJiBjb25zb2xlLmxvZyhcInR3ZWVuc0NvbnRhaW5lciAoXCIgKyBOICsgXCIpOiBcIiArIEpTT04uc3RyaW5naWZ5KGxbTl0pLCBvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBiLmRlYnVnICYmIGNvbnNvbGUubG9nKFwiU2tpcHBpbmcgW1wiICsgTSArIFwiXSBkdWUgdG8gYSBsYWNrIG9mIGJyb3dzZXIgc3VwcG9ydC5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGwuZWxlbWVudCA9IG9cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsLmVsZW1lbnQgJiYgKFMuVmFsdWVzLmFkZENsYXNzKG8sIFwidmVsb2NpdHktYW5pbWF0aW5nXCIpLCBSLnB1c2gobCksIFwiXCIgPT09IHMucXVldWUgJiYgKGkobykudHdlZW5zQ29udGFpbmVyID0gbCwgaShvKS5vcHRzID0gcyksIGkobykuaXNBbmltYXRpbmcgPSAhMCwgViA9PT0gdyAtIDEgPyAoYi5TdGF0ZS5jYWxscy5wdXNoKFtSLCBnLCBzLCBudWxsLCBrLnJlc29sdmVyXSksIGIuU3RhdGUuaXNUaWNraW5nID09PSAhMSAmJiAoYi5TdGF0ZS5pc1RpY2tpbmcgPSAhMCwgYygpKSkgOiBWKyspXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuLCBvID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgcyA9IGYuZXh0ZW5kKHt9LCBiLmRlZmF1bHRzLCB2KSxcbiAgICAgICAgICAgICAgICAgICAgbCA9IHt9O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoaShvKSA9PT0gYSAmJiBiLmluaXQobyksIHBhcnNlRmxvYXQocy5kZWxheSkgJiYgcy5xdWV1ZSAhPT0gITEgJiYgZi5xdWV1ZShvLCBzLnF1ZXVlLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGIudmVsb2NpdHlRdWV1ZUVudHJ5RmxhZyA9ICEwLCBpKG8pLmRlbGF5VGltZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0OiBzZXRUaW1lb3V0KGUsIHBhcnNlRmxvYXQocy5kZWxheSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dDogZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksIHMuZHVyYXRpb24udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYXN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzLmR1cmF0aW9uID0gMjAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub3JtYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuZHVyYXRpb24gPSBoO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzbG93XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzLmR1cmF0aW9uID0gNjAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzLmR1cmF0aW9uID0gcGFyc2VGbG9hdChzLmR1cmF0aW9uKSB8fCAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIubW9jayAhPT0gITEgJiYgKGIubW9jayA9PT0gITAgPyBzLmR1cmF0aW9uID0gcy5kZWxheSA9IDEgOiAocy5kdXJhdGlvbiAqPSBwYXJzZUZsb2F0KGIubW9jaykgfHwgMSwgcy5kZWxheSAqPSBwYXJzZUZsb2F0KGIubW9jaykgfHwgMSkpLCBzLmVhc2luZyA9IHUocy5lYXNpbmcsIHMuZHVyYXRpb24pLCBzLmJlZ2luICYmICFtLmlzRnVuY3Rpb24ocy5iZWdpbikgJiYgKHMuYmVnaW4gPSBudWxsKSwgcy5wcm9ncmVzcyAmJiAhbS5pc0Z1bmN0aW9uKHMucHJvZ3Jlc3MpICYmIChzLnByb2dyZXNzID0gbnVsbCksIHMuY29tcGxldGUgJiYgIW0uaXNGdW5jdGlvbihzLmNvbXBsZXRlKSAmJiAocy5jb21wbGV0ZSA9IG51bGwpLCBzLmRpc3BsYXkgIT09IGEgJiYgbnVsbCAhPT0gcy5kaXNwbGF5ICYmIChzLmRpc3BsYXkgPSBzLmRpc3BsYXkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLCBcImF1dG9cIiA9PT0gcy5kaXNwbGF5ICYmIChzLmRpc3BsYXkgPSBiLkNTUy5WYWx1ZXMuZ2V0RGlzcGxheVR5cGUobykpKSwgcy52aXNpYmlsaXR5ICE9PSBhICYmIG51bGwgIT09IHMudmlzaWJpbGl0eSAmJiAocy52aXNpYmlsaXR5ID0gcy52aXNpYmlsaXR5LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSksIHMubW9iaWxlSEEgPSBzLm1vYmlsZUhBICYmIGIuU3RhdGUuaXNNb2JpbGUgJiYgIWIuU3RhdGUuaXNHaW5nZXJicmVhZCwgcy5xdWV1ZSA9PT0gITEgPyBzLmRlbGF5ID8gc2V0VGltZW91dChlLCBzLmRlbGF5KSA6IGUoKSA6IGYucXVldWUobywgcy5xdWV1ZSwgZnVuY3Rpb24odCwgcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gciA9PT0gITAgPyAoay5wcm9taXNlICYmIGsucmVzb2x2ZXIoZyksICEwKSA6IChiLnZlbG9jaXR5UXVldWVFbnRyeUZsYWcgPSAhMCwgdm9pZCBlKHQpKVxuICAgICAgICAgICAgICAgIH0pLCBcIlwiICE9PSBzLnF1ZXVlICYmIFwiZnhcIiAhPT0gcy5xdWV1ZSB8fCBcImlucHJvZ3Jlc3NcIiA9PT0gZi5xdWV1ZShvKVswXSB8fCBmLmRlcXVldWUobylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzLCBsLCBkLCBnLCB5LCB2LCB4ID0gYXJndW1lbnRzWzBdICYmIChhcmd1bWVudHNbMF0ucCB8fCBmLmlzUGxhaW5PYmplY3QoYXJndW1lbnRzWzBdLnByb3BlcnRpZXMpICYmICFhcmd1bWVudHNbMF0ucHJvcGVydGllcy5uYW1lcyB8fCBtLmlzU3RyaW5nKGFyZ3VtZW50c1swXS5wcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICBpZiAobS5pc1dyYXBwZWQodGhpcykgPyAocyA9ICExLCBkID0gMCwgZyA9IHRoaXMsIGwgPSB0aGlzKSA6IChzID0gITAsIGQgPSAxLCBnID0geCA/IGFyZ3VtZW50c1swXS5lbGVtZW50cyB8fCBhcmd1bWVudHNbMF0uZSA6IGFyZ3VtZW50c1swXSksIGcgPSBvKGcpKSB7XG4gICAgICAgICAgICAgICAgeCA/ICh5ID0gYXJndW1lbnRzWzBdLnByb3BlcnRpZXMgfHwgYXJndW1lbnRzWzBdLnAsIHYgPSBhcmd1bWVudHNbMF0ub3B0aW9ucyB8fCBhcmd1bWVudHNbMF0ubykgOiAoeSA9IGFyZ3VtZW50c1tkXSwgdiA9IGFyZ3VtZW50c1tkICsgMV0pO1xuICAgICAgICAgICAgICAgIHZhciB3ID0gZy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIFYgPSAwO1xuICAgICAgICAgICAgICAgIGlmICghL14oc3RvcHxmaW5pc2h8ZmluaXNoQWxsKSQvaS50ZXN0KHkpICYmICFmLmlzUGxhaW5PYmplY3QodikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEMgPSBkICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBUID0gQzsgVCA8IGFyZ3VtZW50cy5sZW5ndGg7IFQrKykgbS5pc0FycmF5KGFyZ3VtZW50c1tUXSkgfHwgIS9eKGZhc3R8bm9ybWFsfHNsb3cpJC9pLnRlc3QoYXJndW1lbnRzW1RdKSAmJiAhL15cXGQvLnRlc3QoYXJndW1lbnRzW1RdKSA/IG0uaXNTdHJpbmcoYXJndW1lbnRzW1RdKSB8fCBtLmlzQXJyYXkoYXJndW1lbnRzW1RdKSA/IHYuZWFzaW5nID0gYXJndW1lbnRzW1RdIDogbS5pc0Z1bmN0aW9uKGFyZ3VtZW50c1tUXSkgJiYgKHYuY29tcGxldGUgPSBhcmd1bWVudHNbVF0pIDogdi5kdXJhdGlvbiA9IGFyZ3VtZW50c1tUXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgayA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdGVyOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzICYmIGIuUHJvbWlzZSAmJiAoay5wcm9taXNlID0gbmV3IGIuUHJvbWlzZShmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGsucmVzb2x2ZXIgPSBlLCBrLnJlamVjdGVyID0gdFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB2YXIgQTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjcm9sbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgQSA9IFwic2Nyb2xsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJldmVyc2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIEEgPSBcInJldmVyc2VcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hBbGxcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0b3BcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGYuZWFjaChnLCBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSh0KSAmJiBpKHQpLmRlbGF5VGltZXIgJiYgKGNsZWFyVGltZW91dChpKHQpLmRlbGF5VGltZXIuc2V0VGltZW91dCksIGkodCkuZGVsYXlUaW1lci5uZXh0ICYmIGkodCkuZGVsYXlUaW1lci5uZXh0KCksIGRlbGV0ZSBpKHQpLmRlbGF5VGltZXIpLCBcImZpbmlzaEFsbFwiICE9PSB5IHx8IHYgIT09ICEwICYmICFtLmlzU3RyaW5nKHYpIHx8IChmLmVhY2goZi5xdWV1ZSh0LCBtLmlzU3RyaW5nKHYpID8gdiA6IFwiXCIpLCBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uaXNGdW5jdGlvbih0KSAmJiB0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgZi5xdWV1ZSh0LCBtLmlzU3RyaW5nKHYpID8gdiA6IFwiXCIsIFtdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEYgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmLmVhY2goYi5TdGF0ZS5jYWxscywgZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgJiYgZi5lYWNoKHRbMV0sIGZ1bmN0aW9uKHIsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB2ID09PSBhID8gXCJcIiA6IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvID09PSAhMCB8fCB0WzJdLnF1ZXVlID09PSBvIHx8IHYgPT09IGEgJiYgdFsyXS5xdWV1ZSA9PT0gITEgPyB2b2lkIGYuZWFjaChnLCBmdW5jdGlvbihyLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID09PSBuICYmICgodiA9PT0gITAgfHwgbS5pc1N0cmluZyh2KSkgJiYgKGYuZWFjaChmLnF1ZXVlKGEsIG0uaXNTdHJpbmcodikgPyB2IDogXCJcIiksIGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmlzRnVuY3Rpb24odCkgJiYgdChudWxsLCAhMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBmLnF1ZXVlKGEsIG0uaXNTdHJpbmcodikgPyB2IDogXCJcIiwgW10pKSwgXCJzdG9wXCIgPT09IHkgPyAoaShhKSAmJiBpKGEpLnR3ZWVuc0NvbnRhaW5lciAmJiBvICE9PSAhMSAmJiBmLmVhY2goaShhKS50d2VlbnNDb250YWluZXIsIGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LmVuZFZhbHVlID0gdC5jdXJyZW50VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBGLnB1c2goZSkpIDogKFwiZmluaXNoXCIgPT09IHkgfHwgXCJmaW5pc2hBbGxcIiA9PT0geSkgJiYgKHRbMl0uZHVyYXRpb24gPSAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgXCJzdG9wXCIgPT09IHkgJiYgKGYuZWFjaChGLCBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCh0LCAhMClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBrLnByb21pc2UgJiYgay5yZXNvbHZlcihnKSksIGUoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZi5pc1BsYWluT2JqZWN0KHkpIHx8IG0uaXNFbXB0eU9iamVjdCh5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLmlzU3RyaW5nKHkpICYmIGIuUmVkaXJlY3RzW3ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBFID0gZi5leHRlbmQoe30sIHYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IEUuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIID0gRS5kZWxheSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRS5iYWNrd2FyZHMgPT09ICEwICYmIChnID0gZi5leHRlbmQoITAsIFtdLCBnKS5yZXZlcnNlKCkpLCBmLmVhY2goZywgZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChFLnN0YWdnZXIpID8gRS5kZWxheSA9IEggKyBwYXJzZUZsb2F0KEUuc3RhZ2dlcikgKiBlIDogbS5pc0Z1bmN0aW9uKEUuc3RhZ2dlcikgJiYgKEUuZGVsYXkgPSBIICsgRS5zdGFnZ2VyLmNhbGwodCwgZSwgdykpLCBFLmRyYWcgJiYgKEUuZHVyYXRpb24gPSBwYXJzZUZsb2F0KGopIHx8ICgvXihjYWxsb3V0fHRyYW5zaXRpb24pLy50ZXN0KHkpID8gMWUzIDogaCksIEUuZHVyYXRpb24gPSBNYXRoLm1heChFLmR1cmF0aW9uICogKEUuYmFja3dhcmRzID8gMSAtIGUgLyB3IDogKGUgKyAxKSAvIHcpLCAuNzUgKiBFLmR1cmF0aW9uLCAyMDApKSwgYi5SZWRpcmVjdHNbeV0uY2FsbCh0LCB0LCBFIHx8IHt9LCBlLCB3LCBnLCBrLnByb21pc2UgPyBrIDogYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTiA9IFwiVmVsb2NpdHk6IEZpcnN0IGFyZ3VtZW50IChcIiArIHkgKyBcIikgd2FzIG5vdCBhIHByb3BlcnR5IG1hcCwgYSBrbm93biBhY3Rpb24sIG9yIGEgcmVnaXN0ZXJlZCByZWRpcmVjdC4gQWJvcnRpbmcuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGsucHJvbWlzZSA/IGsucmVqZWN0ZXIobmV3IEVycm9yKE4pKSA6IGNvbnNvbGUubG9nKE4pLCBlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIEEgPSBcInN0YXJ0XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIEwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBvc2l0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEZvbnRTaXplOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBlcmNlbnRUb1B4V2lkdGg6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGVyY2VudFRvUHhIZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RW1Ub1B4OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtVG9QeDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZ3VG9QeDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZoVG9QeDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBSID0gW107XG4gICAgICAgICAgICAgICAgZi5lYWNoKGcsIGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbS5pc05vZGUodCkgJiYgbi5jYWxsKHQpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIE8sIEUgPSBmLmV4dGVuZCh7fSwgYi5kZWZhdWx0cywgdik7XG4gICAgICAgICAgICAgICAgaWYgKEUubG9vcCA9IHBhcnNlSW50KEUubG9vcCksIE8gPSAyICogRS5sb29wIC0gMSwgRS5sb29wKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gMDsgTyA+IHo7IHorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IEUuZGVsYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IEUucHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB6ID09PSBPIC0gMSAmJiAocS5kaXNwbGF5ID0gRS5kaXNwbGF5LCBxLnZpc2liaWxpdHkgPSBFLnZpc2liaWxpdHksIHEuY29tcGxldGUgPSBFLmNvbXBsZXRlKSwgUChnLCBcInJldmVyc2VcIiwgcSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYiA9IGYuZXh0ZW5kKFAsIGIpLCBiLmFuaW1hdGUgPSBQO1xuICAgICAgICB2YXIgdyA9IHQucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGc7XG4gICAgICAgIHJldHVybiBiLlN0YXRlLmlzTW9iaWxlIHx8IHIuaGlkZGVuID09PSBhIHx8IHIuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByLmhpZGRlbiA/ICh3ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBlKCEwKVxuICAgICAgICAgICAgICAgIH0sIDE2KVxuICAgICAgICAgICAgfSwgYygpKSA6IHcgPSB0LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnXG4gICAgICAgIH0pLCBlLlZlbG9jaXR5ID0gYiwgZSAhPT0gdCAmJiAoZS5mbi52ZWxvY2l0eSA9IFAsIGUuZm4udmVsb2NpdHkuZGVmYXVsdHMgPSBiLmRlZmF1bHRzKSwgZi5lYWNoKFtcIkRvd25cIiwgXCJVcFwiXSwgZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgYi5SZWRpcmVjdHNbXCJzbGlkZVwiICsgdF0gPSBmdW5jdGlvbihlLCByLCBuLCBvLCBpLCBzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBmLmV4dGVuZCh7fSwgciksXG4gICAgICAgICAgICAgICAgICAgIHUgPSBsLmJlZ2luLFxuICAgICAgICAgICAgICAgICAgICBjID0gbC5jb21wbGV0ZSxcbiAgICAgICAgICAgICAgICAgICAgcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGQgPSB7fTtcbiAgICAgICAgICAgICAgICBsLmRpc3BsYXkgPT09IGEgJiYgKGwuZGlzcGxheSA9IFwiRG93blwiID09PSB0ID8gXCJpbmxpbmVcIiA9PT0gYi5DU1MuVmFsdWVzLmdldERpc3BsYXlUeXBlKGUpID8gXCJpbmxpbmUtYmxvY2tcIiA6IFwiYmxvY2tcIiA6IFwibm9uZVwiKSwgbC5iZWdpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB1ICYmIHUuY2FsbChpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciBpbiBwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkW3JdID0gZS5zdHlsZVtyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gYi5DU1MuZ2V0UHJvcGVydHlWYWx1ZShlLCByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBbcl0gPSBcIkRvd25cIiA9PT0gdCA/IFthLCAwXSA6IFswLCBhXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGQub3ZlcmZsb3cgPSBlLnN0eWxlLm92ZXJmbG93LCBlLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIlxuICAgICAgICAgICAgICAgIH0sIGwuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCBpbiBkKSBlLnN0eWxlW3RdID0gZFt0XTtcbiAgICAgICAgICAgICAgICAgICAgYyAmJiBjLmNhbGwoaSwgaSksIHMgJiYgcy5yZXNvbHZlcihpKVxuICAgICAgICAgICAgICAgIH0sIGIoZSwgcCwgbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIGYuZWFjaChbXCJJblwiLCBcIk91dFwiXSwgZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgYi5SZWRpcmVjdHNbXCJmYWRlXCIgKyB0XSA9IGZ1bmN0aW9uKGUsIHIsIG4sIG8sIGksIHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGYuZXh0ZW5kKHt9LCByKSxcbiAgICAgICAgICAgICAgICAgICAgdSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiSW5cIiA9PT0gdCA/IDEgOiAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGMgPSBsLmNvbXBsZXRlO1xuICAgICAgICAgICAgICAgIGwuY29tcGxldGUgPSBuICE9PSBvIC0gMSA/IGwuYmVnaW4gPSBudWxsIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGMgJiYgYy5jYWxsKGksIGkpLCBzICYmIHMucmVzb2x2ZXIoaSlcbiAgICAgICAgICAgICAgICB9LCBsLmRpc3BsYXkgPT09IGEgJiYgKGwuZGlzcGxheSA9IFwiSW5cIiA9PT0gdCA/IFwiYXV0b1wiIDogXCJub25lXCIpLCBiKHRoaXMsIHUsIGwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBiXG4gICAgfSh3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0byB8fCB3aW5kb3csIHdpbmRvdywgZG9jdW1lbnQpXG59KTtcbiJdLCJmaWxlIjoidmVsb2NpdHkubWluLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
